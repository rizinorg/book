<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Official Rizin Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Official Rizin Book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first_steps/overview.html"><strong aria-hidden="true">1.1.</strong> The Framework</a></li><li class="chapter-item expanded "><a href="first_steps/getting_rizin.html"><strong aria-hidden="true">1.2.</strong> Downloading rizin</a></li><li class="chapter-item expanded "><a href="first_steps/compilation_portability.html"><strong aria-hidden="true">1.3.</strong> Compilation and Portability</a></li><li class="chapter-item expanded "><a href="first_steps/windows_compilation.html"><strong aria-hidden="true">1.4.</strong> Compilation on Windows</a></li><li class="chapter-item expanded "><a href="first_steps/compilation_android.html"><strong aria-hidden="true">1.5.</strong> Compilation on Android</a></li></ol></li><li class="chapter-item expanded "><a href="first_steps/intro.html"><strong aria-hidden="true">2.</strong> First Steps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first_steps/commandline_flags.html"><strong aria-hidden="true">2.1.</strong> Command-line Flags</a></li><li class="chapter-item expanded "><a href="first_steps/command_format.html"><strong aria-hidden="true">2.2.</strong> Command Format</a></li><li class="chapter-item expanded "><a href="first_steps/expressions.html"><strong aria-hidden="true">2.3.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="first_steps/basic_debugger_session.html"><strong aria-hidden="true">2.4.</strong> Basic Debugger Session</a></li><li class="chapter-item expanded "><a href="first_steps/contributing.html"><strong aria-hidden="true">2.5.</strong> Contributing to rizin</a></li></ol></li><li class="chapter-item expanded "><a href="configuration/intro.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="configuration/colors.html"><strong aria-hidden="true">3.1.</strong> Colors</a></li><li class="chapter-item expanded "><a href="configuration/evars.html"><strong aria-hidden="true">3.2.</strong> Configuration Variables</a></li><li class="chapter-item expanded "><a href="configuration/files.html"><strong aria-hidden="true">3.3.</strong> Files</a></li></ol></li><li class="chapter-item expanded "><a href="basic_commands/intro.html"><strong aria-hidden="true">4.</strong> Basic Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_commands/seeking.html"><strong aria-hidden="true">4.1.</strong> Seeking</a></li><li class="chapter-item expanded "><a href="basic_commands/block_size.html"><strong aria-hidden="true">4.2.</strong> Block Size</a></li><li class="chapter-item expanded "><a href="basic_commands/sections.html"><strong aria-hidden="true">4.3.</strong> Sections</a></li><li class="chapter-item expanded "><a href="basic_commands/mapping_files.html"><strong aria-hidden="true">4.4.</strong> Mapping Files</a></li><li class="chapter-item expanded "><a href="basic_commands/print_modes.html"><strong aria-hidden="true">4.5.</strong> Print Modes</a></li><li class="chapter-item expanded "><a href="basic_commands/flags.html"><strong aria-hidden="true">4.6.</strong> Flags</a></li><li class="chapter-item expanded "><a href="basic_commands/write.html"><strong aria-hidden="true">4.7.</strong> Write</a></li><li class="chapter-item expanded "><a href="basic_commands/zoom.html"><strong aria-hidden="true">4.8.</strong> Zoom</a></li><li class="chapter-item expanded "><a href="basic_commands/yank_paste.html"><strong aria-hidden="true">4.9.</strong> Yank/Paste</a></li><li class="chapter-item expanded "><a href="basic_commands/comparing_bytes.html"><strong aria-hidden="true">4.10.</strong> Comparing Bytes</a></li><li class="chapter-item expanded "><a href="basic_commands/sdb.html"><strong aria-hidden="true">4.11.</strong> SDB</a></li><li class="chapter-item expanded "><a href="basic_commands/dietline.html"><strong aria-hidden="true">4.12.</strong> Dietline</a></li></ol></li><li class="chapter-item expanded "><a href="visual_mode/intro.html"><strong aria-hidden="true">5.</strong> Visual mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="visual_mode/visual_disassembly.html"><strong aria-hidden="true">5.1.</strong> Visual Disassembly</a></li><li class="chapter-item expanded "><a href="visual_mode/visual_assembler.html"><strong aria-hidden="true">5.2.</strong> Visual Assembler</a></li><li class="chapter-item expanded "><a href="visual_mode/visual_configuration_editor.html"><strong aria-hidden="true">5.3.</strong> Visual Configuration Editor</a></li><li class="chapter-item expanded "><a href="visual_mode/visual_panels.html"><strong aria-hidden="true">5.4.</strong> Visual Panels</a></li></ol></li><li class="chapter-item expanded "><a href="search_bytes/intro.html"><strong aria-hidden="true">6.</strong> Searching bytes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="search_bytes/basic_searches.html"><strong aria-hidden="true">6.1.</strong> Basic Searches</a></li><li class="chapter-item expanded "><a href="search_bytes/configurating_the_search.html"><strong aria-hidden="true">6.2.</strong> Configurating the Search</a></li><li class="chapter-item expanded "><a href="search_bytes/pattern_search.html"><strong aria-hidden="true">6.3.</strong> Pattern Search</a></li><li class="chapter-item expanded "><a href="search_bytes/automation.html"><strong aria-hidden="true">6.4.</strong> Automation</a></li><li class="chapter-item expanded "><a href="search_bytes/backward_search.html"><strong aria-hidden="true">6.5.</strong> Backward Search</a></li><li class="chapter-item expanded "><a href="search_bytes/search_in_assembly.html"><strong aria-hidden="true">6.6.</strong> Search in Assembly</a></li><li class="chapter-item expanded "><a href="search_bytes/searching_aes_keys.html"><strong aria-hidden="true">6.7.</strong> Searching for AES Keys</a></li></ol></li><li class="chapter-item expanded "><a href="disassembling/intro.html"><strong aria-hidden="true">7.</strong> Disassembling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disassembling/adding_metadata.html"><strong aria-hidden="true">7.1.</strong> Adding Metadata</a></li><li class="chapter-item expanded "><a href="disassembling/esil.html"><strong aria-hidden="true">7.2.</strong> ESIL</a></li></ol></li><li class="chapter-item expanded "><a href="analysis/intro.html"><strong aria-hidden="true">8.</strong> Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="analysis/code_analysis.html"><strong aria-hidden="true">8.1.</strong> Code Analysis</a></li><li class="chapter-item expanded "><a href="analysis/variables.html"><strong aria-hidden="true">8.2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="analysis/types.html"><strong aria-hidden="true">8.3.</strong> Types</a></li><li class="chapter-item expanded "><a href="analysis/calling_conventions.html"><strong aria-hidden="true">8.4.</strong> Calling Conventions</a></li><li class="chapter-item expanded "><a href="analysis/vtables.html"><strong aria-hidden="true">8.5.</strong> Virtual Tables</a></li><li class="chapter-item expanded "><a href="analysis/syscalls.html"><strong aria-hidden="true">8.6.</strong> Syscalls</a></li><li class="chapter-item expanded "><a href="analysis/emulation.html"><strong aria-hidden="true">8.7.</strong> Emulation</a></li><li class="chapter-item expanded "><a href="analysis/symbols.html"><strong aria-hidden="true">8.8.</strong> Symbols information</a></li><li class="chapter-item expanded "><a href="signatures/zignatures.html"><strong aria-hidden="true">8.9.</strong> Signatures</a></li><li class="chapter-item expanded "><a href="analysis/graphs.html"><strong aria-hidden="true">8.10.</strong> Graph commands</a></li><li class="chapter-item expanded "><a href="analysis/cpu_platform_profiles.html"><strong aria-hidden="true">8.11.</strong> CPU and platform profiles</a></li></ol></li><li class="chapter-item expanded "><a href="scripting/intro.html"><strong aria-hidden="true">9.</strong> Scripting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scripting/loops.html"><strong aria-hidden="true">9.1.</strong> Loops</a></li><li class="chapter-item expanded "><a href="scripting/macros.html"><strong aria-hidden="true">9.2.</strong> Macros</a></li><li class="chapter-item expanded "><a href="scripting/rz-pipe.html"><strong aria-hidden="true">9.3.</strong> Rz-pipe</a></li></ol></li><li class="chapter-item expanded "><a href="debugger/intro.html"><strong aria-hidden="true">10.</strong> Debugger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debugger/getting_started.html"><strong aria-hidden="true">10.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="debugger/migration.html"><strong aria-hidden="true">10.2.</strong> Migration from ida, GDB or WinDBG</a></li><li class="chapter-item expanded "><a href="debugger/registers.html"><strong aria-hidden="true">10.3.</strong> Registers</a></li><li class="chapter-item expanded "><a href="debugger/memory_maps.html"><strong aria-hidden="true">10.4.</strong> Memory Maps</a></li><li class="chapter-item expanded "><a href="debugger/heap.html"><strong aria-hidden="true">10.5.</strong> Heap</a></li><li class="chapter-item expanded "><a href="debugger/files.html"><strong aria-hidden="true">10.6.</strong> Files</a></li><li class="chapter-item expanded "><a href="debugger/revdebug.html"><strong aria-hidden="true">10.7.</strong> Reverse Debugging</a></li><li class="chapter-item expanded "><a href="debugger/windows_messages.html"><strong aria-hidden="true">10.8.</strong> Windows Messages</a></li><li class="chapter-item expanded "><a href="debugger/apple.html"><strong aria-hidden="true">10.9.</strong> macOS/iOS</a></li></ol></li><li class="chapter-item expanded "><a href="debugger/remoting_capabilities.html"><strong aria-hidden="true">11.</strong> Remote Access</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debugger/remote_gdb.html"><strong aria-hidden="true">11.1.</strong> Remote GDB</a></li><li class="chapter-item expanded "><a href="debugger/windbg.html"><strong aria-hidden="true">11.2.</strong> Remote WinDbg</a></li></ol></li><li class="chapter-item expanded "><a href="tools/intro.html"><strong aria-hidden="true">12.</strong> Command Line Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rz-ax/intro.html"><strong aria-hidden="true">12.1.</strong> Rz-ax</a></li><li class="chapter-item expanded "><a href="tools/rz-find/intro.html"><strong aria-hidden="true">12.2.</strong> Rz-find</a></li><li class="chapter-item expanded "><a href="tools/rz-run/intro.html"><strong aria-hidden="true">12.3.</strong> Rz-run</a></li><li class="chapter-item expanded "><a href="tools/rz-bin/intro.html"><strong aria-hidden="true">12.4.</strong> Rz-bin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rz-bin/file_identification.html"><strong aria-hidden="true">12.4.1.</strong> File Identification</a></li><li class="chapter-item expanded "><a href="tools/rz-bin/entrypoints.html"><strong aria-hidden="true">12.4.2.</strong> Entrypoint</a></li><li class="chapter-item expanded "><a href="tools/rz-bin/imports.html"><strong aria-hidden="true">12.4.3.</strong> Imports</a></li><li class="chapter-item expanded "><a href="tools/rz-bin/exports.html"><strong aria-hidden="true">12.4.4.</strong> Exports</a></li><li class="chapter-item expanded "><a href="tools/rz-bin/symbols.html"><strong aria-hidden="true">12.4.5.</strong> Symbols (exports)</a></li><li class="chapter-item expanded "><a href="tools/rz-bin/libraries.html"><strong aria-hidden="true">12.4.6.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="tools/rz-bin/strings.html"><strong aria-hidden="true">12.4.7.</strong> Strings</a></li><li class="chapter-item expanded "><a href="tools/rz-bin/program_sections.html"><strong aria-hidden="true">12.4.8.</strong> Program Sections</a></li></ol></li><li class="chapter-item expanded "><a href="tools/rz-diff/intro.html"><strong aria-hidden="true">12.5.</strong> Rz-diff</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rz-diff/binary_diffing.html"><strong aria-hidden="true">12.5.1.</strong> Binary Diffing</a></li></ol></li><li class="chapter-item expanded "><a href="tools/rz-asm/intro.html"><strong aria-hidden="true">12.6.</strong> Rz-asm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rz-asm/assemble.html"><strong aria-hidden="true">12.6.1.</strong> Assemble</a></li><li class="chapter-item expanded "><a href="tools/rz-asm/disassemble.html"><strong aria-hidden="true">12.6.2.</strong> Disassemble</a></li><li class="chapter-item expanded "><a href="tools/rz-asm/config.html"><strong aria-hidden="true">12.6.3.</strong> Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="tools/rz-gg/rz-gg.html"><strong aria-hidden="true">12.7.</strong> Rz-gg</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rz-gg/lang.html"><strong aria-hidden="true">12.7.1.</strong> Language</a></li></ol></li><li class="chapter-item expanded "><a href="tools/rz-hash/intro.html"><strong aria-hidden="true">12.8.</strong> Rz-hash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rz-hash/rz-hash_tool.html"><strong aria-hidden="true">12.8.1.</strong> Rz-hash Tool</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="plugins/intro.html"><strong aria-hidden="true">13.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugins/ioplugins.html"><strong aria-hidden="true">13.1.</strong> IO plugins</a></li><li class="chapter-item expanded "><a href="plugins/dev-asm.html"><strong aria-hidden="true">13.2.</strong> Asm plugins</a></li><li class="chapter-item expanded "><a href="plugins/dev-analysis.html"><strong aria-hidden="true">13.3.</strong> Analysis plugins</a></li><li class="chapter-item expanded "><a href="plugins/dev-bin.html"><strong aria-hidden="true">13.4.</strong> Bin plugins</a></li><li class="chapter-item expanded "><a href="plugins/dev-other.html"><strong aria-hidden="true">13.5.</strong> Other plugins</a></li><li class="chapter-item expanded "><a href="plugins/python.html"><strong aria-hidden="true">13.6.</strong> Python plugins</a></li><li class="chapter-item expanded "><a href="plugins/debug.html"><strong aria-hidden="true">13.7.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="plugins/testing.html"><strong aria-hidden="true">13.8.</strong> Testing</a></li><li class="chapter-item expanded "><a href="plugins/rz-pm.html"><strong aria-hidden="true">13.9.</strong> Packaging</a></li></ol></li><li class="chapter-item expanded "><a href="crackmes/intro.html"><strong aria-hidden="true">14.</strong> Crackmes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crackmes/ioli/intro.html"><strong aria-hidden="true">14.1.</strong> IOLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x00.html"><strong aria-hidden="true">14.1.1.</strong> IOLI 0x00</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x01.html"><strong aria-hidden="true">14.1.2.</strong> IOLI 0x01</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x02.html"><strong aria-hidden="true">14.1.3.</strong> IOLI 0x02</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x03.html"><strong aria-hidden="true">14.1.4.</strong> IOLI 0x03</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x04.html"><strong aria-hidden="true">14.1.5.</strong> IOLI 0x04</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x05.html"><strong aria-hidden="true">14.1.6.</strong> IOLI 0x05</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x06.html"><strong aria-hidden="true">14.1.7.</strong> IOLI 0x06</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x07.html"><strong aria-hidden="true">14.1.8.</strong> IOLI 0x07</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x08.html"><strong aria-hidden="true">14.1.9.</strong> IOLI 0x08</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x09.html"><strong aria-hidden="true">14.1.10.</strong> IOLI 0x09</a></li></ol></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/intro.html"><strong aria-hidden="true">14.2.</strong> Avatao R3v3rs3 4</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/rizin.html"><strong aria-hidden="true">14.2.1.</strong> .rizin</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/first_steps.html"><strong aria-hidden="true">14.2.2.</strong> .first_steps</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/main.html"><strong aria-hidden="true">14.2.3.</strong> .main</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/vmloop.html"><strong aria-hidden="true">14.2.4.</strong> .vmloop</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/instructionset.html"><strong aria-hidden="true">14.2.5.</strong> .instructionset</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/bytecode.html"><strong aria-hidden="true">14.2.6.</strong> .bytecode</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/outro.html"><strong aria-hidden="true">14.2.7.</strong> .outro</a></li></ol></li><li class="chapter-item expanded "><a href="crackmes/hackthebox/intro.html"><strong aria-hidden="true">14.3.</strong> Hack The Box</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crackmes/hackthebox/find-the-easy-pass/intro.html"><strong aria-hidden="true">14.3.1.</strong> Find The Easy Pass</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crackmes/hackthebox/find-the-easy-pass/identification.html"><strong aria-hidden="true">14.3.1.1.</strong> identification</a></li><li class="chapter-item expanded "><a href="crackmes/hackthebox/find-the-easy-pass/find-the-validation-routine.html"><strong aria-hidden="true">14.3.1.2.</strong> find-the-valiation-routine</a></li><li class="chapter-item expanded "><a href="crackmes/hackthebox/find-the-easy-pass/fire-up-the-debugger.html"><strong aria-hidden="true">14.3.1.3.</strong> fire-up-the-debugger</a></li><li class="chapter-item expanded "><a href="crackmes/hackthebox/find-the-easy-pass/bonus.html"><strong aria-hidden="true">14.3.1.4.</strong> bonus</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="refcard/intro.html"><strong aria-hidden="true">15.</strong> Reference Card</a></li><li class="chapter-item expanded "><a href="credits/credits.html"><strong aria-hidden="true">16.</strong> Acknowledgments</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Official Rizin Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is a book about <a href="https://rizin.re">Rizin</a> reverse engineering framework and it's originally
based on the <a href="https://github.com/radareorg/radare2book">radare2 book</a></p>
<p>Check the Github site to add new contents or fix typos:</p>
<ul>
<li>Github: <a href="https://github.com/rizinorg/book">https://github.com/rizinorg/book</a></li>
<li>Online: <a href="https://book.rizin.re">https://book.rizin.re/</a></li>
</ul>
<h2 id="offline"><a class="header" href="#offline">Offline</a></h2>
<p>For offline use you need to fetch the <a href="https://github.com/rust-lang/mdBook">mdbook</a> tool and run the build locally:</p>
<pre><code class="language-sh">mdbook serve
</code></pre>
<p>After that, you can point your Web-browser to <code>http://localhost:3000</code> and read it offline.</p>
<h2 id="the-framework"><a class="header" href="#the-framework">The Framework</a></h2>
<p>The Rizin project is a set of small command-line utilities that can be used together or independently.</p>
<p>This chapter will give you a quick understanding of them, but you can check the dedicated sections for each tool at the end of this book.</p>
<h3 id="rizin"><a class="header" href="#rizin">rizin</a></h3>
<p>The main tool of the whole framework. It uses the core of the hexadecimal editor and debugger. rizin allows you to open a number of input/output sources as if they were simple, plain files, including disks, network connections, kernel drivers, processes under debugging, and so on.</p>
<p>It implements an advanced command line interface for moving around a file, analyzing data, disassembling, binary patching, data comparison, searching, replacing, and visualizing. It can be scripted with a variety of languages, including Python, Haskell, OCaml, JavaScript, and others.</p>
<h3 id="rz-bin"><a class="header" href="#rz-bin">rz-bin</a></h3>
<p>A program to extract information from executable binaries, such as ELF, PE, Java CLASS, Mach-O, plus any format supported by rizin plugins. rz-bin is used by the core to get data like exported symbols, imports, file information, cross references (xrefs), library dependencies, and sections.</p>
<h3 id="rz-asm"><a class="header" href="#rz-asm">rz-asm</a></h3>
<p>A command line assembler and disassembler for multiple architectures (including Intel x86 and x86-64, MIPS, ARM, PowerPC, Java, and myriad of others).</p>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<pre><code>$ rz-asm -a java 'nop'
00
</code></pre>
<pre><code>$ rz-asm -a x86 -d '90'
nop
</code></pre>
<pre><code>$ rz-asm -a x86 -b 32 'mov eax, 33'
b821000000
</code></pre>
<pre><code>$ echo 'push eax;nop;nop' | rz-asm -f -
509090
</code></pre>
<h3 id="rz-hash"><a class="header" href="#rz-hash">rz-hash</a></h3>
<p>An implementation of a block-based hash tool. From small text strings to large disks, rz-hash supports multiple algorithms, including MD4, MD5, CRC16, CRC32, SHA1, SHA256, and others.
rz-hash can be used to check the integrity or track changes of big files, memory dumps, or disks.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code>$ rz-hash file
file: 0x00000000-0x00000007 sha256: 887cfbd0d44aaff69f7bdbedebd282ec96191cce9d7fa7336298a18efc3c7a5a
</code></pre>
<pre><code>$ rz-hash -a md5 file
file: 0x00000000-0x00000007 md5: d1833805515fc34b46c2b9de553f599d
</code></pre>
<h3 id="rz-diff"><a class="header" href="#rz-diff">rz-diff</a></h3>
<p>A binary diffing utility that implements multiple algorithms. It supports byte-level or delta diffing for binary files, and code-analysis diffing to find changes in basic code blocks obtained from the rizin code analysis.</p>
<h3 id="rz-find"><a class="header" href="#rz-find">rz-find</a></h3>
<p>A program to find byte patterns in files.</p>
<h3 id="rz-egg"><a class="header" href="#rz-egg">rz-egg</a></h3>
<p>A frontend for r_egg. rz-egg compiles programs written in a simple high-level language into tiny binaries for x86, x86-64, and ARM.</p>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples</a></h4>
<pre><code>$ cat hi.r
/* hello world in r_egg */
write@syscall(4); //x64 write@syscall(1);
exit@syscall(1); //x64 exit@syscall(60);

main@global(128) {
 .var0 = &quot;hi!\n&quot;;
 write(1,.var0, 4);
 exit(0);
}
$ rz-egg -O -F hi.r
$ ./hi
hi!

$ cat hi.c
main@global(0,6) {
 write(1, &quot;Hello0&quot;, 6);
 exit(0);
}
$ rz-egg hi.c
$ ./hi.c.bin
Hello
</code></pre>
<h3 id="rz-run"><a class="header" href="#rz-run">rz-run</a></h3>
<p>A launcher for running programs within different environments, with different arguments,
permissions, directories, and overridden default file descriptors. rz-run is useful for:</p>
<ul>
<li>Solving crackmes</li>
<li>Fuzzing</li>
<li>Test suites</li>
</ul>
<h4 id="sample-rz-run-script"><a class="header" href="#sample-rz-run-script">Sample rz-run script</a></h4>
<pre><code>$ cat foo.rrz
#!/usr/bin/rz-run
program=./pp400
arg0=10
stdin=foo.txt
chdir=/tmp
#chroot=.
./foo.rrz
</code></pre>
<h4 id="connecting-a-program-with-a-socket"><a class="header" href="#connecting-a-program-with-a-socket">Connecting a Program with a Socket</a></h4>
<pre><code>$ nc -l 9999
$ rz-run program=/bin/ls connect=localhost:9999
</code></pre>
<h4 id="debugging-a-program-redirecting-the-stdio-into-another-terminal"><a class="header" href="#debugging-a-program-redirecting-the-stdio-into-another-terminal">Debugging a Program Redirecting the stdio into Another Terminal</a></h4>
<p>1 - open a new terminal and type 'tty' to get a terminal name:</p>
<pre><code>$ tty ; clear ; sleep 999999
/dev/ttyS010
</code></pre>
<p>2 - Create a new file containing the following rz-run profile named foo.rrz:</p>
<pre><code>#!/usr/bin/rz-run
program=/bin/ls
stdio=/dev/ttys010
</code></pre>
<p>3 - Launch the following rizin command:</p>
<pre><code>rizin -r foo.rrz -d /bin/ls
</code></pre>
<h3 id="rz-ax"><a class="header" href="#rz-ax">rz-ax</a></h3>
<p>A minimalistic mathematical expression evaluator for the shell that is useful for making base conversions between floating point values, hexadecimal representations, hexpair strings to ASCII, octal to integer, and more. It also supports endianness settings and can be used as an interactive shell if no arguments are given.</p>
<h4 id="examples-3"><a class="header" href="#examples-3">Examples</a></h4>
<pre><code>$ rz-ax 1337
0x539

$ rz-ax 0x400000
4194304

$ rz-ax -b 01111001
y

$ rz-ax -S rizin
72616461726532

$ rz-ax -s 617765736f6d65
awesome
</code></pre>
<h2 id="downloading-rizin"><a class="header" href="#downloading-rizin">Downloading rizin</a></h2>
<p>Binary packages are available for most of the common platforms (e.g. Windows, MacOS, Linux), however you can still compile rizin yourself for many other architectures/operating systems.</p>
<p>Please have a look at the <a href="https://github.com/rizinorg/rizin/releases">releases</a> tab of Rizin's GitHub repository for the binary packages.
See <a href="https://github.com/rizinorg/rizin/blob/dev/BUILDING.md">BUILDING.md</a> for more detailed instructions on how to build the tool.</p>
<h2 id="compilation-and-portability"><a class="header" href="#compilation-and-portability">Compilation and Portability</a></h2>
<p>Currently the core of rizin can be compiled on many systems and architectures, but the main development is done on GNU/Linux with GCC, and on MacOS X with clang. Rizin is also known to compile on many different systems and architectures (including TCC and SunStudio).</p>
<p>People often want to use rizin as a debugger for reverse engineering. Currently, the debugger layer can be used on Windows, GNU/Linux (Intel x86 and x86_64, MIPS, and ARM), OS X, FreeBSD, NetBSD, and OpenBSD (Intel x86 and x86_64)..</p>
<p>Compared to core, the debugger feature is more restrictive portability-wise. If the debugger has not been ported to your favorite platform, you can disable the debugger layer with the meson option <code>-Ddebugger=false</code>. Have a look at <a href="https://github.com/rizinorg/rizin/blob/dev/BUILDING.md">BUILDING.md</a> for more information.</p>
<p>Note that there are I/O plugins that use GDB, WinDbg, or Wine as back-ends, and therefore rely on presence of corresponding third-party tools (in case of remote debugging - just on the target machine).</p>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>Rizin repository ships a <a href="https://github.com/rizinorg/rizin/blob/master/Dockerfile">Dockerfile</a> that you can use with Docker.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>Rizin relies on the Meson build system generator to support compilation on all platforms, including Windows. Meson will generate a Visual Studio Solution, all the necessary project files, and wire up the Microsoft Visual C++ compiler for you.</p>
<blockquote>
<p><strong>tip</strong> You can download nightly binaries from https://ci.appveyor.com/project/rizinorg/rizin/history. Be sure to download only from <code>master</code> branch!</p>
</blockquote>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>Visual Studio 2015 (or higher)</li>
<li>Python 3</li>
<li>Meson</li>
<li>Git</li>
</ul>
<h3 id="step-by-step"><a class="header" href="#step-by-step">Step-by-Step</a></h3>
<h4 id="install-visual-studio-2015-or-higher"><a class="header" href="#install-visual-studio-2015-or-higher">Install Visual Studio 2015 (or higher)</a></h4>
<p>Visual Studio must be installed with a Visual C++ compiler, supporting C++ libraries, and the appropriate Windows SDK for the target platform version.</p>
<ul>
<li>In the Visual Studio 2015 installer, ensure <code>Programming Languages &gt; Visual C++</code> is selected</li>
<li>In the Visual Studio 2017+ installers, ensure the <code>Desktop development with C++</code> workload is selected</li>
</ul>
<p>If you need a copy of Visual Studio, the Community versions are free and work great.</p>
<ul>
<li><a href="https://my.visualstudio.com/Downloads?q=Visual%20Studio%202015%20with%20Update%203">Download Visual Studio 2015 Community (registration required)</a></li>
<li><a href="https://visualstudio.microsoft.com/downloads/">Download Visual Studio 2017 Community</a></li>
<li><a href="https://visualstudio.microsoft.com/downloads/">Download Visual Studio 2019 Community</a></li>
</ul>
<h4 id="install-python-3-and-mesonninja-via-conda"><a class="header" href="#install-python-3-and-mesonninja-via-conda">Install Python 3 and Meson/Ninja via Conda</a></h4>
<p>It is strongly recommended you install Conda — a Python environment management system — when working with Python on the Windows platform. This will isolate the Rizin build environment from other installed Python versions and minimize potential conflicts.</p>
<h5 id="set-up-conda"><a class="header" href="#set-up-conda">Set Up Conda:</a></h5>
<ol>
<li>Download the appropriate Conda (Python 3.x) for your platform (https://conda.io/miniconda.html)</li>
<li>Install Conda with the recommended defaults</li>
</ol>
<h5 id="create-a-python-environment-for-rizin"><a class="header" href="#create-a-python-environment-for-rizin">Create a Python Environment for Rizin</a></h5>
<p>Follow these steps to create and activate a Conda environment named <em>rizin</em>. All instructions from this point on will assume this name matches your environment, but you may change this if desired.</p>
<ol>
<li>Start &gt; Anaconda Prompt</li>
<li><code>conda create -n rizin python=3</code></li>
<li><code>activate rizin</code></li>
</ol>
<p>Any time you wish to enter this environment, open the Anaconda Prompt and re-issue <code>activate rizin</code>. Conversely, <code>deactivate</code> will leave the environment.</p>
<h5 id="install-meson--ninja"><a class="header" href="#install-meson--ninja">Install Meson + Ninja</a></h5>
<ol>
<li>Enter the Rizin Conda environment, if needed (<code>activate rizin</code>)</li>
<li>Download meson + ninja</li>
<li><code>pip install meson ninja</code></li>
<li>Verify Meson is version 0.50 or higher (<code>meson -v</code>)</li>
</ol>
<h4 id="install-git-for-windows"><a class="header" href="#install-git-for-windows">Install Git for Windows</a></h4>
<p>All Rizin code is managed via the Git version control system and <a href="https://github.com/rizin">hosted on GitHub</a>.</p>
<p>Follow these steps to install Git for Windows.</p>
<ol>
<li>Download <a href="https://git-scm.com/download/win">Git for Windows</a></li>
</ol>
<p>As you navigate the install wizard, we recommend you set these options when they appear:
* Use a TrueType font in all console windows
* Use Git from the Windows Command Prompt
* Use the native Windows Secure Channel library (instead of OpenSSL)
* Checkout Windows-style, commit Unix-style line endings (core.autocrlf=true)
* Use Windows' default console window (instead of Mintty)</p>
<ol start="2">
<li>Close any previously open console windows and re-open them to ensure they receive the new PATH</li>
<li>Ensure <code>git --version</code> works</li>
</ol>
<h4 id="get-rizin-code"><a class="header" href="#get-rizin-code">Get Rizin Code</a></h4>
<p>Follow these steps to clone the Rizin git repository.</p>
<ol>
<li>In your Rizin Conda environment, navigate to a location where the code will be saved and compiled. This location needs approximately <strong>3-4GiB</strong> of space</li>
<li>Clone the repository with <code>git clone --recurse-submodules https://github.com/rizinorg/rizin.git</code></li>
</ol>
<h4 id="compile-rizin-code"><a class="header" href="#compile-rizin-code">Compile Rizin Code</a></h4>
<p>Follow these steps to compile the Rizin Code.</p>
<p>Compiled binaries will be installed into the <code>dest</code> folder.</p>
<ol>
<li>
<p>Enter the Rizin Conda environment</p>
</li>
<li>
<p>Navigate to the root of the Rizin sources (<code>cd rizin</code>)</p>
</li>
<li>
<p>Initialize Visual Studio tooling by executing the command below that matches the version of Visual Studio installed on your machine and the version of Rizin you wish to install:</p>
<ul>
<li>
<p><strong>Visual Studio 2015:</strong></p>
<p>Note: For the 64-bit version change only the <code>x86</code> at the very end of the command below to <code>x64</code>.</p>
<p><code>&quot;%ProgramFiles(x86)%\Microsoft Visual Studio 14.0\VC\vcvarsall.bat&quot; x86</code></p>
</li>
<li>
<p><strong>Visual Studio 2017/2019:</strong></p>
<p>Note 1: Change <code>Community</code> to either <code>Professional</code> or <code>Enterprise</code> in the command below depending on the version installed.</p>
<p>Note 2: Change <code>vcvars32.bat</code> to <code>vcvars64.bat</code> in the command below for the 64-bit version.</p>
<p>Note 3: Change <code>2017</code> to <code>2019</code> if you are using Visual Studio 2019.</p>
<p><code>&quot;%ProgramFiles(x86)%\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build\vcvars32.bat&quot;</code></p>
</li>
<li>
<p><strong>Visual Studio Preview:</strong></p>
<p>Note 1: Change <code>Community</code> to either <code>Professional</code> or <code>Enterprise</code> in the command below depending on the version installed.</p>
<p>Note 2: Change <code>vcvars32.bat</code> to <code>vcvars64.bat</code> in the command below for the 64-bit version.</p>
<p><code>&quot;%ProgramFiles(x86)%\Microsoft Visual Studio\Preview\Community\VC\Auxiliary\Build\vcvars32.bat&quot;</code></p>
</li>
</ul>
</li>
<li>
<p>Generate the build system with Meson:</p>
</li>
</ol>
<p>Note 1: Change <code>debug</code> to <code>release</code> in the command below depending on whether the latest version or release version is desired.</p>
<p><code>meson --buildtype debug --prefix %cd%\dest build</code></p>
<p>Meson currently requires <code>--prefix</code> to point to an absolute path. We use the %CD% pseudo-variable to get the absolute path to the current working directory.</p>
<ol start="5">
<li>Start a build:</li>
</ol>
<p><code>ninja -C build</code></p>
<ol start="6">
<li>Install into your destination folder: <code>ninja -C build install</code></li>
<li>Check your Rizin version: <code>dest\bin\rizin.exe -v</code></li>
</ol>
<h4 id="check-that-rizin-runs-from-all-locations"><a class="header" href="#check-that-rizin-runs-from-all-locations">Check That Rizin Runs From All Locations</a></h4>
<ol>
<li>In the file explorer go to the folder Rizin was just installed in.</li>
<li>From this folder go to <code>dest</code> &gt; <code>bin</code> and keep this window open.</li>
<li>Go to System Properties: In the Windows search bar enter <code>sysdm.cpl</code>.</li>
<li>Go to <code>Advanced &gt; Environment Variables</code>.</li>
<li>Click on the PATH variable and then click edit (if it exists within both the user and system variables, look at the user version).</li>
<li>Ensure the file path displayed in the window left open is listed within the PATH variable. If it is not add it and click <code>ok</code>.</li>
<li>Log out of your Windows session.</li>
<li>Open up a new Windows Command Prompt: type <code>cmd</code> in the search bar. Ensure that the current path is not in the Rizin folder.</li>
<li>Check Rizin version from Command Prompt Window: <code>rizin -v</code></li>
</ol>
<h2 id="android"><a class="header" href="#android">Android</a></h2>
<p>Rizin can be cross-compiled for other architectures/systems as well, like Android.</p>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li>Python 3</li>
<li>Meson</li>
<li>Ninja</li>
<li>Git</li>
<li>Android NDK</li>
</ul>
<h3 id="step-by-step-1"><a class="header" href="#step-by-step-1">Step-by-step</a></h3>
<h4 id="download-and-extract-the-android-ndk"><a class="header" href="#download-and-extract-the-android-ndk">Download and extract the Android NDK</a></h4>
<p>Download the Android NDK from the <a href="https://developer.android.com/ndk">official site</a> and extract it somewhere on your system (e.g. <code>/tmp/android-ndk</code>)</p>
<h4 id="meson"><a class="header" href="#meson">Meson</a></h4>
<p>See also <a href="https://github.com/rizinorg/rizin/blob/dev/BUILDING.md#cross-compilation-for-android">BUILDING.md</a>.</p>
<h5 id="create-a-cross-file-for-meson"><a class="header" href="#create-a-cross-file-for-meson">Create a cross-file for meson</a></h5>
<p>Meson needs a configuration file that describes the cross compilation environment (e.g. <code>meson-android.ini</code>).
You can adjust it as necessary, but something like the following should be a good starting point:</p>
<pre><code>[binaries]
c       = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang'
cpp     = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang++'
ar      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ar'
as      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-as'
ranlib  = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ranlib'
ld      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ld'
strip   = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-strip'
pkgconfig = 'false'

[properties]
sys_root = '/tmp/android-ndk/sysroot'

[host_machine]
system = 'android'
cpu_family = 'arm'
cpu = 'aarch64'
endian = 'little'
</code></pre>
<h5 id="compile-with-meson--ninja"><a class="header" href="#compile-with-meson--ninja">Compile with meson + ninja</a></h5>
<p>Now setup the build directory with meson as usual:</p>
<pre><code>$ meson --default-library static -Dstatic_runtime=true --prefix=/tmp/android-dir -Dblob=true build --cross-file ./meson-android.ini
</code></pre>
<p>A bit of explanation about all the options:</p>
<ul>
<li><code>--default-library static -Dstatic_runtime=true</code>: this ensure that libraries
and binaries are statically compiled, so you do not need to properly set LD_*
environment variables in your Android environment to make it find the right
libraries. Binaries have everything they need inside.</li>
<li><code>-Dblob=true</code>: it tells meson to compile just one binary with all the needed
code for running <code>rizin</code>, <code>rz-bin</code>, <code>rz-asm</code>, etc. and creates symbolic links to
those names. This avoids creating many statically compiled large binaries and
just create one that provides all features. You will still have <code>rz-bin</code>,
<code>rz-asm</code>, <code>rz-ax</code>, etc. but they are just symlinks to <code>rizin</code>.</li>
<li><code>--cross-file ./meson-android.ini</code>: it describes how to compile rizin for Android</li>
</ul>
<p>Then compile and install the project:</p>
<pre><code>$ ninja -C build
$ ninja -C build install
</code></pre>
<h5 id="move-files-to-your-android-device-and-enjoy"><a class="header" href="#move-files-to-your-android-device-and-enjoy">Move files to your android device and enjoy</a></h5>
<p>At this point you can copy the generated files in /tmp/android-dir to your Android device and running rizin from it.
For example:</p>
<pre><code>$ cd /tmp &amp;&amp; tar -cvf rizin-android.tar.gz android-dir
$ adb push rizin-android.tar.gz /data/local/tmp
$ adb shell
DEVICE:/ $ cd /data/local/tmp
DEVICE:/data/local/tmp $ tar xvf rizin-android.tar.gz
DEVICE:/data/local/tmp $ ./android-dir/bin/rizin
Usage: rizin [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]
          [-s addr] [-B baddr] [-m maddr] [-c cmd] [-e k=v] file|pid|-|--|=
</code></pre>
<h2 id="basic-rizin-usage"><a class="header" href="#basic-rizin-usage">Basic Rizin Usage</a></h2>
<p>The learning curve is usually somewhat steep at the beginning. Although after an hour of using it you should easily understand how most things work, and how to combine the various tools rizin offers. You are encouraged to read the rest of this book to understand how some non-trivial things work, and to ultimately improve your skills.</p>
<p><img src="first_steps/learning_curve.png" alt="learning_curve" /></p>
<p>Navigation, inspection and modification of a loaded binary file is performed using three simple actions: seek (to position), print (buffer), and alternate (write, append).</p>
<p>The 'seek' command is abbreviated as <code>s</code> and accepts an expression as its argument. The expression can be something like <code>10</code>, <code>+0x25</code>, or <code>[0x100+ptr_table]</code>. If you are working with block-based files, you may prefer to set the block size to a required value with <code>b</code> command, and seek forward or backwards with positions aligned to it. Use <code>s++</code> and <code>s--</code> commands to navigate this way.</p>
<p>If rizin opens an executable file, by default it will open the file in Virtual Addressing (VA) mode and the sections will be mapped to their virtual addresses. In VA mode, seeking is based on the virtual address and the starting position is set to the entry point of the executable. Using <code>-n</code> option you can suppress this default behavior and ask rizin to open the file in non-VA mode for you. In non-VA mode, seeking is based on the offset from the beginning of the file.</p>
<p>The 'print' command is abbreviated as <code>p</code> and has a number of submodes — the second letter specifying a desired print mode. Frequent variants include <code>px</code> to print in hexadecimal, and <code>pd</code> for disassembling.</p>
<p>To be allowed to write files, specify the <code>-w</code> option to rizin when opening a file. The <code>w</code> command can be used to write strings, hexpairs (<code>x</code> subcommand), or even assembly opcodes (<code>a</code> subcommand). Examples:</p>
<pre><code>&gt; w hello world         ; string
&gt; wx 90 90 90 90        ; hexpairs
&gt; wa jmp 0x8048140      ; assemble
&gt; wf inline.bin         ; write contents of file
</code></pre>
<p>Appending a <code>?</code> to a command will show its help message, for example, <code>p?</code>.
Appending <code>?*</code> will show commands starting with the given string, e.g. <code>p?*</code>.</p>
<p>To enter visual mode, press <code>V&lt;enter&gt;</code>. Use <code>q</code> to quit visual mode and return to the prompt.</p>
<p>In visual mode you can use HJKL keys to navigate (left, down, up, and right, respectively). You can use these keys in cursor mode toggled by <code>c</code> key. To select a byte range in cursor mode, hold down <code>SHIFT</code> key, and press navigation keys HJKL to mark your selection.</p>
<p>While in visual mode, you can also overwrite bytes by pressing <code>i</code>. You can press <code>TAB</code> to switch between the hex (middle) and string (right) columns. Pressing <code>q</code> inside the hex panel returns you to visual mode. By pressing <code>p</code> or <code>P</code> you can scroll different visual mode representations. There is a second most important visual mode - curses-like panels interface, accessible with <code>V!</code> command.</p>
<h2 id="command-line-options"><a class="header" href="#command-line-options">Command-line Options</a></h2>
<p>The rizin core accepts many flags from the command line.</p>
<p>This is an excerpt from the usage help message:</p>
<pre><code>$ rizin -h
Usage: rizin [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]
          [-s addr] [-B baddr] [-m maddr] [-c cmd] [-e k=v] file|pid|-|--|=
 --           run rizin without opening any file
 =            same as 'rizin malloc://512'
 -            read file from stdin (use -i and -c to run cmds)
 -=           perform !=! command to run all commands remotely
 -0           print \x00 after init and every command
 -2           close stderr file descriptor (silent warning messages)
 -a [arch]    set asm.arch
 -A           run 'aaa' command to analyze all referenced code
 -b [bits]    set asm.bits
 -B [baddr]   set base address for PIE binaries
 -c 'cmd..'   execute rizin command
 -C           file is host:port (alias for -c+=http://%s/cmd/)
 -d           debug the executable 'file' or running process 'pid'
 -D [backend] enable debug mode (e cfg.debug=true)
 -e k=v       evaluate config var
 -f           block size = file size
 -F [binplug] force to use that rbin plugin
 -h, -hh      show help message, -hh for long
 -H ([var])   display variable
 -i [file]    run script file
 -I [file]    run script file before the file is opened
 -k [OS/kern] set asm.os (linux, macos, w32, netbsd, ...)
 -l [lib]     load plugin file
 -L           list supported IO plugins
</code></pre>
<pre><code> -m [addr]    map file at given address (loadaddr)
 -M           do not demangle symbol names
 -n, -nn      do not load RzBin info (-nn only load bin structures)
 -N           do not load user settings and scripts
 -q           quiet mode (no prompt) and quit after -i
 -Q           quiet mode (no prompt) and quit faster (quickLeak=true)
 -p [prj]     use project, list if no arg, load if no file
 -P [file]    apply rapatch file and quit
 -r [rz-run]  specify rz-run profile to load (same as -e dbg.profile=X)
 -R [rrzrule] specify custom rz-run directive
 -s [addr]    initial seek
 -S           start rizin in sandbox mode
 -t           load rz-bin info in thread
 -u           set bin.filter=false to get raw sym/sec/cls names
 -v, -V       show rizin version (-V show lib versions)
 -w           open file in write mode
 -x           open without exec-flag (asm.emu will not work), See io.exec
 -X           same as -e bin.usextr=false (useful for dyldcache)
 -z, -zz      do not load strings or load them even in raw
</code></pre>
<h3 id="common-usage-patterns"><a class="header" href="#common-usage-patterns">Common usage patterns</a></h3>
<p>Open a file in write mode without parsing the file format headers.</p>
<pre><code>$ rizin -nw file
</code></pre>
<p>Quickly get into an rizin shell without opening any file.</p>
<pre><code>$ rizin 
</code></pre>
<p>Quickly get into an rizin shell with malloc://512</p>
<pre><code>$ rizin = 
</code></pre>
<p>Specify which sub-binary you want to select when opening a fatbin file:</p>
<pre><code>$ rizin -a ppc -b 32 ls.fat
</code></pre>
<p>Run a script before showing interactive command-line prompt:</p>
<pre><code>$ rizin -i patch.rz target.bin
</code></pre>
<p>Execute a command and quit without entering the interactive mode:</p>
<pre><code>$ rizin -qc ij hi.bin &gt; imports.json
</code></pre>
<p>Set the configuration variable:</p>
<pre><code>$ rizin -e scr.color=0 blah.bin
</code></pre>
<p>Debug a program:</p>
<pre><code>$ rizin -d ls
</code></pre>
<p>Use an existing project file:</p>
<pre><code>$ rizin -p test
</code></pre>
<h2 id="command-format"><a class="header" href="#command-format">Command Format</a></h2>
<p>A general format for rizin commands is as follows:</p>
<pre><code>[.][times][cmd][~grep][@[@iter]addr!size][|&gt;pipe] ;
</code></pre>
<p>People who use Vim daily and are familiar with its commands will find themselves at home. You will see this format used throughout the book. Commands are identified by a single case-sensitive character [a-zA-Z].</p>
<p>To repeatedly execute a command, prefix the command with a number:</p>
<pre><code>px    # run px
3px   # run px 3 times
</code></pre>
<p>The <code>!</code> prefix is used to execute a command in shell context. If you want to use the cmd callback from the I/O plugin you must prefix with <code>R!</code>.</p>
<p>Note that a single exclamation mark will run the command and print the output through the RCons API. This means that the execution will be blocking and not interactive. Use double exclamation marks -- <code>!!</code> -- to run a standard system call.</p>
<p>All the socket, filesystem and execution APIs can be restricted with the <code>cfg.sandbox</code> configuration variable.</p>
<p>A few examples:</p>
<pre><code>ds                    ; call the debugger's 'step' command
px 200 @ esp          ; show 200 hex bytes at esp
pc &gt; file.c           ; dump buffer as a C byte array to file.c
wx 90 @@is            ; write a nop on every symbol
pd 2000 | grep eax    ; grep opcodes that use the 'eax' register
px 20 ; pd 3 ; px 40  ; multiple commands in a single line
</code></pre>
<p>The standard UNIX pipe <code>|</code> is also available in the rizin shell. You can use it to filter the output of an rizin command with any shell program that reads from stdin, such as <code>grep</code>, <code>less</code>, <code>wc</code>. If you do not want to spawn anything, or you can't, or the target system does not have the basic UNIX tools you need (Windows or embedded users), you can also use the built-in grep (<code>~</code>).</p>
<p>See <code>~?</code> for help.</p>
<p>The <code>~</code> character enables internal grep-like function used to filter output of any command:</p>
<pre><code>pd 20~call            ; disassemble 20 instructions and grep output for 'call'
</code></pre>
<p>Additionally, you can grep either for columns or for rows:</p>
<pre><code>pd 20~call:0          ; get first row
pd 20~call:1          ; get second row
pd 20~call[0]         ; get first column
pd 20~call[1]         ; get second column
</code></pre>
<p>Or even combine them:</p>
<pre><code>pd 20~call:0[0]       ; grep the first column of the first row matching 'call'
</code></pre>
<p>This internal grep function is a key feature for scripting rizin,
because it can be used to iterate over a list of offsets or data generated by disassembler,
ranges, or any other command. Refer to the <a href="first_steps/../scripting/loops.html">loops</a> section (iterators) for more information.</p>
<p>The <code>@</code> character is used to specify a temporary offset at which the command to its left will be executed.
The original seek position in a file is then restored.</p>
<p>For example, <code>pd 5 @ 0x100000fce</code> to disassemble 5 instructions at address 0x100000fce.</p>
<p>Most of the commands offer autocompletion support using <code>&lt;TAB&gt;</code> key, for example <code>s</code>eek or <code>f</code>lags commands.
It offers autocompletion using all possible values, taking flag names in this case.
Note that it is possible to see the history of the commands
using the <code>!~...</code> command - it offers a visual mode to scroll through the rizin command history.</p>
<p>To extend the autocompletion support to handle more commands or enable autocompletion to your own commands defined in core, I/O plugins you must use the <code>!!!</code> command.</p>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>Expressions are mathematical representations of 64-bit numerical values.
They can be displayed in different formats, be compared or used with all commands
accepting numeric arguments. Expressions can use traditional arithmetic operations,
as well as binary and boolean ones.
To evaluate mathematical expressions prepend them with command <code>?</code>:</p>
<pre><code>[0xb7f9d810]&gt; ?vi 0x8048000
134512640
[0xv7f9d810]&gt; ?vi 0x8048000+34
134512674
[0xb7f9d810]&gt; ?vi 0x8048000+0x34
134512692
[0xb7f9d810]&gt; ? 1+2+3-4*3
hex     0xfffffffffffffffa
octal   01777777777777777777772
unit    17179869184.0G
segment fffff000:0ffa
int64   -6
string  &quot;\xfa\xff\xff\xff\xff\xff\xff\xff&quot;
binary  0b1111111111111111111111111111111111111111111111111111111111111010
fvalue: -6.0
float:  nanf
double: nan
trits   0t11112220022122120101211020120210210211201
</code></pre>
<p>Supported arithmetic operations are:</p>
<ul>
<li>+ : addition</li>
<li>- : subtraction</li>
<li>* : multiplication</li>
<li>/ : division</li>
<li>% : modulus</li>
<li>&gt; : shift right</li>
<li>&lt; : shift left</li>
</ul>
<pre><code>[0x00000000]&gt; ?vi 1+2+3
6
</code></pre>
<p>To use of logical OR should quote the whole command to avoid executing the <code>|</code> pipe:</p>
<pre><code>[0x00000000]&gt; &quot;? 1 | 2&quot;
hex     0x3
octal   03
unit    3
segment 0000:0003
int32   3
string  &quot;\x03&quot;
binary  0b00000011
fvalue: 2.0
float:  0.000000f
double: 0.000000
trits   0t10
</code></pre>
<p>Numbers can be displayed in several formats:</p>
<pre><code>0x033   : hexadecimal can be displayed
3334    : decimal
sym.fo  : resolve flag offset
10K     : KBytes  10*1024
10M     : MBytes  10*1024*1024
</code></pre>
<p>You can also use variables and seek positions to build complex expressions.</p>
<p>Use the <code>?$?</code> command to list all the available commands or read the refcard chapter of this book.</p>
<pre><code>$$    here (the current virtual seek)
$l    opcode length
$s    file size
$j    jump address (e.g. jmp 0x10, jz 0x10 =&gt; 0x10)
$f    jump fail address (e.g. jz 0x10 =&gt; next instruction)
$m    opcode memory reference (e.g. mov eax,[0x10] =&gt; 0x10)
$b    block size
</code></pre>
<p>Some more examples:</p>
<pre><code>[0x4A13B8C0]&gt; ? $m + $l
140293837812900 0x7f98b45df4a4 03771426427372244 130658.0G 8b45d000:04a4 140293837812900 10100100 140293837812900.0 -0.000000
</code></pre>
<pre><code>[0x4A13B8C0]&gt; pd 1 @ +$l
0x4A13B8C2   call 0x4a13c000
</code></pre>
<h1 id="basic-debugger-session"><a class="header" href="#basic-debugger-session">Basic Debugger Session</a></h1>
<p>To debug a program, start rizin with the <code>-d</code> option. Note that you can attach to a running process by specifying its PID, or you can start a new program by specifying its name and parameters:</p>
<pre><code>$ pidof mc
32220
$ rizin -d 32220
$ rizin -d /bin/ls
$ rizin -a arm -b 16 -d gdb://192.168.1.43:9090
...
</code></pre>
<p>In the second case, the debugger will fork and load the debuggee <code>ls</code> program in memory.</p>
<p>It will pause its execution early in <code>ld.so</code> dynamic linker. As a result, you will not yet see the entrypoint or any shared libraries at this point.</p>
<p>You can override this behavior by setting another name for an entry breakpoint. To do this, add a rizin command
<code>e dbg.bep=entry</code> or <code>e dbg.bep=main</code> to your startup script, usually it is <code>~/.config/rizin/rizinrc</code>.</p>
<p>Another way to continue until a specific address is by using the <code>dcu</code> command. Which means: &quot;debug continue until&quot; taking the address of the place to stop at. For example:</p>
<pre><code>dcu main
</code></pre>
<p>Be warned that certain malware or other tricky programs can actually execute code before <code>main()</code> and thus you'll be unable to control them. (Like the program constructor or the tls initializers)</p>
<p>Below is a list of most common commands used with debugger:</p>
<pre><code>&gt; d?            ; get help on debugger commands
&gt; ds 3          ; step 3 times
&gt; db 0x8048920  ; setup a breakpoint
&gt; db -0x8048920 ; remove a breakpoint
&gt; dc            ; continue process execution
&gt; dcs           ; continue until syscall
&gt; dd            ; manipulate file descriptors
&gt; dm            ; show process maps
&gt; dmp A S rwx   ; change permissions of page at A and size S
&gt; dr eax=33     ; set register value. eax = 33
</code></pre>
<p>There is another option for debugging in rizin, which may be easier: using visual mode.</p>
<p>That way you will neither need to remember many commands nor to keep program state in your mind.</p>
<p>To enter visual debugger mode use <code>Vpp</code>:</p>
<pre><code>[0xb7f0c8c0]&gt; Vpp
</code></pre>
<p>The initial view after entering visual mode is a hexdump view of the current target program counter (e.g., EIP for x86).
Pressing <code>p</code> will allow you to cycle through the rest of visual mode views.
You can press <code>p</code> and <code>P</code> to rotate through the most commonly used print modes.
Use F7 or <code>s</code> to step into and F8 or <code>S</code> to step over current instruction.
With the <code>c</code> key you can toggle the cursor mode to mark a byte range selection
(for example, to later overwrite them with nop). You can set breakpoints with <code>F2</code> key.</p>
<p>In visual mode you can enter regular rizin commands by prepending them with <code>:</code>.
For example, to dump a one block of memory contents at ESI:</p>
<pre><code>&lt;Press ':'&gt;
x @ esi
</code></pre>
<p>To get help on visual mode, press <code>?</code>. To scroll the help screen, use arrows. To
exit the help view, press <code>q</code>.</p>
<p>A frequently used command is <code>dr</code>, which is used to read or write values of the target's general purpose registers.
For a more compact register value representation you might use <code>dr=</code> command.
You can also manipulate the hardware and the extended/floating point registers.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<h3 id="rizin-book"><a class="header" href="#rizin-book">Rizin Book</a></h3>
<p>If you want to contribute to the Rizin book, you can do it at the <a href="https://github.com/rizinorg/book">Github repository</a>.
Suggested contributions include:</p>
<ul>
<li>Crackme writeups</li>
<li>CTF writeups</li>
<li>Documentation on how to use Rizin</li>
<li>Documentation on developing for Rizin</li>
<li>Conference presentations/workshops using Rizin</li>
<li>Missing content from the Radare1 book updated to Rizin</li>
</ul>
<p>Please get permission to port any content you do not own/did not create before you put it in the Rizin book.</p>
<p>See <a href="https://github.com/rizinorg/rizin/blob/dev/CONTRIBUTING.md">https://github.com/rizinorg/rizin/blob/dev/CONTRIBUTING.md</a> for general help on contributing to rizin.</p>
<h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>The core reads <code>~/.config/rizin/rizinrc</code> while starting. You can add <code>e</code> commands to this file to tune the rizin configuration to your taste.</p>
<p>To prevent rizin from parsing this file at startup, pass it the <code>-N</code> option.</p>
<p>All the configuration of rizin is done with the <code>eval</code> commands. A typical startup configuration file looks like this:</p>
<pre><code class="language-sh">$ cat ~/.rizinrc
e scr.color=1
e dbg.bep   = loader
</code></pre>
<p>The configuration can also be changed with <code>-e</code> &lt;config=value&gt; command-line option. This way you can adjust configuration from the command line, keeping the .rizinrc file intact. For example, to start with empty configuration and then adjust <code>scr.color</code> and <code>asm.syntax</code> the following line may be used:</p>
<pre><code class="language-sh">$ rizin -N -e scr.color=1 -e asm.syntax=intel -d /bin/ls
</code></pre>
<p>Internally, the configuration is stored in a hash table. The variables are grouped in namespaces: <code>cfg.</code>, <code>file.</code>, <code>dbg.</code>, <code>scr.</code> and so on.</p>
<p>To get a list of all configuration variables just type <code>e</code> in the command line
prompt. To limit the output to a selected namespace, pass it with an ending dot to <code>e</code>. For example, <code>e file.</code> will display all variables defined inside the &quot;file&quot; namespace.</p>
<p>To get help about <code>e</code> command type <code>e?</code>:</p>
<pre><code>[0x00000000]&gt; e?
Usage: e[?]   # List/get/set config evaluable vars
| e &lt;key&gt;[=&lt;val|?&gt;] [&lt;key&gt;[=&lt;val|?&gt;] ...]] # Get/Set value of config variable &lt;key&gt;
| el[j*qlJ] [&lt;key&gt;]      # List config variables with their descriptions
| e-                     # Reset config variables
| e! &lt;key&gt;               # Invert the boolean value of config variable &lt;var&gt;
| ec[?]                  # Set color for given key (prompt, offset, ...)
| ee &lt;key&gt;               # Open editor to change the value of config variable &lt;var&gt;
| ed                     # Open editor to change ~/.rizinrc
| er &lt;key&gt;               # Set config variable &lt;var&gt; as read-only
| es [&lt;key&gt;]             # List all config variable spaces or sub-keys/sub-spaces if a &lt;key&gt; is provided
| et &lt;key&gt;               # Show type of given config variable &lt;var&gt;
| env [&lt;varname&gt;[=&lt;varvalue&gt;]] # Get/set environment variables
</code></pre>
<p>A simpler alternative to the <code>e</code> command is accessible from the visual mode. Type <code>Ve</code> to enter it, use arrows (up, down, left, right) to navigate the configuration, and <code>q</code> to exit it. The start screen for the visual configuration edit looks like this:</p>
<pre><code>[EvalSpace]

    &gt;  analysis
       asm
       bin
       cfg
       cmd
       dbg
       diff
       dir
       emu
       esil
       file
       graph
       hex
       http
       hud
       io
       key
       log
       magic
       pdb
       ...
</code></pre>
<p>For configuration values that can take one of several values, you can use the <code>=?</code> operator to get a list
of valid values:</p>
<pre><code>[0x00000000]&gt; e scr.nkey=?
scr.nkey = fun, hit, flag
</code></pre>
<h2 id="colors"><a class="header" href="#colors">Colors</a></h2>
<p>Console access is wrapped in API that permits to show the output of any command as ANSI, W32 Console or HTML formats. This allows rizin's core to run inside environments with limited displaying capabilities, like kernels or embedded devices. It is still possible to receive data from it in your favorite format.</p>
<p>To enable colors support by default, add a corresponding configuration option to the .rizin configuration file:</p>
<pre><code>$ echo 'e scr.color=1' &gt;&gt; ~/.rizinrc
</code></pre>
<p>Note that enabling colors is not a boolean option. Instead, it is a number because there are different color depth levels. This is:</p>
<ul>
<li>0: black and white</li>
<li>1: 16 basic ANSI colors</li>
<li>2: 256 scale colors</li>
<li>3: 24bit true color</li>
</ul>
<p>The reason for having such user-defined options is because there's no standard or portable way for the terminal programs to query the console to determine the best configuration, same goes for charset encodings, so rizin allows you to choose that by hand.</p>
<p>Usually, serial consoles may work with 0 or 1, while xterms may support up to 3. RCons will try to find the closest color scheme for your theme when you choose a different them with the <code>eco</code> command.</p>
<p>It is possible to configure the color of almost any element of disassembly output. For *NIX terminals, rizin accepts color specification in RGB format. To change the console color palette use <code>ec</code> command.</p>
<p>Type <code>ec</code> to get a list of all currently used colors. Type <code>ecs</code> to show a color palette to pick colors from:</p>
<p><img src="configuration/rzpal.png" alt="img" /></p>
<h2 id="themes"><a class="header" href="#themes">Themes</a></h2>
<p>You can create your own color theme, but rizin have its own predefined ones. Use the <code>eco</code> command to list or select them.</p>
<p>After selecting one, you can compare between the color scheme of the shell and the current theme by pressing Ctrl-Shift and then right arrow key for the toggle.</p>
<p>In visual mode use the <code>R</code> key to randomize colors or choose the next theme in the list.</p>
<h2 id="configuration-variables"><a class="header" href="#configuration-variables">Configuration Variables</a></h2>
<p>Below is a list of the most frequently used configuration variables. You can get a complete list by issuing <code>e</code> command without arguments. For example, to see all variables defined in the &quot;cfg&quot; namespace, issue <code>e cfg.</code> (mind the ending dot). You can get help on any eval configuration variable by using <code>el cfg.</code></p>
<p>The <code>el</code> command to get help on all the evaluable configuration variables of rizin. As long as the output of this command is pretty large you can combine it with the internal grep <code>~</code> to filter for what you are looking for:</p>
<pre><code>[0x00000000]&gt; el~color
      graph.gv.graph: Graphviz global style attributes. (bgcolor=white)
       graph.gv.node: Graphviz node style. (color=gray, style=filled shape=box)
          log.colors: Should the log output use colors (TODO)
           scr.color: Enable colors (0: none, 1: ansi, 2: 256 colors, 3: truecolor)
      scr.color.args: Colorize arguments and variables of functions
     scr.color.bytes: Colorize bytes that represent the opcodes of the instruction
      scr.color.grep: Enable colors when using ~grep
       scr.color.ops: Colorize numbers and registers in opcodes
      scr.color.pipe: Enable colors when using pipes
     scr.prompt.mode: Set prompt color based on vi mode
         scr.rainbow: Shows rainbow colors depending of address
         scr.randpal: Random color palette or just get the next one from 'eco'
</code></pre>
<p>The Visual mode has an eval browser that is accessible through the <code>Vbe</code> command.</p>
<h2 id="assembly-configuration"><a class="header" href="#assembly-configuration">Assembly Configuration</a></h2>
<h3 id="asmarch-string"><a class="header" href="#asmarch-string">asm.arch: <code>string</code></a></h3>
<p>Defines the target CPU architecture used for disassembling (<code>pd</code>, <code>pD</code> commands) and code analysis (<code>a</code> command). You can find the list of possible values by looking at the result of <code>e asm.arch=?</code> or <code>rz-asm -L</code>.
It is quite simple to add new architectures for disassembling and analyzing code. There is an interface for that. For x86, it is used to attach a number of third-party disassembler engines, including GNU binutils, Udis86 and a few handmade ones.</p>
<h3 id="asmbits-int"><a class="header" href="#asmbits-int">asm.bits: <code>int</code></a></h3>
<p>Determines width in bits of registers for the current architecture.
Supported values:</p>
<ul>
<li>8</li>
<li>16</li>
<li>32</li>
<li>64</li>
</ul>
<p>Note that not all target architectures support all combinations for asm.bits.</p>
<h3 id="asmbytes-bool"><a class="header" href="#asmbytes-bool">asm.bytes: <code>bool</code></a></h3>
<p>Show or hide displaying of raw bytes of instructions. By default, it is turned off, resulting in a disassembly like:</p>
<pre><code>[0x00005b20]&gt; e asm.bytes
false
[0x00005b20]&gt; pd 5
            0x00005b20      endbr64
            0x00005b24      xor   ebp, ebp
            0x00005b26      mov   r9, rdx
            0x00005b29      pop   rsi
            0x00005b2a      mov   rdx, rsp
</code></pre>
<p>When turned on, the raw bytes will be displayed along with the instructions:</p>
<pre><code>[0x00005b20]&gt; e asm.bytes=true
[0x00005b20]&gt; pd 5
            ;-- entry0:
            ;-- rip:
            0x00005b20      f30f1efa       endbr64
            0x00005b24      31ed           xor   ebp, ebp
            0x00005b26      4989d1         mov   r9, rdx
            0x00005b29      5e             pop   rsi
            0x00005b2a      4889e2         mov   rdx, rsp
</code></pre>
<h3 id="asmcpu-string"><a class="header" href="#asmcpu-string">asm.cpu: <code>string</code></a></h3>
<p>You can use this configuration variable to define the CPU type. For example, if you had picked the architecture as AVR, you can choose your CPU type (ATmega1281, ATmega2561, etc) using <code>asm.cpu</code>.</p>
<h3 id="asmplatform-string"><a class="header" href="#asmplatform-string">asm.platform: <code>string</code></a></h3>
<p>You can use this configuration variable to select the platform and it'll load up the corresponding 
platform profile during analysis. See the section about <a href="https://book.rizin.re/analysis/cpu_platform_profiles.html">CPU and platform profiles</a> for more information.</p>
<h3 id="asmflags-bool"><a class="header" href="#asmflags-bool">asm.flags: <code>bool</code></a></h3>
<p>When set to &quot;true&quot;, the disassembler view will have the flags column.</p>
<h3 id="asmfcnsize-bool"><a class="header" href="#asmfcnsize-bool">asm.fcn.size: <code>bool</code></a></h3>
<p>This variable is used to display the size of the function in the disassembly. By default, it is set to false and turning it on would result in a disassembly like the one below:</p>
<pre><code>┌ 44: int main (char **argv);
│           ; var int32_t var_4h @ ebp-0x4
│           ; arg char **argv @ esp+0x24
│           0x000011cd      lea   ecx, [argv]
│           0x000011d1      and   esp, 0xfffffff0
</code></pre>
<p>Here, <code>44</code> is the size of the function.</p>
<h3 id="asmlinescall-bool"><a class="header" href="#asmlinescall-bool">asm.lines.call: <code>bool</code></a></h3>
<p>If set to &quot;true&quot;, draw lines at the left of the disassembly output (<code>pd</code>, <code>pD</code> commands) to graphically represent control flow changes (jumps and calls) that are targeted inside the current block. Also, see <code>asm.lines.out</code>.</p>
<h3 id="asmlinesout-bool"><a class="header" href="#asmlinesout-bool">asm.lines.out: <code>bool</code></a></h3>
<p>When set to &quot;true&quot;, the disassembly view will also draw control flow lines that go outside of the block.</p>
<h3 id="asmoffset-bool"><a class="header" href="#asmoffset-bool">asm.offset: <code>bool</code></a></h3>
<p>Show or hide offsets for individual disassembled instructions.</p>
<h3 id="asmos-string"><a class="header" href="#asmos-string">asm.os: <code>string</code></a></h3>
<p>Selects a target operating system for the currently loaded binary. Usually, OS is automatically detected by Rizin (<code>rz-bin -rI</code>). Yet, <code>asm.os</code> can be used to switch to a different syscall table employed by another OS.</p>
<h3 id="asmpseudo-bool"><a class="header" href="#asmpseudo-bool">asm.pseudo: <code>bool</code></a></h3>
<p>A boolean value to set the pseudo syntax in the disassembly. &quot;False&quot; indicates a native one, defined by the current architecture, &quot;true&quot; activates a pseudocode strings format. For example, it'll transform :</p>
<pre><code>│           0x080483ff      e832000000     call 0x8048436
│           0x08048404      31c0           xor eax, eax
│           0x08048406      0205849a0408   add al, byte [0x8049a84]
│           0x0804840c      83f800         cmp eax, 0
│           0x0804840f      7405           je 0x8048416
</code></pre>
<p>to</p>
<pre><code>│           0x080483ff      e832000000     0x8048436 ()
│           0x08048404      31c0           eax = 0
│           0x08048406      0205849a0408   al += byte [0x8049a84]
│           0x0804840c      83f800         var = eax - 0
│           0x0804840f      7405           if (!var) goto 0x8048416
</code></pre>
<p>It can be useful while disassembling obscure architectures.</p>
<h3 id="asmsubjmp-bool"><a class="header" href="#asmsubjmp-bool">asm.sub.jmp: <code>bool</code></a></h3>
<p>Substitute jump, call and branch targets with function names in the disassembly.</p>
<p>For example, when turned on, it'd display <code>jal 0x80001a40</code> as <code>jal fcn.80001a40</code> in the disassembly.</p>
<h3 id="asmsubreg-bool"><a class="header" href="#asmsubreg-bool">asm.sub.reg: <code>bool</code></a></h3>
<p>Replace register names with arguments or their associated role alias.</p>
<p>For example, if you have something like this:</p>
<pre><code>│           0x080483ea      83c404         add esp, 4
│           0x080483ed      68989a0408     push 0x8049a98
│           0x080483f7      e870060000     call sym.imp.scanf
│           0x080483fc      83c408         add esp, 8
│           0x08048404      31c0           xor eax, eax
</code></pre>
<p>This variable changes it to:</p>
<pre><code>│           0x080483ea      83c404         add SP, 4
│           0x080483ed      68989a0408     push 0x8049a98
│           0x080483f7      e870060000     call sym.imp.scanf
│           0x080483fc      83c408         add SP, 8
│           0x08048404      31c0           xor A0, A0
</code></pre>
<h3 id="asmsubrel-bool"><a class="header" href="#asmsubrel-bool">asm.sub.rel: <code>bool</code></a></h3>
<p>A boolean value that substitutes expressions relative to the Program Counter in the disassembly. When turned on, it shows the references as string references.</p>
<p>For example:</p>
<pre><code>0x5563844a0181      488d3d7c0e00.  lea rdi, [rip + 0xe7c]    ; str.argv__2d_:__s
</code></pre>
<p>When turned on, this variable lets you display the above instruction as:</p>
<pre><code>0x5563844a0181      488d3d7c0e00.  lea rdi, str.argv__2d_:__s    ; 0x5563844a1004 ; &quot;argv[%2d]: %s\n&quot;
</code></pre>
<h3 id="asmsubsection-bool"><a class="header" href="#asmsubsection-bool">asm.sub.section: <code>bool</code></a></h3>
<p>Prefix offsets in the disassembly with the name of the section or map.</p>
<p>That means, from something like:</p>
<pre><code>0x000067ea      488d0def0c01.  lea rcx, [0x000174e0]
</code></pre>
<p>to the one below, when toggled on.</p>
<pre><code>0x000067ea      488d0def0c01.  lea rcx, [fmap.LOAD1.0x000174e0]
</code></pre>
<h3 id="asmsubvaronly-bool"><a class="header" href="#asmsubvaronly-bool">asm.sub.varonly: <code>bool</code></a></h3>
<p>Substitutes the variable expression with the local variable name.</p>
<p>For example: <code>var_14h</code> as <code>rbp - var_14h</code>, in the disassembly.</p>
<h3 id="asmsyntax-string"><a class="header" href="#asmsyntax-string">asm.syntax: <code>string</code></a></h3>
<p>Changes syntax flavor for disassembler between Intel and AT&amp;T. At the moment, this setting affects Udis86 disassembler for Intel 32/Intel 64 targets only. Supported values are <code>intel</code> and <code>att</code>.</p>
<h3 id="asmtabs-int"><a class="header" href="#asmtabs-int">asm.tabs: <code>int</code></a></h3>
<p>If your disassembly doesn't fit in your screen or aligns clumsily, <code>asm.tabs</code> might be of help. You can use this variable to control the distance between the operands, by setting the number of spaces, while displaying your disassembly.</p>
<p>For example, this is the disassembly with the variable set to 0:</p>
<pre><code>[0x000040a7]&gt; e asm.tabs=0
[0x000040a7]&gt; pd 6
│           0x000040a7      push rsp
│           0x000040a8      mov r12d, edi                              ; argc
│           0x000040ab      push rbp
│           0x000040ac      mov rbp, rsi                               ; argv
│           0x000040af      push rbx
│           0x000040b0      sub rsp, 0x48
</code></pre>
<p>And here's what it would look like after setting it to 6:</p>
<pre><code>[0x000040a7]&gt; e asm.tabs=6
[0x000040a7]&gt; pd 6
│           0x000040a7      push  rsp
│           0x000040a8      mov   r12d, edi                            ; argc
│           0x000040ab      push  rbp
│           0x000040ac      mov   rbp,  rsi                            ; argv
│           0x000040af      push  rbx
│           0x000040b0      sub   rsp,  0x48
</code></pre>
<h3 id="asmtabsonce-bool"><a class="header" href="#asmtabsonce-bool">asm.tabs.once: <code>bool</code></a></h3>
<p>This is a boolean variable that can be set to true if you want to align only the opcodes, excluding the arguments. This makes sense only if you have set <code>asm.tabs</code> on.</p>
<pre><code>[0x00008290]&gt; e asm.tabs=6
[0x00008290]&gt; e asm.tabs.once=false
[0x00008290]&gt; pd 10
│           0x00008290      mov   ip,   sp
│           0x00008294      push  {r4,  fp,   ip,   lr,   pc}
│           0x00008298      sub   fp,   ip,   4
│           0x0000829c      sub   sp,   sp,   0x24
│           0x000082a0      str   r0,   [fp,  -0x28]
│           0x000082a4      str   r1,   [fp,  -0x2c]
│           0x000082a8      ldr   r3,   [fp,  -0x28]
│           0x000082ac      cmp   r3,   1
│       ┌─&lt; 0x000082b0      bgt   0x82c0
│       │   0x000082b4      mvn   r3,   0
</code></pre>
<p>In the above example, the opcodes and the operands are aligned. Now, turning it on would align only the opcodes.</p>
<pre><code>[0x00008290]&gt; e asm.tabs.once=true
[0x00008290]&gt; pd 10
│           0x00008290      mov   ip, sp
│           0x00008294      push  {r4, fp, ip, lr, pc}
│           0x00008298      sub   fp, ip, 4
│           0x0000829c      sub   sp, sp, 0x24
│           0x000082a0      str   r0, [var_28h]
│           0x000082a4      str   r1, [var_2ch]
│           0x000082a8      ldr   r3, [var_28h]
│           0x000082ac      cmp   r3, 1
│       ┌─&lt; 0x000082b0      bgt   0x82c0
│       │   0x000082b4      mvn   r3, 0
</code></pre>
<h3 id="asmtrace-bool"><a class="header" href="#asmtrace-bool">asm.trace: <code>bool</code></a></h3>
<p>A boolean value that controls displaying of tracing information (sequence number and counter) at the left of each opcode. It is used to assist with programs trace analysis.</p>
<h2 id="debug-configuration"><a class="header" href="#debug-configuration">Debug Configuration</a></h2>
<h3 id="dbgfollowchild-bool"><a class="header" href="#dbgfollowchild-bool">dbg.follow.child: <code>bool</code></a></h3>
<p>This variable lets you follow the child process, when a fork (system call) is encountered during debugging. By default, it is set to <code>false</code> and the parent process is traced.</p>
<h2 id="screen-configuration"><a class="header" href="#screen-configuration">Screen Configuration</a></h2>
<h3 id="scrcolor-int"><a class="header" href="#scrcolor-int">scr.color: <code>int</code></a></h3>
<p>This variable specifies the mode for colorized screen output.</p>
<ul>
<li>0 means no colors.</li>
<li>1 means 16-colors mode.</li>
<li>2 means 256-colors mode.</li>
<li>3 means 16 million-colors mode.</li>
</ul>
<p>If your favorite theme looks weird, try to bump this up.</p>
<h3 id="scrseek-string"><a class="header" href="#scrseek-string">scr.seek: <code>string</code></a></h3>
<p>This variable accepts a full-featured expression or a pointer/flag (eg. eip). If set, rizin will set seek position to its value on startup.</p>
<h3 id="scrscrollbar-bool"><a class="header" href="#scrscrollbar-bool">scr.scrollbar: <code>bool</code></a></h3>
<p>If you have set up any <a href="http://book.rada.re/basic_commands/flags.html#flag-zones">flagzones</a> (<code>fz?</code>), this variable will let you display the scrollbar with the flagzones, in Visual mode. Set it to <code>1</code> to display the scrollbar at the right end, <code>2</code> for the top and <code>3</code> to display it at the bottom.</p>
<h3 id="scrutf8-bool"><a class="header" href="#scrutf8-bool">scr.utf8: <code>bool</code></a></h3>
<p>Show UTF-8 characters instead of ANSI.</p>
<h3 id="scrutf8curvy-bool"><a class="header" href="#scrutf8curvy-bool">scr.utf8.curvy: <code>bool</code></a></h3>
<p>This variable lets you display curved corners in places like function graphs. This variable requires <code>scr.utf8</code> to be turned on.</p>
<pre><code>[0x0000415c]&gt; pd 4
│           0x0000415c      cmp   eax, 2
│       ┌─&lt; 0x0000415f      je    0x5001
│       │   0x00004165      cmp   eax, 3
│      ┌──&lt; 0x00004168      jne   0x4348
[0x0000415c]&gt; e scr.utf8.curvy=1
[0x0000415c]&gt; pd 4
│           0x0000415c      cmp   eax, 2
│       ╭─&lt; 0x0000415f      je    0x5001
│       │   0x00004165      cmp   eax, 3
│      ╭──&lt; 0x00004168      jne   0x4348
</code></pre>
<h3 id="scrwheel-bool"><a class="header" href="#scrwheel-bool">scr.wheel: <code>bool</code></a></h3>
<p>This variable lets you enable the mouse in Visual mode. Turning this variable on will be useful when you want to use your mouse to scroll through your disassembly or copy something in the Visual mode.</p>
<h2 id="general-configuration"><a class="header" href="#general-configuration">General Configuration</a></h2>
<h3 id="cfgbigendian-bool"><a class="header" href="#cfgbigendian-bool">cfg.bigendian: <code>bool</code></a></h3>
<p>Change endianness. &quot;true&quot; means big-endian, &quot;false&quot; is for little-endian.
&quot;file.id&quot; and &quot;file.flag&quot; both to be true.</p>
<h3 id="cfgfortunes-bool"><a class="header" href="#cfgfortunes-bool">cfg.fortunes: <code>bool</code></a></h3>
<p>Enables or disables &quot;fortune&quot; messages displayed at each rizin start.</p>
<h3 id="cfgfortunesfile-string"><a class="header" href="#cfgfortunesfile-string">cfg.fortunes.file: <code>string</code></a></h3>
<p>Rizin has two types for fortunes: tips and fun. Fortunes of the type 'tips' are general tips to help you use Rizin better, whereas the other one prints some lighthearted jokes. You can choose which type of fortune to display, using this variable.</p>
<pre><code>[0x00000000]&gt; e cfg.fortunes.file=tips
[0x00000000]&gt; fo
 -- Bindiff two files with '$ rz_diff /bin/true /bin/false'
[0x00000000]&gt; e cfg.fortunes.file=fun
[0x00000000]&gt; fo
 -- Welcome to &quot;IDA - the roguelike&quot;
[0x00000000]&gt;
</code></pre>
<p>Rizin also supports custom fortunes. You can save your fortunes in a file and provide the relative or absolute path to the same variable, to have them displayed at the startup.</p>
<pre><code>[0x00000000]&gt; e cfg.fortunes.file=/path/to/my/fortunes.txt
</code></pre>
<p>Please make sure that you add these in your <code>~/.rizinrc</code> to preserve the changes when you reopen rizin.</p>
<h3 id="cfgnewtab-bool"><a class="header" href="#cfgnewtab-bool">cfg.newtab: <code>bool</code></a></h3>
<p>If this variable is enabled, help messages will be displayed along with command names in tab completion for commands.</p>
<h2 id="stack-configuration"><a class="header" href="#stack-configuration">Stack Configuration</a></h2>
<h3 id="stacksize-int"><a class="header" href="#stacksize-int">stack.size: <code>int</code></a></h3>
<p>This variable lets you set the size of stack in bytes.</p>
<h2 id="command-configuration"><a class="header" href="#command-configuration">Command Configuration</a></h2>
<h2 id="cmdrepeat-bool"><a class="header" href="#cmdrepeat-bool">cmd.repeat: <code>bool</code></a></h2>
<p>Sometimes, you may need to run the same command repeatedly and that is what <code>cmd.repeat</code> is for. When set to <code>true</code>, pressing Return key (Enter key) will run the previous command again.</p>
<p>For example:</p>
<pre><code>[0x00005bc0]&gt; e cmd.repeat=true
[0x00005bc0]&gt; pd 2
            ;-- entry.fini0:
            0x00005bc0      endbr64
            0x00005bc4      cmp   byte [0x000232c8], 0
</code></pre>
<p>When turned on, you'd just need to press Enter key to run <code>pd 2</code></p>
<pre><code>[0x00005bc0]&gt;
            0x00005bce      cmp   qword [reloc.__cxa_finalize], 0
            0x00005bd6      mov   rbp, rsp
</code></pre>
<h2 id="files"><a class="header" href="#files">Files</a></h2>
<p>Use <code>rizin -H</code> to list all the environment variables that matter to know where it will
be looking for files. Those paths depend on the way (and operating system) you have
built rizin for.</p>
<pre><code>RZ_PREFIX=/usr
MAGICPATH=/usr/share/rizin/2.8.0-git/magic
PREFIX=/usr
INCDIR=/usr/include/libr
LIBDIR=/usr/lib64
LIBEXT=so
RCONFIGHOME=/home/user/.config/rizin
RDATAHOME=/home/user/.local/share/rizin
RCACHEHOME=/home/user/.cache/rizin
LIBR_PLUGINS=/usr/lib/rizin/2.8.0-git
USER_PLUGINS=/home/user/.local/share/rizin/plugins
USER_ZIGNS=/home/user/.local/share/rizin/zigns
</code></pre>
<h2 id="rc-files"><a class="header" href="#rc-files">RC Files</a></h2>
<p>RC files are rizin scripts that are loaded at startup time. Those files must be in 3 different places:</p>
<h3 id="system"><a class="header" href="#system">System</a></h3>
<p>rizin will first try to load /usr/share/rizin/rizinrc</p>
<h3 id="your-home"><a class="header" href="#your-home">Your Home</a></h3>
<p>Each user in the system can have its own rizin scripts to run on startup to select the color scheme, and other custom options by having rizin commands in there.</p>
<ul>
<li>~/.rizinrc</li>
<li>~/.config/rizin/rizinrc</li>
<li>~/.config/rizin/rizinrc.d/</li>
</ul>
<h3 id="target-file"><a class="header" href="#target-file">Target file</a></h3>
<p>If you want to run a script every time you open a file, just create a file with the same name of the file
but appending <code>.rz</code> to it.</p>
<h1 id="basic-commands"><a class="header" href="#basic-commands">Basic Commands</a></h1>
<p>Most command names in rizin are derived from action names. They should be easy to remember, as they are short. Actually, all commands are single letters. Subcommands or related commands are specified using the second character of the command name. For example, <code>/ foo</code> is a command to search plain string, while <code>/x 90 90</code> is used to look for hexadecimal pairs.</p>
<p>The general format for a valid command (as explained in the <a href="basic_commands/../first_steps/command_format.html">Command Format</a> chapter) looks like this:</p>
<pre><code>[.][times][cmd][~grep][@[@iter]addr!size][|&gt;pipe] ; ...
</code></pre>
<p>For example,</p>
<pre><code>&gt; 3s +1024    ; seeks three times 1024 from the current seek
</code></pre>
<p>If a command starts with <code>R!</code>, the rest of the string is passed to the currently loaded IO plugin (a debugger, for example). Most plugins provide help messages with <code>R!?</code> or <code>R!help</code>.</p>
<pre><code>$ rizin -d /bin/ls
&gt; R!help      ; handled by the IO plugin
</code></pre>
<p>If a command starts with <code>!</code>, posix_system() is called to pass the command to your shell. Check <code>!?</code> for more options and usage examples.</p>
<pre><code>&gt; !ls         ; run `ls` in the shell
</code></pre>
<p>The meaning of the arguments (iter, addr, size) depends on the specific command. As a rule of thumb, most commands take a number as an argument to specify the number of bytes to work with, instead of the currently defined block size. Some commands accept math expressions or strings.</p>
<pre><code>&gt; px 0x17     ; show 0x17 bytes in hexs at current seek
&gt; s base+0x33 ; seeks to flag 'base' plus 0x33
&gt; / lib       ; search for 'lib' string.
</code></pre>
<p>The <code>@</code> sign is used to specify a temporary offset location or a seek position at which the command is executed, instead of current seek position. This is quite useful as you don't have to seek around all the time.</p>
<pre><code>&gt; p8 10 @ 0x4010  ; show 10 bytes at offset 0x4010
&gt; f patata @ 0x10 ; set 'patata' flag at offset 0x10
</code></pre>
<p>Using <code>@@</code> sub-commands you can execute a single command on a list of flags, functions, symbols, etc.. You can think of these as foreach operations:</p>
<pre><code>&gt; s 0
&gt; / lib             ; search 'lib' string
&gt; p8 20 @@f:hit0_*   ; show 20 hexpairs at each search hit
</code></pre>
<p>The <code>&gt;</code> operation is used to redirect the output of a command into a file (overwriting it if it already exists).</p>
<pre><code>&gt; pr &gt; dump.bin   ; dump 'raw' bytes of current block to file named 'dump.bin'
&gt; f  &gt; flags.txt  ; dump flag list to 'flags.txt'
</code></pre>
<p>The <code>|</code> operation (pipe) is similar to what you are used to expect from it in a *NIX shell: an output of one command as input to another.</p>
<pre><code>[0x4A13B8C0]&gt; f | grep section | grep text
0x0805f3b0 512 section._text
0x080d24b0 512 section._text_end
</code></pre>
<p>You can pass several commands in a single line by separating them with a semicolon <code>;</code>:</p>
<pre><code>&gt; px ; dr
</code></pre>
<p>Using <code>_</code>, you can print the result that was obtained by the last command.</p>
<pre><code>[0x00001060]&gt; axt 0x00002004
main 0x1181 [DATA] lea rdi, str.argv__2d_:__s
[0x00001060]&gt; _
main 0x1181 [DATA] lea rdi, str.argv__2d_:__s
</code></pre>
<h2 id="seeking"><a class="header" href="#seeking">Seeking</a></h2>
<p>To move around the file we are inspecting we will need to change the offset at which we are using the <code>s</code> command.</p>
<p>The argument is a math expression that can contain flag names, parenthesis, addition, subtraction, multiplication of immediates of contents of memory using brackets.</p>
<p>Some example commands:</p>
<pre><code>[0x00000000]&gt; s 0x10
[0x00000010]&gt; sd +4
[0x00000014]&gt; shu
[0x00000010]&gt; shr
[0x00000014]&gt;
</code></pre>
<p>Observe how the prompt offset changes. The first line moves the current offset to the address 0x10.</p>
<p>The second does a relative seek 4 bytes forward.</p>
<p>And finally, the last 2 commands are undoing, and redoing the last seek operations in the seek history.</p>
<p>Instead of using just numbers, we can use complex expressions, or basic arithmetic operations to represent the address to seek.</p>
<p>To do this, check the ?$? Help message which describes the internal variables that can be used in the expressions. For example, this is the same as doing <code>sd +4</code> .</p>
<pre><code>[0x00000000]&gt; s $$+4
</code></pre>
<p>From the debugger (or when emulating) we can also use the register names as references. They are loaded as flags with the <code>.dr*</code> command, which happens under the hood.</p>
<pre><code>[0x00000000]&gt; s rsp+0x40
</code></pre>
<p>Here's the full help of the <code>s</code> command. We will explain in more detail below.</p>
<pre><code>[0x00000000]&gt; s?
Usage: s[?]   # Seek commands
| s [&lt;addr&gt;]          # Print current address / Seek to address
| spad [&lt;n&gt;]          # Print current address with &lt;n&gt; padded zeros (defaults to 8)
| s. &lt;hex_offset&gt;     # Seek honoring a base from core-&gt;offset
| sd &lt;delta&gt;          # Seek to a delta relative to current offset
| s-- [&lt;n&gt;]           # Seek blocksize bytes backward (/=n)
| s++ [&lt;n&gt;]           # Seek blocksize bytes forward (/=n)
| sh[j*ru-]           # Seek history commands
| s/[?]               # Seek to the first hit of a search
| sa &lt;align&gt; [&lt;addr&gt;] # Seek to current offset (or &lt;addr&gt;) aligned to &lt;align&gt;
| sb                  # Seek aligned to bb start
| sf [&lt;fcn&gt;]          # Seek to next function / Seek to specific function
| sf.                 # Seek to the beginning of current function
| sg                  # Seek to begin of section/file
| sG                  # Seek to end of section/file
| sn [&lt;type&gt;]         # Seek to next location of the given &lt;type&gt; or scr.nkey otherwise
| sp [&lt;type&gt;]         # Seek to prev location
| so [&lt;n&gt;]            # Seek to &lt;n&gt; next opcodes
| sr &lt;reg&gt;            # Seek to register
| sleep &lt;seconds&gt;     # Sleep for the specified amount of seconds


&gt; 3s++        ; 3 times block-seeking
&gt; s 10+0x80   ; seek at 0x80+10
</code></pre>
<p>If you want to inspect the result of a math expression, you can evaluate it using the <code>?</code> command. Simply pass the expression as an argument. The result can be displayed in hexadecimal, decimal, octal or binary formats.</p>
<pre><code>&gt; ? 0x100+200
0x1C8 ; 456d ; 710o ; 1100 1000
</code></pre>
<p>There are also subcommands of <code>?</code> that display the output in one specific format (base 10, base 16 ,...). See <code>?v</code> and <code>?vi</code>.</p>
<p>In the visual mode, you can press <code>u</code> (undo) or <code>U</code> (redo) inside the seek history to return back to previous or forward to the next location.</p>
<h2 id="open-file"><a class="header" href="#open-file">Open file</a></h2>
<p>As a test file, let's use a simple <code>hello_world.c</code> compiled in Linux ELF format.
After we compile it let's open it with rizin:</p>
<pre><code>$ rizin hello_world
</code></pre>
<p>Now we have the command prompt:</p>
<pre><code>[0x00400410]&gt;
</code></pre>
<p>And it is time to go deeper.</p>
<h2 id="seeking-at-any-position"><a class="header" href="#seeking-at-any-position">Seeking at any position</a></h2>
<p>All seeking commands that take an address as a command parameter can use any numeral base
such as hex, octal, binary or decimal.</p>
<p>Seek to an address 0x0. An alternative command is simply <code>0x0</code></p>
<pre><code>[0x00400410]&gt; s 0x0
[0x00000000]&gt;
</code></pre>
<p>Print current address:</p>
<pre><code>[0x00000000]&gt; s
0x0
[0x00000000]&gt;
</code></pre>
<p>There is an alternate way to print current position: <code>?v $$</code>.</p>
<p>Seek N positions forward, space is optional:</p>
<pre><code>[0x00000000]&gt; sd 128
[0x00000080]&gt;
</code></pre>
<p>Undo last two seeks to return to the initial address:</p>
<pre><code>[0x00000080]&gt; shu
[0x00000000]&gt; shu
[0x00400410]&gt;
</code></pre>
<p>We are back at <em>0x00400410</em>.</p>
<p>There's also a command to show the seek history:</p>
<pre><code>[0x00400410]&gt; sh
0x400410 
0x40041a 
0x400410 
0x400411 
0x400410  # current seek
0x4005b4  # redo
[0x00400410]&gt; sh*
f undo_3 @ 0x400410
f undo_2 @ 0x40041a
f undo_1 @ 0x400410
f undo_0 @ 0x400411
# Current seek @ 0x400410
f redo_0 @ 0x4005b4
</code></pre>
<h2 id="block-size"><a class="header" href="#block-size">Block Size</a></h2>
<p>The block size determines how many bytes rizin commands will process when not given an explicit size argument. You can temporarily change the block size by specifying a numeric argument to the print commands. For example <code>px 20</code>.</p>
<pre><code>[0x00000000]&gt; b?
Usage: b[f] [arg]  # Get/Set block size
| b 33     set block size to 33
| b eip+4  numeric argument can be an expression
| b        display current block size
| b+3      increase blocksize by 3
| b-16     decrease blocksize by 16
| b*       display current block size in rizin command
| bf foo   set block size to flag size
| bj       display block size information in JSON
| bm 1M    set max block size
</code></pre>
<p>The <code>b</code> command is used to change the block size:</p>
<pre><code>[0x00000000]&gt; b 0x100   # block size = 0x100
[0x00000000]&gt; b+16      #  ... = 0x110
[0x00000000]&gt; b-32      #  ... = 0xf0
</code></pre>
<p>The <code>bf</code> command is used to change the block size to value specified by a flag. For example, in symbols, the block size of the flag represents the size of the function. To make that work, you have to either run function analysis <code>af</code> (which is included in <code>aa</code>) or manually seek and define some functions e.g. via <code>Vd</code>.</p>
<pre><code>[0x00000000]&gt; bf sym.main    # block size = sizeof(sym.main)
[0x00000000]&gt; pD @ sym.main  # disassemble sym.main
</code></pre>
<p>You can combine two operations in a single <code>pdf</code> command. Except that <code>pdf</code> neither uses nor affects global block size.</p>
<pre><code>[0x00000000]&gt; pdf @ sym.main  # disassemble sym.main
</code></pre>
<p>Another way around is to use special variables <code>$FB</code> and <code>$FS</code> which denote Function's Beginning and Size at the current seek. Read more about <a href="basic_commands/../refcard/intro.html#usable-variables-in-expression">Usable variables</a>.</p>
<pre><code>[0x00000000]&gt; s sym.main + 0x04
[0x00001ec9]&gt; pD @ $FB !$FS  # disassemble current function
╭ 211: int main (int argc, char **argv, char **envp);
│           0x00001ec5      55                 push rbp
│           0x00001ec6      4889e5             mov rbp, rsp
│           0x00001ec9      4881ecc0000000     sub rsp, 0xc0
...
╰           0x00001f97      c3                 ret
</code></pre>
<p>Note: don't put space after <code>!</code> size designator. See also <a href="basic_commands/../first_steps/command_format.html">Command Format</a>.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p>The concept of sections is tied to the information extracted from the binary. We can display this information by using the <code>i</code> command.</p>
<p>Displaying information about sections:</p>
<pre><code>[0x00005310]&gt; iS
[Sections]
00 0x00000000     0 0x00000000     0 ----
01 0x00000238    28 0x00000238    28 -r-- .interp
02 0x00000254    32 0x00000254    32 -r-- .note.ABI_tag
03 0x00000278   176 0x00000278   176 -r-- .gnu.hash
04 0x00000328  3000 0x00000328  3000 -r-- .dynsym
05 0x00000ee0  1412 0x00000ee0  1412 -r-- .dynstr
06 0x00001464   250 0x00001464   250 -r-- .gnu.version
07 0x00001560   112 0x00001560   112 -r-- .gnu.version_r
08 0x000015d0  4944 0x000015d0  4944 -r-- .rela.dyn
09 0x00002920  2448 0x00002920  2448 -r-- .rela.plt
10 0x000032b0    23 0x000032b0    23 -r-x .init
...
</code></pre>
<p>As you may know, binaries have sections and maps. The sections define the contents of a portion of the file that can be mapped in memory (or not). What is mapped is defined by the segments.</p>
<p>Before the IO refactoring done by condret, the <code>S</code> command was used to manage what we now call maps. Currently the <code>S</code> command is deprecated because <code>iS</code> and <code>om</code> should be enough.</p>
<p>Firmware images, bootloaders and binary files usually place various sections of a binary at different addresses in memory. To represent this behavior, rizin offers the <code>iS</code>. Use <code>iS?</code> to get the help message. To list all created sections use <code>iS</code> (or <code>iSj</code> to get the json format). The <code>iS=</code> will show the region bars in ascii-art.</p>
<p>You can create a new mapping using the <code>om</code> subcommand as follows:</p>
<pre><code>om fd vaddr [size] [paddr] [rwx] [name]
</code></pre>
<p>For Example:</p>
<pre><code>[0x0040100]&gt; om 4 0x00000100 0x00400000 0x0001ae08 rwx test
</code></pre>
<p>You can also use <code>oml</code> command to view information about mapped sections:</p>
<pre><code>[0x00401000]&gt; oml
 6 fd: 4 +0x0001ae08 0x00000100 - 0x004000ff rwx test
 5 fd: 3 +0x00000000 0x00000000 - 0x0000055f r-- fmap.LOAD0
 4 fd: 3 +0x00001000 0x00001000 - 0x000011e4 r-x fmap.LOAD1
 3 fd: 3 +0x00002000 0x00002000 - 0x0000211f r-- fmap.LOAD2
 2 fd: 3 +0x00002de8 0x00003de8 - 0x0000402f r-- fmap.LOAD3
 1 fd: 4 +0x00000000 0x00004030 - 0x00004037 rw- mmap.LOAD3
</code></pre>
<p>Use <code>om?</code> to get all the possible subcommands. To list all the defined maps use <code>oml</code> (or <code>omlj</code> to get the json format). To get the ascii art view use <code>oml=</code>. </p>
<p>It is also possible to delete the mapped section using the <code>om- mapid</code> command.</p>
<p>For Example:</p>
<pre><code>[0x00401000]&gt; om- 6
</code></pre>
<h2 id="mapping-files"><a class="header" href="#mapping-files">Mapping Files</a></h2>
<p>Rizin's I/O subsystem allows you to map the contents of files into the same I/O space used to contain a loaded binary. New contents can be placed at random offsets.</p>
<p>The <code>o</code> command permits the user to open a file, this is mapped at offset 0 unless it has a known binary header and then the maps are created in virtual addresses.</p>
<p>Sometimes, we want to rebase a binary, or maybe we want to load or map the file in a different address.</p>
<p>When launching rizin, the base address can be changed with the <code>-B</code> flag. But you must notice the difference when opening files with unknown headers, like bootloaders, so we need to map them using the <code>-m</code> flag (or specifying it as argument to the <code>o</code> command).</p>
<p>rizin is able to open files and map portions of them at random places in memory specifying attributes like permissions and name. It is the perfect basic tooling to reproduce an environment like a core file, a debug session, by also loading and mapping all the libraries the binary depends on.</p>
<p>Opening files (and mapping them) is done using the <code>o</code> (open) command. Let's read the help:</p>
<pre><code>[0x00000000]&gt; o?
|Usage: o [com- ] [file] ([offset])
| o                         list opened files
| o-1                       close file descriptor 1
| o-!*                      close all opened files
| o--                       close all files, analysis, binfiles, flags, same as !rizin --
| o [file]                  open [file] file in read-only
| o+ [file]                 open file in read-write mode
| o [file] 0x4000 rwx       map file at 0x4000
| oa[-] [A] [B] [filename]  Specify arch and bits for given file
| oq                        list all open files
| o*                        list opened files in rizin commands
| o. [len]                  open a malloc://[len] copying the bytes from current offset
| o=                        list opened files (ascii-art bars)
| ob[?] [lbdos] [...]       list opened binary files backed by fd
| oc [file]                 open core file, like relaunching rizin
| of [file]                 open file and map it at addr 0 as read-only
| oi[-|idx]                 alias for o, but using index instead of fd
| oj[?]                     list opened files in JSON format
| oL                        list all IO plugins registered
| om[?]                     create, list, remove IO maps
| on [file] 0x4000          map raw file at 0x4000 (no rz_bin involved)
| oo[?]                     reopen current file (kill+fork in debugger)
| oo+                       reopen current file in read-write
| ood[r] [args]             reopen in debugger mode (with args)
| oo[bnm] [...]             see oo? for help
| op [fd]                   prioritize given fd (see also ob)
| ox fd fdx                 exchange the descs of fd and fdx and keep the mapping
</code></pre>
<p>Prepare a simple layout:</p>
<pre><code class="language-sh">$ rz-bin -l /bin/ls
[Linked libraries]
libselinux.so.1
librt.so.1
libacl.so.1
libc.so.6

4 libraries
</code></pre>
<p>Map a file:</p>
<pre><code>[0x00001190]&gt; o /bin/zsh 0x499999
</code></pre>
<p>List mapped files:</p>
<pre><code>[0x00000000]&gt; o
- 6 /bin/ls @ 0x0 ; r
- 10 /lib/ld-linux.so.2 @ 0x100000000 ; r
- 14 /bin/zsh @ 0x499999 ; r
</code></pre>
<p>Print hexadecimal values from /bin/zsh:</p>
<pre><code>[0x00000000]&gt; px @ 0x499999
</code></pre>
<p>Unmap files using the <code>o-</code> command. Pass the required file descriptor to it as an argument:</p>
<pre><code>[0x00000000]&gt; o-14
</code></pre>
<p>You can also view the ascii table showing the list of the opened files:</p>
<pre><code>[0x00000000]&gt; ob=
</code></pre>
<h2 id="print-modes"><a class="header" href="#print-modes">Print Modes</a></h2>
<p>One of the key features of rizin is displaying information in many formats. The goal is to offer a selection of display choices to interpret binary data in the best possible way.</p>
<p>Binary data can be represented as integers, shorts, longs, floats, timestamps, hexpair strings, or more complex formats like C structures, disassembly listings, decompilation listing, be a result of an external processing...</p>
<p>Below is a list of available print modes listed by <code>p?</code>:</p>
<pre><code>[0x00005310]&gt; p?
|Usage: p[=68abcdDfiImrstuxz] [arg|len] [@addr]
| p[b|B|xb] [len] ([S])   bindump N bits skipping S bytes
| p[iI][df] [len]         print N ops/bytes (f=func) (see pi? and pdi)
| p[kK] [len]             print key in randomart (K is for mosaic)
| p-[?][jh] [mode]        bar|json|histogram blocks (mode: el search.in)
| p2 [len]                8x8 2bpp-tiles
| p3 [file]               print stereogram (3D)
| p6[de] [len]            base64 decode/encode
| p8[?][j] [len]          8bit hexpair list of bytes
| p=[?][bep] [N] [L] [b]  show entropy/printable chars/chars bars
| pa[edD] [arg]           pa:assemble  pa[dD]:disasm or pae: esil from hex
| pA[n_ops]               show n_ops address and type
| pb[?] [n]               bitstream of N bits
| pB[?] [n]               bitstream of N bytes
| pc[?][p] [len]          output C (or python) format
| pC[aAcdDxw] [rows]      print disassembly in columns (see hex.cols and pdi)
| pd[?] [sz] [a] [b]      disassemble N opcodes (pd) or N bytes (pD)
| pf[?][.nam] [fmt]       print formatted data (pf.name, pf.name $&lt;expr&gt;)
| pF[?][apx]              print asn1, pkcs7 or x509
| pg[?][x y w h] [cmd]    create new visual gadget or print it (see pg? for details)
| ph[?][=|hash] ([len])   calculate hash for a block
| pj[?] [len]             print as indented JSON
| pm[?] [magic]           print libmagic data (see pm? and /m?)
| po[?] hex               print operation applied to block (see po?)
| pp[?][sz] [len]         print patterns, see pp? for more help
| pq[?][is] [len]         print QR code with the first Nbytes
| pr[?][glx] [len]        print N raw bytes (in lines or hexblocks, 'g'unzip)
| ps[?][pwz] [len]        print pascal/wide/zero-terminated strings
| pt[?][dn] [len]         print different timestamps
| pu[?][w] [len]          print N url encoded bytes (w=wide)
| pv[?][jh] [mode]        show variable/pointer/value in memory
| pwd                     display current working directory
| px[?][owq] [len]        hexdump of N bytes (o=octal, w=32bit, q=64bit)
| pz[?] [len]             print zoom view (see pz? for help)
[0x00005310]&gt;
</code></pre>
<p>Tip: when using json output, you can append the <code>~{}</code> to the command to get a pretty-printed version of the output:</p>
<pre><code>[0x00000000]&gt; oj
[{&quot;raised&quot;:false,&quot;fd&quot;:563280,&quot;uri&quot;:&quot;malloc://512&quot;,&quot;from&quot;:0,&quot;writable&quot;:true,&quot;size&quot;:512,&quot;overlaps&quot;:false}]
[0x00000000]&gt; oj~{}
[
	{
		&quot;raised&quot;: false,
		&quot;fd&quot;: 563280,
		&quot;uri&quot;: &quot;malloc://512&quot;,
		&quot;from&quot;: 0,
		&quot;writable&quot;: true,
		&quot;size&quot;: 512,
		&quot;overlaps&quot;: false
	}
]
</code></pre>
<p>For more on the magical powers of <code>~</code> see the help in <code>?@?</code>, and the <a href="basic_commands/../first_steps/command_format.html">Command Format</a> chapter earlier in the book.</p>
<h3 id="hexadecimal-view"><a class="header" href="#hexadecimal-view">Hexadecimal View</a></h3>
<p><code>px</code> gives a user-friendly output showing 16 pairs of numbers per row with offsets and raw representations:</p>
<p><img src="basic_commands/print_modes_px.png" alt="hexprint" /></p>
<h4 id="show-hexadecimal-words-dump-32-bits"><a class="header" href="#show-hexadecimal-words-dump-32-bits">Show Hexadecimal Words Dump (32 bits)</a></h4>
<p><img src="basic_commands/print_modes_pxw.png" alt="wordprint" /></p>
<h4 id="8-bits-hexpair-list-of-bytes"><a class="header" href="#8-bits-hexpair-list-of-bytes">8 bits Hexpair List of Bytes</a></h4>
<pre><code>[0x00404888]&gt; p8 16
31ed4989d15e4889e24883e4f0505449
</code></pre>
<h4 id="show-hexadecimal-quad-words-dump-64-bits"><a class="header" href="#show-hexadecimal-quad-words-dump-64-bits">Show Hexadecimal Quad-words Dump (64 bits)</a></h4>
<p><img src="basic_commands/print_modes_pxq.png" alt="pxq" /></p>
<h3 id="datetime-formats"><a class="header" href="#datetime-formats">Date/Time Formats</a></h3>
<p>Currently supported timestamp output modes are:</p>
<pre><code>[0x00404888]&gt; pt?
|Usage: pt [dn]  print timestamps
| pt.  print current time
| pt   print UNIX time (32 bit `cfg.bigendian`) Since January 1, 1970
| ptd  print DOS time (32 bit `cfg.bigendian`) Since January 1, 1980
| pth  print HFS time (32 bit `cfg.bigendian`) Since January 1, 1904
| ptn  print NTFS time (64 bit `cfg.bigendian`) Since January 1, 1601
</code></pre>
<p>For example, you can 'view' the current buffer as timestamps in the ntfs time:</p>
<pre><code>[0x08048000]&gt; e cfg.bigendian=false
[0x08048000]&gt; pt 4
29:04:32948 23:12:36 +0000
[0x08048000]&gt; e cfg.bigendian=true
[0x08048000]&gt; pt 4
20:05:13001 09:29:21 +0000
</code></pre>
<p>As you can see, the endianness affects the result. Once you have printed a timestamp, you can grep the output, for example, by year:</p>
<pre><code>[0x08048000]&gt; pt ~1974 | wc -l
15
[0x08048000]&gt; pt ~2022
27:04:2022 16:15:43 +0000
</code></pre>
<p>The default date format can be configured using the <code>cfg.datefmt</code> variable. Formatting rules for it follow the well known strftime(3) format. Check the manpage for more details, but these are the most important:</p>
<pre><code>%a  The abbreviated name of the day of the week according to the current locale.
%A  The full name of the day of the week according to the current locale.
%d  The day of the month as a decimal number (range 01 to 31).
%D  Equivalent to %m/%d/%y.  (Yecch—for Americans only).
%H  The hour as a decimal number using a 24-hour clock (range 00 to 23).
%I  The hour as a decimal number using a 12-hour clock (range 01 to 12).
%m  The month as a decimal number (range 01 to 12).
%M  The minute as a decimal number (range 00 to 59).
%p  Either &quot;AM&quot; or &quot;PM&quot; according to the given time value.
%s  The number of seconds since the Epoch, 1970-01-01 00:00:00  +0000 (UTC). (TZ)
%S  The second as a decimal number (range 00 to 60).  (The range is up to 60 to allow for occasional leap seconds.)
%T  The time in 24-hour notation (%H:%M:%S).  (SU)
%y  The year as a decimal number without a century (range 00 to 99).
%Y  The year as a decimal number including the century.
%z  The +hhmm or -hhmm numeric timezone (that is, the hour and minute offset from UTC). (SU)
%Z  The timezone name or abbreviation.
</code></pre>
<h3 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h3>
<p>There are print modes available for all basic types. If you are interested in a more complex structure, type <code>pf??</code> for format characters and <code>pf???</code> for examples:</p>
<pre><code>[0x00499999]&gt; pf??
|pf: pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]
| Format:
|  b       byte (unsigned)
|  B       resolve enum bitfield (see t?)
|  c       char (signed byte)
|  C       byte in decimal
|  d       0xHEX value (4 bytes) (see 'i' and 'x')
|  D       disassemble one opcode
|  e       temporally swap endian
|  E       resolve enum name (see t?)
|  f       float value (4 bytes)
|  F       double value (8 bytes)
|  i       signed integer value (4 bytes) (see 'd' and 'x')
|  n       next char specifies size of signed value (1, 2, 4 or 8 byte(s))
|  N       next char specifies size of unsigned value (1, 2, 4 or 8 byte(s))
|  o       octal value (4 byte)
|  p       pointer reference (2, 4 or 8 bytes)
|  q       quadword (8 bytes)
|  r       CPU register `pf r (eax)plop`
|  s       32bit pointer to string (4 bytes)
|  S       64bit pointer to string (8 bytes)
|  t       UNIX timestamp (4 bytes)
|  T       show Ten first bytes of buffer
|  u       uleb128 (variable length)
|  w       word (2 bytes unsigned short in hex)
|  x       0xHEX value and flag (fd @ addr) (see 'd' and 'i')
|  X       show formatted hexpairs
|  z       null terminated string
|  Z       null terminated wide string
|  ?       data structure `pf ? (struct_name)example_name`
|  *       next char is pointer (honors asm.bits)
|  +       toggle show flags for each offset
|  :       skip 4 bytes
|  .       skip 1 byte
|  ;       rewind 4 bytes
|  ,       rewind 1 byte
</code></pre>
<p>Use triple-question-mark <code>pf???</code> to get some examples using print format strings.</p>
<pre><code>[0x00499999]&gt; pf???
|pf: pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]
| Examples:
| pf 3xi foo bar                               3-array of struct, each with named fields: 'foo' as hex, and 'bar' as int
| pf B (BitFldType)arg_name`                   bitfield type
| pf E (EnumType)arg_name`                     enum type
| pf.obj xxdz prev next size name              Define the obj format as xxdz
| pf obj=xxdz prev next size name              Same as above
| pf *z*i*w nb name blob                       Print the pointers with given labels
| pf iwq foo bar troll                         Print the iwq format with foo, bar, troll as the respective names for the fields
| pf 0iwq foo bar troll                        Same as above, but considered as a union (all fields at offset 0)
| pf.plop ? (troll)mystruct                    Use structure troll previously defined
| pfj.plop @ 0x14                              Apply format object at the given offset
| pf 10xiz pointer length string               Print a size 10 array of the xiz struct with its field names
| pf 5sqw string quad word                     Print an array with sqw struct along with its field names
| pf {integer}? (bifc)                         Print integer times the following format (bifc)
| pf [4]w[7]i                                  Print an array of 4 words and then an array of 7 integers
| pf ic...?i foo bar &quot;(pf xw yo foo)troll&quot; yo  Print nested anonymous structures
| pf ;..x                                      Print value located 6 bytes from current offset
| pf [10]z[3]i[10]Zb                           Print an fixed size str, widechar, and var
| pfj +F @ 0x14                                Print the content at given offset with flag
| pf n2                                        print signed short (2 bytes) value. Use N instead of n for printing unsigned values
| pf [2]? (plop)structname @ 0                 Prints an array of structs
| pf eqew bigWord beef                         Swap endianness and print with given labels
| pf.foo rr (eax)reg1 (eip)reg2                Create object referencing to register values
| pf tt troll plop                             print time stamps with labels troll and plop
</code></pre>
<p>Some examples are below:</p>
<pre><code>[0x4A13B8C0]&gt; pf i
0x00404888 = 837634441
</code></pre>
<pre><code>[0x4A13B8C0]&gt; pf
0x00404888 = 837634432.000000
</code></pre>
<h3 id="high-level-languages-views"><a class="header" href="#high-level-languages-views">High-level Languages Views</a></h3>
<p>Valid print code formats for human-readable languages are:</p>
<ul>
<li><code>pc</code>     C</li>
<li><code>pc*</code>    print 'wx' rizin commands</li>
<li><code>pch</code>    C half-words (2 byte)</li>
<li><code>pcw</code>    C words (4 byte)</li>
<li><code>pcd</code>    C dwords (8 byte)</li>
<li><code>pci</code>    C array of bytes with instructions</li>
<li><code>pca</code>    GAS .byte blob</li>
<li><code>pcA</code>    .bytes with instructions in comments</li>
<li><code>pcs</code>    string</li>
<li><code>pcS</code>    shellscript that reconstructs the bin</li>
<li><code>pcj</code>    json</li>
<li><code>pcJ</code>    javascript</li>
<li><code>pco</code>    Objective-C</li>
<li><code>pcp</code>    python</li>
<li><code>pck</code>    kotlin</li>
<li><code>pcr</code>    rust</li>
<li><code>pcv</code>    JaVa</li>
<li><code>pcV</code>    V (vlang.io)</li>
<li><code>pcy</code>    yara</li>
<li><code>pcz</code>    Swift</li>
</ul>
<p>If we need to create a .c file containing a binary blob, use the <code>pc</code> command, that creates this output. The default size is like in many other commands: the block size, which can be changed with the <code>b</code> command.</p>
<p>We can also just temporarily override this block size by expressing it as an argument.</p>
<pre><code>[0xB7F8E810]&gt; pc 32
#define _BUFFER_SIZE 32
unsigned char buffer[_BUFFER_SIZE] = {
0x89, 0xe0, 0xe8, 0x49, 0x02, 0x00, 0x00, 0x89, 0xc7, 0xe8, 0xe2, 0xff, 0xff, 0xff, 0x81, 0xc3, 0xd6, 0xa7, 0x01, 0x00, 0x8b, 0x83, 0x00, 0xff, 0xff, 0xff, 0x5a, 0x8d, 0x24, 0x84, 0x29, 0xc2 };
</code></pre>
<p>That cstring can be used in many programming languages, not just C.</p>
<pre><code>[0x7fcd6a891630]&gt; pcs
&quot;\x48\x89\xe7\xe8\x68\x39\x00\x00\x49\x89\xc4\x8b\x05\xef\x16\x22\x00\x5a\x48\x8d\x24\xc4\x29\xc2\x52\x48\x89\xd6\x49\x89\xe5\x48\x83\xe4\xf0\x48\x8b\x3d\x06\x1a
</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Strings are probably one of the most important entry points when starting to reverse engineer a program because they usually reference information about functions' actions (asserts, debug or info messages...). Therefore, rizin supports various string formats:</p>
<pre><code>[0x00000000]&gt; ps?
|Usage: ps[bijqpsuwWxz+] [N]  Print String
| ps       print string
| ps+[j]   print libc++ std::string (same-endian, ascii, zero-terminated)
| psb      print strings in current block
| psi      print string inside curseek
| psj      print string in JSON format
| psp[j]   print pascal string
| psq      alias for pqs
| pss      print string in screen (wrap width)
| psu[zj]  print utf16 unicode (json)
| psw[j]   print 16bit wide string
| psW[j]   print 32bit wide string
| psx      show string with escaped chars
| psz[j]   print zero-terminated string
</code></pre>
<p>Most strings are zero-terminated. Below there is an example using the debugger to continue the execution of a program until it executes the 'open' syscall. When we recover the control over the process, we get the arguments passed to the syscall, pointed by %ebx. In the case of the 'open' call, it is a zero terminated string which we can inspect using <code>psz</code>.</p>
<pre><code>[0x4A13B8C0]&gt; dcs open
0x4a14fc24 syscall(5) open ( 0x4a151c91 0x00000000 0x00000000 ) = 0xffffffda
[0x4A13B8C0]&gt; dr
  eax  0xffffffda    esi  0xffffffff    eip    0x4a14fc24
  ebx  0x4a151c91    edi  0x4a151be1    oeax   0x00000005
  ecx  0x00000000    esp  0xbfbedb1c    eflags 0x200246
  edx  0x00000000    ebp  0xbfbedbb0    cPaZstIdor0 (PZI)
[0x4A13B8C0]&gt;
[0x4A13B8C0]&gt; psz @ 0x4a151c91
/etc/ld.so.cache
</code></pre>
<h3 id="print-memory-contents"><a class="header" href="#print-memory-contents">Print Memory Contents</a></h3>
<p>It is also possible to print various packed data types using the <code>pf</code> command:</p>
<pre><code>[0xB7F08810]&gt; pf xxS @ rsp
0x7fff0d29da30 = 0x00000001
0x7fff0d29da34 = 0x00000000
0x7fff0d29da38 = 0x7fff0d29da38 -&gt; 0x0d29f7ee /bin/ls
</code></pre>
<p>This can be used to look at the arguments passed to a function. To achieve this, simply pass a 'format memory string' as an argument to <code>pf</code>, and temporally change the current seek position/offset using <code>@</code>. It is also possible to define arrays of structures with <code>pf</code>. To do this, prefix the format string with a numeric value. You can also define a name for each field of the structure by appending them as a space-separated arguments list.</p>
<pre><code>[0x4A13B8C0]&gt; pf 2*xw pointer type @ esp
0x00404888 [0] {
   pointer :
(*0xffffffff8949ed31)      type : 0x00404888 = 0x8949ed31
   0x00404890 = 0x48e2
}
0x00404892 [1] {
(*0x50f0e483)    pointer : 0x00404892 = 0x50f0e483
	 type : 0x0040489a = 0x2440
}
</code></pre>
<p>A practical example for using <code>pf</code> on a binary of a GStreamer plugin:</p>
<pre><code>$ rizin /usr/lib/gstreamer-1.0/libgsttcp.so
 -- Move the comments to the right changing their margin with asm.cmt.margin
[0x00005020]&gt; aa; pdf @ sym.gst_plugin_tcp_get_desc
[x] Analyze all flags starting with sym. and entry0 (aa)
┌ 8: sym.gst_plugin_tcp_get_desc ();
│ bp: 0 (vars 0, args 0)
│ sp: 0 (vars 0, args 0)
│ rg: 0 (vars 0, args 0)
│           0x000127f0      lea rax, section..data.rel.ro              ; 0x1d460
└           0x000127f7      ret
[0x00005020]&gt; s section..data.rel.ro
[0x0001d460]&gt; pf ii*z*zp*z*z*z*z*z*z major minor name desc init version license source package origin release_datetime
            major : 0x0001d460 = 1
            minor : 0x0001d464 = 18
             name : (*0x15c8e)0x0001d468 = &quot;tcp&quot;
             desc : (*0x17c88)0x0001d470 = &quot;transfer data over the network via TCP&quot;
             init : 0x0001d478 = (qword)0x0000000000011430
          version : (*0x15d0b)0x0001d480 = &quot;1.18.2&quot;
          license : (*0x15d3e)0x0001d488 = &quot;LGPL&quot;
           source : (*0x15d2d)0x0001d490 = &quot;gst-plugins-base&quot;
          package : (*0x17cb0)0x0001d498 = &quot;GStreamer Base Plugins (Arch Linux)&quot;
           origin : (*0x15d12)0x0001d4a0 = &quot;https://www.archlinux.org/&quot;
 release_datetime : (*0x15d43)0x0001d4a8 = &quot;2020-12-06&quot;
</code></pre>
<h3 id="disassembly"><a class="header" href="#disassembly">Disassembly</a></h3>
<p>The <code>pd</code> command is used to disassemble code. It accepts a numeric value to specify how many instructions should be disassembled. The <code>pD</code> command is similar but instead of a number of instructions, it decompiles a given number of bytes.</p>
<ul>
<li><code>d</code> : disassembly N opcodes   count of opcodes</li>
<li><code>D</code> : asm.arch disassembler   bsize bytes</li>
</ul>
<pre><code>[0x00404888]&gt; pd 1
			;-- entry0:
			0x00404888    31ed         xor ebp, ebp
</code></pre>
<h3 id="selecting-target-architecture"><a class="header" href="#selecting-target-architecture">Selecting Target Architecture</a></h3>
<p>The architecture flavor for the disassembler is defined by the <code>asm.arch</code> eval variable. You can use <code>e asm.arch=??</code> to list all available architectures.</p>
<pre><code>[0x00005310]&gt; e asm.arch=??
_dAe  _8_16      6502        LGPL3   6502/NES/C64/Tamagotchi/T-1000 CPU
_dAe  _8         8051        PD      8051 Intel CPU
_dA_  _16_32     arc         GPL3    Argonaut RISC Core
a___  _16_32_64  arm.as      LGPL3   as ARM Assembler (use ARM_AS environment)
adAe  _16_32_64  arm         BSD     Capstone ARM disassembler
_dA_  _16_32_64  arm.gnu     GPL3    Acorn RISC Machine CPU
_d__  _16_32     arm.winedbg LGPL2   WineDBG's ARM disassembler
adAe  _8_16      avr         GPL     AVR Atmel
adAe  _16_32_64  bf          LGPL3   Brainfuck
_dA_  _32        chip8       LGPL3   Chip8 disassembler
_dA_  _16        cr16        LGPL3   cr16 disassembly plugin
_dA_  _32        cris        GPL3    Axis Communications 32-bit embedded processor
adA_  _32_64     dalvik      LGPL3   AndroidVM Dalvik
ad__  _16        dcpu16      PD      Mojang's DCPU-16
_dA_  _32_64     ebc         LGPL3   EFI Bytecode
adAe  _16        gb          LGPL3   GameBoy(TM) (z80-like)
_dAe  _16        h8300       LGPL3   H8/300 disassembly plugin
_dAe  _32        hexagon     LGPL3   Qualcomm Hexagon (QDSP6) V6
_d__  _32        hppa        GPL3    HP PA-RISC
_dAe  _0         i4004       LGPL3   Intel 4004 microprocessor
_dA_  _8         i8080       BSD     Intel 8080 CPU
adA_  _32        java        Apache  Java bytecode
_d__  _32        lanai       GPL3    LANAI
...
</code></pre>
<h3 id="configuring-the-disassembler"><a class="header" href="#configuring-the-disassembler">Configuring the Disassembler</a></h3>
<p>There are multiple options which can be used to configure the output of the disassembler. All these options are described in <code>el asm.</code></p>
<pre><code>[0x00005310]&gt; el asm.
asm.analysis: Analyze code and refs while disassembling (see analysis.strings)
asm.arch: Set the arch to be used by asm
asm.assembler: Set the plugin name to use when assembling
asm.bbline: Show empty line after every basic block
asm.bits: Word size in bits at assembler
asm.bytes: Display the bytes of each instruction
asm.bytespace: Separate hexadecimal bytes with a whitespace
asm.calls: Show callee function related info as comments in disasm
asm.capitalize: Use camelcase at disassembly
asm.cmt.col: Column to align comments
asm.cmt.flgrefs: Show comment flags associated to branch reference
asm.cmt.fold: Fold comments, toggle with Vz
...
</code></pre>
<p>Currently there are 136 <code>asm.</code> configuration variables so we do not list them all.</p>
<h3 id="disassembly-syntax"><a class="header" href="#disassembly-syntax">Disassembly Syntax</a></h3>
<p>The <code>asm.syntax</code> variable is used to change the flavor of the assembly syntax used by a disassembler engine. To switch between Intel and AT&amp;T representations:</p>
<pre><code>e asm.syntax=intel
e asm.syntax=att
</code></pre>
<p>You can also check <code>asm.pseudo</code>, which is an experimental pseudocode view,
and <code>asm.esil</code> which outputs <a href="basic_commands/../disassembling/esil.html">ESIL</a> ('Evaluable Strings Intermediate Language'). ESIL's goal is to have a human-readable representation of every opcode semantics. Such representations can be evaluated (interpreted) to emulate effects of individual instructions.</p>
<h3 id="print-gadgets"><a class="header" href="#print-gadgets">Print gadgets</a></h3>
<p>In Rizin, visual gadgets allows the users to cast or display the output of a particular Rizin command anywhere on the screen while in Visual mode.
This command is unrelated with displaying <a href="https://book.rizin.re/refcard/intro.html#searching">ROP Gadgets</a>.</p>
<p>Using the commands under <code>pg</code> (print gadgets), we can add, remove and change the location of these visual gadgets. You can add a gadget using <code>pg</code>:</p>
<pre><code>pg 10 10 10 10 ddr
</code></pre>
<p>This will add the output of the Rizin command <code>ddr</code> be printed on the screen. The four arguments to be passed are the position (like coordinates) and
the height and width of the gadget you would like to see. This command requires the configuration variable <code>scr.gadgets</code> to be turned on.</p>
<p>See <code>pg?</code> for more information.</p>
<h2 id="flags"><a class="header" href="#flags">Flags</a></h2>
<p>Flags are conceptually similar to bookmarks. They associate a name with a given offset in a file. Flags can be grouped into 'flag spaces'. A flag space is a namespace for flags, grouping together flags of similar characteristics or type. Examples for flag spaces: sections, registers, symbols.</p>
<p>To create a flag:</p>
<pre><code>[0x4A13B8C0]&gt; f flag_name @ offset
</code></pre>
<p>You can remove a flag by appending the <code>-</code> character to command. Most commands accept <code>-</code> as argument-prefix as an indication to delete something.</p>
<pre><code>[0x4A13B8C0]&gt; f-flag_name
</code></pre>
<p>To switch between or create new flagspaces use the <code>fs</code> command:</p>
<pre><code>[0x00005310]&gt; fs?
|Usage: fs [*] [+-][flagspace|addr] # Manage flagspaces
| fs            display flagspaces
| fs*           display flagspaces as rizin commands
| fsj           display flagspaces in JSON
| fs *          select all flagspaces
| fs flagspace  select flagspace or create if it doesn't exist
| fs-flagspace  remove flagspace
| fs-*          remove all flagspaces
| fs+foo        push previous flagspace and set
| fs-           pop to the previous flagspace
| fs-.          remove the current flagspace
| fsq           list flagspaces in quiet mode
| fsm [addr]    move flags at given address to the current flagspace
| fss           display flagspaces stack
| fss*          display flagspaces stack in rizin commands
| fssj          display flagspaces stack in JSON
| fsr newname   rename selected flagspace
[0x00005310]&gt; fs
0  439 * strings
1   17 * symbols
2   54 * sections
3   20 * segments
4  115 * relocs
5  109 * imports
[0x00005310]&gt;
</code></pre>
<p>Here there are some command examples:</p>
<pre><code>[0x4A13B8C0]&gt; fs symbols ; select only flags in symbols flagspace
[0x4A13B8C0]&gt; f          ; list only flags in symbols flagspace
[0x4A13B8C0]&gt; fs *       ; select all flagspaces
[0x4A13B8C0]&gt; f myflag   ; create a new flag called 'myflag'
[0x4A13B8C0]&gt; f-myflag  ; delete the flag called 'myflag'
</code></pre>
<p>You can rename flags with <code>fr</code>.</p>
<h3 id="local-flags"><a class="header" href="#local-flags">Local flags</a></h3>
<p>Every flag name should be unique for addressing reasons. But it is quite a common need
to have the flags, for example inside the functions, with simple and ubiquitous names like <code>loop</code> or <code>return</code>. For this purpose you can use so called &quot;local&quot; flags, which are tied to the function where they reside. It is possible to add them using <code>f.</code> command:</p>
<pre><code>[0x00003a04]&gt; pd 10
│      0x00003a04      48c705c9cc21.  mov qword [0x002206d8], 0xffffffffffffffff ;
[0x2206d8:8]=0
│      0x00003a0f      c60522cc2100.  mov byte [0x00220638], 0     ; [0x220638:1]=0
│      0x00003a16      83f802         cmp eax, 2
│  .─&lt; 0x00003a19      0f84880d0000   je 0x47a7
│  │   0x00003a1f      83f803         cmp eax, 3
│ .──&lt; 0x00003a22      740e           je 0x3a32
│ ││   0x00003a24      83e801         sub eax, 1
│.───&lt; 0x00003a27      0f84ed080000   je 0x431a
││││   0x00003a2d      e8fef8ffff     call sym.imp.abort           ; void abort(void)
││││   ; CODE XREF from main (0x3a22)
││╰──&gt; 0x00003a32      be07000000     mov esi, 7
[0x00003a04]&gt; f. localflag @ 0x3a32
[0x00003a04]&gt; f.
0x00003a32 localflag   [main + 210]
[0x00003a04]&gt; pd 10
│      0x00003a04      48c705c9cc21.  mov qword [0x002206d8], 0xffffffffffffffff ;
[0x2206d8:8]=0
│      0x00003a0f      c60522cc2100.  mov byte [0x00220638], 0     ; [0x220638:1]=0
│      0x00003a16      83f802         cmp eax, 2
│  .─&lt; 0x00003a19      0f84880d0000   je 0x47a7
│  │   0x00003a1f      83f803         cmp eax, 3
│ .──&lt; 0x00003a22      740e           je 0x3a32                    ; main.localflag
│ ││   0x00003a24      83e801         sub eax, 1
│.───&lt; 0x00003a27      0f84ed080000   je 0x431a
││││   0x00003a2d      e8fef8ffff     call sym.imp.abort           ; void abort(void)
││││   ; CODE XREF from main (0x3a22)
││`──&gt;  .localflag:
││││   ; CODE XREF from main (0x3a22)
││`──&gt; 0x00003a32      be07000000     mov esi, 7
[0x00003a04]&gt;
</code></pre>
<h3 id="flag-zones"><a class="header" href="#flag-zones">Flag Zones</a></h3>
<p>rizin offers flag zones, which lets you label different offsets on the scrollbar, for making it easier to navigate through large binaries. You can set a flag zone on the current seek using:</p>
<pre><code>[0x00003a04]&gt; fz flag-zone-name
</code></pre>
<p>Set <code>scr.scrollbar=1</code> and go to the Visual mode, to see your flag zone appear on the scrollbar on the right end of the window.</p>
<p>See <code>fz?</code> for more information.</p>
<h2 id="writing-data"><a class="header" href="#writing-data">Writing Data</a></h2>
<p>Rizin can manipulate a loaded binary file in many ways. You can resize the file, move and copy/paste bytes, insert new bytes (shifting data to the end of the block or file), or simply overwrite bytes. New data may be given as a wide-string, assembler instructions, or the data may be read in from another file.</p>
<p>Resize the file using the <code>r</code> command. It accepts a numeric argument. A positive value sets a new size for the file. A negative one will truncate the file to the current seek position minus N bytes.</p>
<pre><code>r 1024      ; resize the file to 1024 bytes
r -10 @ 33  ; strip 10 bytes at offset 33
</code></pre>
<p>Write bytes using the <code>w</code> command. It accepts multiple input formats like inline assembly, endian-friendly dwords, files, hexpair files, wide strings:</p>
<pre><code>[0x00404888]&gt; w?
Usage: w[x] [str] [&lt;file] [&lt;&lt;EOF] [@addr]  
| w[1248][+-][n]       increment/decrement byte,word..
| w foobar             write string 'foobar'
| w0 [len]             write 'len' bytes with value 0x00
| w6[de] base64/hex    write base64 [d]ecoded or [e]ncoded string
| wa[?] push ebp       write opcode, separated by ';' (use '&quot;' around the command)
| waf f.asm            assemble file and write bytes
| waF f.asm            assemble file and write bytes and show 'wx' op with hexpair bytes of assembled code
| wao[?] op            modify opcode (change conditional of jump. nop, etc)
| wA[?] r 0            alter/modify opcode at current seek (see wA?)
| wb 010203            fill current block with cyclic hexpairs
| wB[-]0xVALUE         set or unset bits with given value
| wc                   list all write changes
| wc[?][jir+-*?]       write cache undo/commit/reset/list (io.cache)
| wd [off] [n]         duplicate N bytes from offset at current seek (memcpy) (see y?)
| we[?] [nNsxX] [arg]  extend write operations (insert instead of replace)
| wf[fs] -|file        write contents of file at current offset
| wh rizin                whereis/which shell command
| wm f0ff              set binary mask hexpair to be used as cyclic write mask
| wo[?] hex            write in block with operation. 'wo?' fmi
| wp[?] -|file         apply rizin patch file. See wp? fmi
| wr 10                write 10 random bytes
| ws pstring           write 1 byte for length and then the string
| wt[f][?] file [sz]   write to file (from current seek, blocksize or sz bytes)
| wts host:port [sz]   send data to remote host:port via tcp://
| ww foobar            write wide string 'f\x00o\x00o\x00b\x00a\x00r\x00'
| wx[?][fs] 9090       write two intel nops (from wxfile or wxseek)
| wv[?] eip+34         write 32-64 bit value honoring cfg.bigendian
| wz string            write zero terminated string (like w + \x00)
</code></pre>
<p>Some examples:</p>
<pre><code> [0x00000000]&gt; wx 123456 @ 0x8048300
 [0x00000000]&gt; wv 0x8048123 @ 0x8049100
 [0x00000000]&gt; wa jmp 0x8048320
</code></pre>
<h3 id="write-over"><a class="header" href="#write-over">Write Over</a></h3>
<p>The <code>wo</code> command (write over) has many subcommands, each combines the existing data with the new data using
an operator. The command is applied to the current block. Supported operators include XOR, ADD, SUB...</p>
<pre><code>[0x4A13B8C0]&gt; wo?
|Usage: wo[asmdxoArl24] [hexpairs] @ addr[:bsize]
|Example:
|  wox 0x90   ; xor cur block with 0x90
|  wox 90     ; xor cur block with 0x90
|  wox 0x0203 ; xor cur block with 0203
|  woa 02 03  ; add [0203][0203][...] to curblk
|  woe 02 03  ; create sequence from 2 to 255 with step 3
|Supported operations:
|  wow  ==  write looped value (alias for 'wb')
|  woa  +=  addition
|  wos  -=  subtraction
|  wom  *=  multiply
|  wod  /=  divide
|  wox  ^=  xor
|  woo  |=  or
|  woA  &amp;=  and
|  woR  random bytes (alias for 'wr $b'
|  wor  &gt;&gt;= shift right
|  wol  &lt;&lt;= shift left
|  wo2  2=  2 byte endian swap
|  wo4  4=  4 byte endian swap
</code></pre>
<p>It is possible to implement cipher-algorithms using rizin core primitives and <code>wo</code>. A sample session performing xor(90) + add(01, 02):</p>
<pre><code>[0x7fcd6a891630]&gt; px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  4889 e7e8 6839 0000 4989 c48b 05ef 1622
0x7fcd6a891640  005a 488d 24c4 29c2 5248 89d6 4989 e548
0x7fcd6a891650  83e4 f048 8b3d 061a 2200 498d 4cd5 1049
0x7fcd6a891660  8d55 0831 ede8 06e2 0000 488d 15cf e600
[0x7fcd6a891630]&gt; wox 90
[0x7fcd6a891630]&gt; px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  d819 7778 d919 541b 90ca d81d c2d8 1946
0x7fcd6a891640  1374 60d8 b290 d91d 1dc5 98a1 9090 d81d
0x7fcd6a891650  90dc 197c 9f8f 1490 d81d 95d9 9f8f 1490
0x7fcd6a891660  13d7 9491 9f8f 1490 13ff 9491 9f8f 1490
[0x7fcd6a891630]&gt; woa 01 02
[0x7fcd6a891630]&gt; px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  d91b 787a 91cc d91f 1476 61da 1ec7 99a3
0x7fcd6a891640  91de 1a7e d91f 96db 14d9 9593 1401 9593
0x7fcd6a891650  c4da 1a6d e89a d959 9192 9159 1cb1 d959
0x7fcd6a891660  9192 79cb 81da 1652 81da 1456 a252 7c77
</code></pre>
<h2 id="zoom"><a class="header" href="#zoom">Zoom</a></h2>
<p>The zoom is a print mode that allows you to get a global view of the whole file or a memory map on a single screen. In this mode, each byte represents <code>file_size/block_size</code> bytes of the file. Use the <code>pz</code> command, or just use <code>Z</code> in the visual mode to toggle the zoom mode.</p>
<p>The cursor can be used to scroll faster through the zoom out view. Pressing <code>z</code> again will zoom-in at the cursor position.</p>
<pre><code>[0x004048c5]&gt; pz?
|Usage: pz [len] print zoomed blocks (filesize/N)
| e zoom.maxsz  max size of block
| e zoom.from   start address
| e zoom.to     end address
| e zoom.byte   specify how to calculate each byte
| pzp           number of printable chars
| pzf           count of flags in block
| pzs           strings in range
| pz0           number of bytes with value '0'
| pzF           number of bytes with value 0xFF
| pze           calculate entropy and expand to 0-255 range
| pzh           head (first byte value); This is the default mode
</code></pre>
<p>Let's see some examples:</p>
<pre><code>[0x08049790]&gt; e zoom.byte=h
[0x08049790]&gt; pz // or default pzh
0x00000000  7f00 0000 e200 0000 146e 6f74 0300 0000
0x00000010  0000 0000 0068 2102 00ff 2024 e8f0 007a
0x00000020  8c00 18c2 ffff 0080 4421 41c4 1500 5dff
0x00000030  ff10 0018 0fc8 031a 000c 8484 e970 8648
0x00000040  d68b 3148 348b 03a0 8b0f c200 5d25 7074
0x00000050  7500 00e1 ffe8 58fe 4dc4 00e0 dbc8 b885
</code></pre>
<pre><code>[0x08049790]&gt; e zoom.byte=p
[0x08049790]&gt; pz // or pzp
0x00000000  2f47 0609 070a 0917 1e9e a4bd 2a1b 2c27
0x00000010  322d 5671 8788 8182 5679 7568 82a2 7d89
0x00000020  8173 7f7b 727a 9588 a07b 5c7d 8daf 836d
0x00000030  b167 6192 a67d 8aa2 6246 856e 8c9b 999f
0x00000040  a774 96c3 b1a4 6c8e a07c 6a8f 8983 6a62
0x00000050  7d66 625f 7ea4 7ea6 b4b6 8b57 a19f 71a2
</code></pre>
<pre><code>[0x08049790]&gt; eval zoom.byte = flags
[0x08049790]&gt; pz // or pzf
0x00406e65  48d0 80f9 360f 8745 ffff ffeb ae66 0f1f
0x00406e75  4400 0083 f801 0f85 3fff ffff 410f b600
0x00406e85  3c78 0f87 6301 0000 0fb6 c8ff 24cd 0026
0x00406e95  4100 660f 1f84 0000 0000 0084 c074 043c
0x00406ea5  3a75 18b8 0500 0000 83f8 060f 95c0 e9cd
0x00406eb5  feff ff0f 1f84 0000 0000 0041 8801 4983
0x00406ec5  c001 4983 c201 4983 c101 e9ec feff ff0f
</code></pre>
<pre><code>[0x08049790]&gt; e zoom.byte=F
[0x08049790]&gt; pO // or pzF
0x00000000  0000 0000 0000 0000 0000 0000 0000 0000
0x00000010  0000 2b5c 5757 3a14 331f 1b23 0315 1d18
0x00000020  222a 2330 2b31 2e2a 1714 200d 1512 383d
0x00000030  1e1a 181b 0a10 1a21 2a36 281e 1d1c 0e11
0x00000040  1b2a 2f22 2229 181e 231e 181c 1913 262b
0x00000050  2b30 4741 422f 382a 1e22 0f17 0f10 3913
</code></pre>
<p>You can limit zooming to a range of bytes instead of the whole bytespace. Change <code>zoom.from</code> and <code>zoom.to</code> eval variables:</p>
<pre><code>[0x00003a04]&gt; el zoom.
zoom.byte: Zoom callback to calculate each byte (See pz? for help)
zoom.from: Zoom start address
zoom.in: Specify  boundaries for zoom
zoom.maxsz: Zoom max size of block
zoom.to: Zoom end address
[0x00003a04]&gt; e zoom.
zoom.byte = h
zoom.from = 0
zoom.in = io.map
zoom.maxsz = 512
zoom.to = 0
</code></pre>
<h2 id="yankpaste"><a class="header" href="#yankpaste">Yank/Paste</a></h2>
<p>Rizin has an internal clipboard to save and write portions of memory loaded from the current io layer.</p>
<p>This clipboard can be manipulated with the <code>y</code> command.</p>
<p>The two basic operations are</p>
<ul>
<li>copy (yank)</li>
<li>paste</li>
</ul>
<p>The yank operation will read N bytes (specified by the argument) into the clipboard. We can later use the <code>yy</code> command to paste what we read before into a file.</p>
<p>You can yank/paste bytes in visual mode selecting them with the cursor mode (<code>Vc</code>) and then using the <code>y</code> and <code>Y</code> key bindings which are aliases for <code>y</code> and <code>yy</code> commands of the command-line interface.</p>
<pre><code>[0x00000000]&gt; y?
Usage: y[ptxy] [len] [[@]addr]   # See wd? for memcpy, same as 'yf'.
| y!              open cfg.editor to edit the clipboard
| y 16 0x200      copy 16 bytes into clipboard from 0x200
| y 16 @ 0x200    copy 16 bytes into clipboard from 0x200
| y 16            copy 16 bytes into clipboard
| y               show yank buffer information (srcoff len bytes)
| y*              print in rizin commands what's been yanked
| yf 64 0x200     copy file 64 bytes from 0x200 from file
| yfa file copy   copy all bytes from file (opens w/ io)
| yfx 10203040    yank from hexpairs (same as ywx)
| yj              print in JSON commands what's been yanked
| yp              print contents of clipboard
| yq              print contents of clipboard in hexpairs
| ys              print contents of clipboard as string
| yt 64 0x200     copy 64 bytes from current seek to 0x200
| ytf file        dump the clipboard to given file
| yw hello world  yank from string
| ywx 10203040    yank from hexpairs (same as yfx)
| yx              print contents of clipboard in hexadecimal
| yy 0x3344       paste clipboard
| yz [len]        copy nul-terminated string (up to blocksize) into clipboard
</code></pre>
<p>Sample session:</p>
<pre><code>[0x00000000]&gt; s 0x100    ; seek at 0x100
[0x00000100]&gt; y 100      ; yanks 100 bytes from here
[0x00000200]&gt; s 0x200    ; seek 0x200
[0x00000200]&gt; yy         ; pastes 100 bytes
</code></pre>
<p>You can perform a yank and paste in a single line by just using the <code>yt</code> command (yank-to). The syntax is as follows:</p>
<pre><code>[0x4A13B8C0]&gt; x
   offset   0 1  2 3  4 5  6 7  8 9  A B  0123456789AB
0x4A13B8C0, 89e0 e839 0700 0089 c7e8 e2ff ...9........
0x4A13B8CC, ffff 81c3 eea6 0100 8b83 08ff ............
0x4A13B8D8, ffff 5a8d 2484 29c2           ..Z.$.).

[0x4A13B8C0]&gt; yt 8 0x4A13B8CC @ 0x4A13B8C0

[0x4A13B8C0]&gt; x
   offset   0 1  2 3  4 5  6 7  8 9  A B  0123456789AB
0x4A13B8C0, 89e0 e839 0700 0089 c7e8 e2ff ...9........
0x4A13B8CC, 89e0 e839 0700 0089 8b83 08ff ...9........
0x4A13B8D8, ffff 5a8d 2484 29c2           ..Z.$.).
</code></pre>
<h2 id="comparing-bytes"><a class="header" href="#comparing-bytes">Comparing Bytes</a></h2>
<p>For most generic reverse engineering tasks like finding the differences between two binary files, which bytes has changed, find differences in the graphs of the code analysis results, and other diffing operations you can just use rz-diff:</p>
<pre><code>$ rz-diff -h
</code></pre>
<p>Inside rizin, the functionalities exposed by rz-diff are available with the <code>c</code> command.</p>
<p><code>c</code> (short for &quot;compare&quot;) allows you to compare arrays of bytes from different sources. The command accepts input in a number of formats and then compares it against values found at current seek position.</p>
<pre><code>[0x00404888]&gt; c?
Usage: c[?dfx] [argument]   # Compare
| c [string]               Compare a plain with escaped chars string
| c* [string]              Same as above, but printing rizin commands instead
| c1 [addr]                Compare 8 bits from current offset
| c2 [value]               Compare a word from a math expression
| c4 [value]               Compare a doubleword from a math expression
| c8 [value]               Compare a quadword from a math expression
| cat [file]               Show contents of file (see pwd, ls)
| cc [at]                  Compares in two hexdump columns of block size
| ccc [at]                 Same as above, but only showing different lines
| ccd [at]                 Compares in two disasm columns of block size
| cd [dir]                 chdir
| cf [file]                Compare contents of file at current seek
| cg[?] [o] [file]         Graphdiff current file and [file]
| cl|cls|clear             Clear screen, (clear0 to goto 0, 0 only)
| cu[?] [addr] @at         Compare memory hexdumps of $$ and dst in unified diff
| cud [addr] @at           Unified diff disasm from $$ and given address
| cv[1248] [hexpairs] @at  Compare 1,2,4,8-byte (silent return in $?)
| cV[1248] [addr] @at      Compare 1,2,4,8-byte address contents (silent, return in $?)
| cw[?] [us?] [...]        Compare memory watchers
| cx [hexpair]             Compare hexpair string (use '.' as nibble wildcard)
| cx* [hexpair]            Compare hexpair string (output rizin commands)
| cX [addr]                Like 'cc' but using hexdiff output
</code></pre>
<p>To compare memory contents at current seek position against a given string of values, use <code>cx</code>:</p>
<pre><code>[0x08048000]&gt; p8 4
7f 45 4c 46

[0x08048000]&gt; cx 7f 45 90 46
Compare 3/4 equal bytes
0x00000002 (byte=03)   90 ' '  -&gt;  4c 'L'
[0x08048000]&gt;
</code></pre>
<p>Another subcommand of the <code>c</code> command is <code>cc</code> which stands for &quot;compare code&quot;.
To compare a byte sequence with a sequence in memory:</p>
<pre><code>[0x4A13B8C0]&gt; cc 0x39e8e089 @ 0x4A13B8C0
</code></pre>
<p>To compare contents of two functions specified by their names:</p>
<pre><code>[0x08049A80]&gt; cc sym.main2 @ sym.main
</code></pre>
<p><code>c8</code> compares a quadword from the current seek (in the example below, 0x00000000) against a math expression:</p>
<pre><code>[0x00000000]&gt; c8 4

Compare 1/8 equal bytes (0%)
0x00000000 (byte=01)   7f ' '  -&gt;  04 ' '
0x00000001 (byte=02)   45 'E'  -&gt;  00 ' '
0x00000002 (byte=03)   4c 'L'  -&gt;  00 ' '
</code></pre>
<p>The number parameter can, of course, be math expressions which use flag names and anything allowed in an expression:</p>
<pre><code>[0x00000000]&gt; cx 7f469046

Compare 2/4 equal bytes
0x00000001 (byte=02)   45 'E'  -&gt;  46 'F'
0x00000002 (byte=03)   4c 'L'  -&gt;  90 ' '
</code></pre>
<p>You can use the compare command to find differences between a current block and a file previously dumped to a disk:</p>
<pre><code>rizin /bin/true
[0x08049A80]&gt; s 0
[0x08048000]&gt; cf /bin/true
Compare 512/512 equal bytes
</code></pre>
<h1 id="sdb"><a class="header" href="#sdb">SDB</a></h1>
<p>SDB stands for String DataBase. It's a simple key-value database that only operates with strings created by pancake. It is used in many parts of rizin to have a disk and in-memory database which is small and fast to manage using it as a hashtable on steroids.</p>
<p>SDB is a simple string key/value database based on djb’s cdb disk storage and supports JSON and arrays introspection.</p>
<p>SDB supports:</p>
<ul>
<li>namespaces (multiple sdb paths)</li>
<li>atomic database sync (never corrupted)</li>
<li>bindings for vala, luvit, newlisp and nodejs</li>
<li>commandline frontend for sdb databases</li>
<li>memcache client and server with sdb backend</li>
<li>arrays support (syntax sugar)</li>
<li>json parser/getter</li>
</ul>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage example</a></h2>
<p>Let's create a database!</p>
<pre><code>$ sdb d hello=world
$ sdb d hello
world
</code></pre>
<p>Using arrays:</p>
<pre><code>$ sdb - '[]list=1,2' '[0]list' '[0]list=foo' '[]list' '[+1]list=bar'
1
foo
2
foo
bar
2
</code></pre>
<p>Let's play with json:</p>
<pre><code>$ sdb d g='{&quot;foo&quot;:1,&quot;bar&quot;:{&quot;cow&quot;:3}}'
$ sdb d g?bar.cow
3
$ sdb - user='{&quot;id&quot;:123}' user?id=99 user?id
99
</code></pre>
<p>Using the command line without any disk database:</p>
<pre><code>$ sdb - foo=bar foo a=3 +a -a
bar
4
3

$ sdb -
foo=bar
foo
bar
a=3
+a
4
-a
3
</code></pre>
<p>Remove the database</p>
<pre><code>$ rm -f d

</code></pre>
<h2 id="so-what-"><a class="header" href="#so-what-">So what ?</a></h2>
<p>So, you can now do this inside your rizin sessions!</p>
<p>Let's take a simple binary, and check what is already <em>sdbized</em>.</p>
<pre><code>$ cat test.c
int main(){
	puts(&quot;Hello world\n&quot;);
}
$ gcc test.c -o test
</code></pre>
<pre><code>$ rizin -A ./test
[0x08048320]&gt; k **
bin
analysis
syscall
debug
</code></pre>
<pre><code>[0x08048320]&gt; k bin/**
fd.6
[0x08048320]&gt; k bin/fd.6/*
archs=0:0:x86:32
</code></pre>
<p>The file corresponding to the sixth file descriptor is a x86_32 binary.</p>
<pre><code>[0x08048320]&gt; k analysis/meta/*
meta.s.0x80484d0=12,SGVsbG8gd29ybGQ=
[...]
[0x08048320]&gt; ?b64- SGVsbG8gd29ybGQ=
Hello world
</code></pre>
<p>Strings are stored encoded in base64.</p>
<hr />
<h2 id="more-examples"><a class="header" href="#more-examples">More Examples</a></h2>
<p>List namespaces</p>
<pre><code>k **
</code></pre>
<p>List sub-namespaces</p>
<pre><code>k analysis/**
</code></pre>
<p>List keys</p>
<pre><code>k *
k analysis/*
</code></pre>
<p>Set a key</p>
<pre><code>k foo=bar
</code></pre>
<p>Get the value of a key</p>
<pre><code>k foo
</code></pre>
<p>List all syscalls</p>
<pre><code>k syscall/*~^0x
</code></pre>
<p>List all comments</p>
<pre><code>k analysis/meta/*~.C.
</code></pre>
<p>Show a comment at given offset:</p>
<pre><code>k %analysis/meta/[1]meta.C.0x100005000
</code></pre>
<h1 id="dietline"><a class="header" href="#dietline">Dietline</a></h1>
<p>Rizin comes with the lean <a href="https://en.wikipedia.org/wiki/GNU_Readline">readline</a>-like input capability through the lean library to handle the command edition and history navigation. It allows users to perform cursor movements, search the
history, and implements autocompletion. Moreover, due to the rizin portability, dietline provides
the uniform experience among all supported platforms. It is used in all rizin subshells - main
prompt, SDB shell, visual prompt, and offsets prompt. It also implements the most common features
and keybindings compatible with the GNU Readline.</p>
<p>Dietline supports two major configuration modes : Emacs-mode and Vi-mode. </p>
<p>It also supports the famous <code>Ctrl-R</code> reverse history search. Using <code>TAB</code> key it allows to scroll through the
autocompletion options.</p>
<h1 id="autocompletion"><a class="header" href="#autocompletion">Autocompletion</a></h1>
<p>In the every shell and rizin command autocompletion is supported. There are multiple modes of it -
files, flags, and SDB keys/namespaces. To provide the easy way to select possible completion options
the scrollable popup widget is available. It can be enabled with <code>scr.prompt.popup</code>, just set it to
the <code>true</code>.</p>
<h1 id="emacs-default-mode"><a class="header" href="#emacs-default-mode">Emacs (default) mode</a></h1>
<p>By default dietline mode is compatible with readline Emacs-like mode key bindings. Thus active are:</p>
<h2 id="moving"><a class="header" href="#moving">Moving</a></h2>
<ul>
<li><code>Ctrl-a</code> - move to the beginning of the line</li>
<li><code>Ctrl-e</code> - move to the end of the line</li>
<li><code>Ctrl-b</code> - move one character backward</li>
<li><code>Ctrl-f</code> - move one character forward</li>
</ul>
<h2 id="deleting"><a class="header" href="#deleting">Deleting</a></h2>
<ul>
<li><code>Ctrl-w</code> - delete the previous word</li>
<li><code>Ctrl-u</code> - delete the whole line</li>
<li><code>Ctrl-h</code> - delete a character to the left</li>
<li><code>Ctrl-d</code> - delete a character to the right</li>
<li><code>Alt-d</code> - cuts the character after the cursor</li>
</ul>
<h2 id="killing-and-yanking"><a class="header" href="#killing-and-yanking">Killing and Yanking</a></h2>
<ul>
<li><code>Ctrl-k</code> - kill the text from point to the end of the line.</li>
<li><code>Ctrl-x</code> - kill backward from the cursor to the beginning of the current line.</li>
<li><code>Ctrl-t</code> - kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as forward-word.</li>
<li><code>Ctrl-w</code> - kill the word behind point, using white space as a word boundary. The killed text is saved on the kill-ring.</li>
<li><code>Ctrl-y</code> - yank the top of the kill ring into the buffer at point.</li>
<li><code>Ctrl-]</code> - rotate the kill-ring, and yank the new top. You can only do this if the prior command is yank or yank-pop.</li>
</ul>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<ul>
<li><code>Ctrl-r</code> - the reverse search in the command history</li>
</ul>
<h1 id="vi-mode"><a class="header" href="#vi-mode">Vi mode</a></h1>
<p>Rizin also comes with in vi mode that can be enabled by toggling <code>scr.prompt.vi</code>. The various keybindings available in this mode are:</p>
<h2 id="entering-command-modes"><a class="header" href="#entering-command-modes">Entering command modes</a></h2>
<ul>
<li><code>ESC</code> - enter into the control mode</li>
<li><code>i</code> - enter into the insert mode</li>
</ul>
<h2 id="moving-1"><a class="header" href="#moving-1">Moving</a></h2>
<ul>
<li><code>j</code> - acts like up arrow key</li>
<li><code>k</code> - acts like down arrow key</li>
<li><code>a</code> - move cursor forward and enter into insert mode</li>
<li><code>I</code> - move to the beginning of the line and enter into insert mode</li>
<li><code>A</code> - move to the end of the line and enter into insert mode</li>
<li><code>^</code> - move to the beginning of the line</li>
<li><code>0</code> - move to the beginning of the line</li>
<li><code>$</code> - move to the end of the line</li>
<li><code>h</code> - move one character backward</li>
<li><code>l</code> - move one character forward</li>
</ul>
<h2 id="deleting-and-yanking"><a class="header" href="#deleting-and-yanking">Deleting and Yanking</a></h2>
<ul>
<li><code>x</code> - cuts the character</li>
<li><code>dw</code> - delete the current word</li>
<li><code>diw</code> - deletes the current word.</li>
<li><code>db</code> - delete the previous word</li>
<li><code>D</code> - delete the whole line</li>
<li><code>dh</code> - delete a character to the left</li>
<li><code>dl</code> - delete a character to the right</li>
<li><code>d$</code> - kill the text from point to the end of the line.</li>
<li><code>d^</code> - kill backward from the cursor to the beginning of the current line.</li>
<li><code>de</code> - kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as forward-word.</li>
<li><code>p</code> - yank the top of the kill ring into the buffer at point.</li>
<li><code>c</code> - acts similar to d based commands, but goes into insert mode in the end by prefixing the commands with numbers, the command is performed multiple times.</li>
</ul>
<p>If you are finding it hard to keep track of which mode you are in, just set <code>scr.prompt.mode=true</code> to update the color of the prompt based on the vi-mode.</p>
<h1 id="visual-mode"><a class="header" href="#visual-mode">Visual Mode</a></h1>
<p>The visual mode is a more user-friendly interface alternative to rizin's command-line prompt. It allows easy navigation, has a cursor mode for selecting bytes, and offers numerous key bindings to simplify debugger use.
To enter visual mode, use <code>V</code> command. To exit from it back to command line, press <code>q</code>.</p>
<h2 id="navigation"><a class="header" href="#navigation">Navigation</a></h2>
<p>Navigation can be done using HJKL or arrow keys and PgUp/PgDown keys. It also understands usual Home/End keys.
Like in Vim the movements can be repeated by preceding the navigation key with the number, for
example <code>5j</code> will move down for 5 lines, or <code>2l</code> will move 2 characters right.</p>
<p><img src="visual_mode/visualmode.png" alt="Visual Mode" /></p>
<h2 id="print-modes-aka-panels"><a class="header" href="#print-modes-aka-panels">print modes aka panels</a></h2>
<p>The Visual mode uses &quot;print modes&quot; which are basically different panel that you can rotate. By default those are:</p>
<p>↻ <strong>Hexdump panel</strong> -&gt; <strong>Disassembly panel</strong> → <strong>Debugger panel</strong> → <strong>Hexadecimal words dump panel</strong> → <strong>Hex-less hexdump panel</strong> → <strong>Op analysis color map panel</strong> → <strong>Annotated hexdump panel</strong> ↺.</p>
<p>Notice that the top of the panel contains the command which is used, for example for the disassembly panel:</p>
<pre><code>[0x00404890 16% 120 /bin/ls]&gt; pd $r @ entry0
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>To see help on all key bindings defined for visual mode, press <code>?</code>:</p>
<pre><code>Visual mode help:
 ?        show this help
 ??       show the user-friendly hud
 %        in cursor mode finds matching pair, or toggle autoblocksz
 @        redraw screen every 1s (multi-user view)
 ^        seek to the beginning of the function
 !        enter into the visual panels mode
 _        enter the flag/comment/functions/.. hud (same as VF_)
 =        set cmd.vprompt (top row)
 |        set cmd.cprompt (right column)
 .        seek to program counter
 \        toggle visual split mode
 &quot;        toggle the column mode (uses pC..)
 /        in cursor mode search in current block
 :cmd     run rizin command
 ;[-]cmt  add/remove comment
 0        seek to beginning of current function
 [1-9]    follow jmp/call identified by shortcut (like ;[1])
 ,file    add a link to the text file
 /*+-[]   change block size, [] = resize hex.cols
 &lt;/&gt;      seek aligned to block size (seek cursor in cursor mode)
 a/A      (a)ssemble code, visual (A)ssembler
 b        browse symbols, flags, configurations, classes, ...
 B        toggle breakpoint
 c/C      toggle (c)ursor and (C)olors
 d[f?]    define function, data, code, ..
 D        enter visual diff mode (set diff.from/to
 e        edit eval configuration variables
 f/F      set/unset or browse flags. f- to unset, F to browse, ..
 gG       go seek to begin and end of file (0-$s)
 hjkl     move around (or HJKL) (left-down-up-right)
 i        insert hex or string (in hexdump) use tab to toggle
 mK/'K    mark/go to Key (any key)
 n/N      seek next/prev function/flag/hit (scr.nkey)
 g        go/seek to given offset
 O        toggle asm.pseudo and asm.esil
 p/P      rotate print modes (hex, disasm, debug, words, buf)
 q        back to rizin shell
 r        refresh screen / in cursor mode browse comments
 R        randomize color palette (ecr)
 sS       step / step over
 t        browse types
 uU       undo/redo seek
 v        visual function/vars code analysis menu
 V        (V)iew graph using cmd.graph (agv?)
 wW       seek cursor to next/prev word
 xX       show xrefs/refs of current function from/to data/code
 yY       copy and paste selection
 z        fold/unfold comments in disassembly
 Z        toggle zoom mode
 Enter    follow address of jump/call
Function Keys: (See 'e key.'), defaults to:
  F2      toggle breakpoint
  F4      run to cursor
  F7      single step
  F8      step over
  F9      continue
</code></pre>
<h1 id="visual-disassembly"><a class="header" href="#visual-disassembly">Visual Disassembly</a></h1>
<h2 id="navigation-1"><a class="header" href="#navigation-1">Navigation</a></h2>
<p>Move within the Disassembly using arrow keys or <code>hjkl</code>. Use <code>g</code> to seek directly to a flag or an offset, type it when requested by the prompt: <code>[offset]&gt;</code>.
Follow a jump or a call using the <code>number</code> of your keyboard <code>[0-9]</code> and the number on the right in disassembly to follow a call or a jump. In this example typing <code>1</code> on the keyboard would follow the call to <code>sym.imp.__libc_start_main</code> and therefore, seek at the offset of this symbol.</p>
<pre><code>0x00404894      e857dcffff     call sym.imp.__libc_start_main ;[1]
</code></pre>
<p>Seek back to the previous location using <code>u</code>, <code>U</code> will allow you to redo the seek.</p>
<h2 id="d-as-define"><a class="header" href="#d-as-define"><code>d</code> as define</a></h2>
<p><code>d</code> can be used to change the type of data of the current block, several basic types/structures are available as well as more advanced one using <code>pf</code> template:</p>
<pre><code>d → ...
0x004048f7      48c1e83f       shr rax, 0x3f
d → b
0x004048f7 .byte 0x48
d → B
0x004048f7 .word 0xc148
d → d
0x004048f7 hex length=165 delta=0
0x004048f7  48c1 e83f 4801 c648 d1fe 7415 b800 0000
...
</code></pre>
<p>To improve code readability you can change how rizin presents numerical values in disassembly, by default most of disassembly display numerical value as hexadecimal. Sometimes you would like to view it as a decimal, binary or even custom defined constant. To change value format you can use <code>d</code> following by <code>i</code> then choose what base to work in, this is the equivalent to <code>ahi</code>:</p>
<pre><code>d → i → ...
0x004048f7      48c1e83f       shr rax, 0x3f
d → i →  10
0x004048f7      48c1e83f       shr rax, 63
d → i →  2
0x004048f7      48c1e83f       shr rax, '?'
</code></pre>
<h3 id="usage-of-the-cursor-for-insertingpatching"><a class="header" href="#usage-of-the-cursor-for-insertingpatching">Usage of the Cursor for Inserting/Patching...</a></h3>
<p>Remember that, to be able to actually edit files loaded in rizin, you have to start it with the <code>-w</code> option. Otherwise a file is opened in read-only mode.</p>
<p>Pressing lowercase <code>c</code> toggles the cursor mode. When this mode is active, the currently selected byte (or byte range) is highlighted.</p>
<p><img src="visual_mode/cursor.png" alt="Cursor at 0x00404896" /></p>
<p>The cursor is used to select a range of bytes or simply to point to a byte. You can use the cursor to create a named flag at specific location. To do so, seek to the required position, then press <code>f</code> and enter a name for a flag.
If the file was opened in write mode using the <code>-w</code> flag or the <code>o+</code> command, you can also use the cursor to overwrite a selected range with new values. To do so, select a range of bytes (with HJKL and SHIFT key pressed), then press <code>i</code> and enter the hexpair values for the new data. The data will be repeated as needed to fill the range selected. For example:</p>
<pre><code>&lt;select 10 bytes in visual mode using SHIFT+HJKL&gt;
&lt;press 'i' and then enter '12 34'&gt;
</code></pre>
<p>The 10 bytes you have selected will be changed to &quot;12 34 12 34 12 ...&quot;.</p>
<p>The Visual Assembler is a feature that provides a live-preview while you type in new instructions to patch
into the disassembly. To use it, seek or place the cursor at the wanted location and hit the 'A' key. To provide multiple instructions, separate them with semicolons, <code>;</code>.</p>
<h2 id="xref"><a class="header" href="#xref">XREF</a></h2>
<p>When rizin has discovered a XREF during the analysis, it will show you the information in the Visual Disassembly using <code>XREF</code> tag:</p>
<pre><code>; DATA XREF from 0x00402e0e (unk)
str.David_MacKenzie:
</code></pre>
<p>To see where this string is called, press <code>x</code>, if you want to jump to the location where the data is used then press the corresponding number [0-9] on your keyboard. (This functionality is similar to <code>axt</code>)</p>
<p><code>X</code> corresponds to the reverse operation aka <code>axf</code>.</p>
<h2 id="function-argument-display"><a class="header" href="#function-argument-display">Function Argument display</a></h2>
<p>To enable this view use this config var <code>e dbg.funcarg=true</code></p>
<p><img src="visual_mode/funcarg.png" alt="funcarg" /></p>
<h2 id="add-a-comment"><a class="header" href="#add-a-comment">Add a comment</a></h2>
<p>To add a comment press <code>;</code>.</p>
<h2 id="type-other-commands"><a class="header" href="#type-other-commands">Type other commands</a></h2>
<p>Quickly type commands using <code>:</code>.</p>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<p><code>/</code>: allows highlighting of strings in the current display.
<code>:cmd</code> allows you to use one of the &quot;/?&quot; commands that perform more specialized searches.</p>
<h2 id="the-huds"><a class="header" href="#the-huds">The HUDS</a></h2>
<h3 id="the-userfriendly-hud"><a class="header" href="#the-userfriendly-hud">The &quot;UserFriendly HUD&quot;</a></h3>
<p>The &quot;UserFriendly HUD&quot; can be accessed using the <code>??</code> key-combination. This HUD acts as an interactive Cheat Sheet that one can use to more easily find and execute commands. This HUD is particularly useful for new-comers. For experienced users, the other HUDS which are more activity-specific may be more useful.</p>
<h3 id="the-flagcommentfunctions-hud"><a class="header" href="#the-flagcommentfunctions-hud">The &quot;flag/comment/functions/.. HUD&quot;</a></h3>
<p>This HUD can be displayed using the <code>_</code> key, it shows a list of all the flags defined and lets you jump to them. Using the keyboard you can quickly filter the list down to a flag that contains a specific pattern.</p>
<p>Hud input mode can be closed using ^C. It will also exit when backspace is pressed when the user input string is empty.</p>
<h2 id="tweaking-the-disassembly"><a class="header" href="#tweaking-the-disassembly">Tweaking the Disassembly</a></h2>
<p>The disassembly's look-and-feel is controlled using the &quot;asm.* configuration keys, which can be
changed using the <code>e</code> command. All configuration keys can also be edited through the Visual Configuration Editor.</p>
<h2 id="visual-configuration-editor"><a class="header" href="#visual-configuration-editor">Visual Configuration Editor</a></h2>
<p>This HUD can be accessed using the <code>e</code> key in visual mode. The editor allows you to easily examine and change rizin's configuration. For example, if you want to change something about the disassembly display, select <code>asm</code> from the list, navigate to the item you wish to modify it, then select it by hitting <code>Enter</code>.
If the item is a boolean variable, it will toggle, otherwise you will be prompted to provide a new value.</p>
<p><img src="visual_mode/select_asm.png" alt="First Select asm" /></p>
<p>Example switch to pseudo disassembly:</p>
<p><img src="visual_mode/pseudo_disable.png" alt="Pseudo disassembly disabled" /></p>
<p><img src="visual_mode/pseudo_enable.png" alt="Pseudo disassembly enabled" /></p>
<p>Following are some example of eval variable related to disassembly.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h4 id="asmarch-change-architecture--asmbits-word-size-in-bits-at-assembler"><a class="header" href="#asmarch-change-architecture--asmbits-word-size-in-bits-at-assembler">asm.arch: Change Architecture &amp;&amp; asm.bits: Word size in bits at assembler</a></h4>
<p>You can view the list of all arch using <code>e asm.arch=?</code></p>
<pre><code>e asm.arch=dalvik
0x00404870      31ed4989       cmp-long v237, v73, v137
0x00404874      d15e4889       rsub-int v14, v5, 0x8948
0x00404878      e24883e4       ushr-int/lit8 v72, v131, 0xe4
0x0040487c      f0505449c7c0   +invoke-object-init-range {}, method+18772 ;[0]
0x00404882      90244100       add-int v36, v65, v0
</code></pre>
<pre><code>e asm.bits=16
0000:4870      31ed           xor bp, bp
0000:4872      49             dec cx
0000:4873      89d1           mov cx, dx
0000:4875      5e             pop si
0000:4876      48             dec ax
0000:4877      89e2           mov dx, sp
</code></pre>
<p>This latest operation can also be done using <code>&amp;</code> in Visual mode.</p>
<h4 id="asmpseudo-enable-pseudo-syntax"><a class="header" href="#asmpseudo-enable-pseudo-syntax">asm.pseudo: Enable pseudo syntax</a></h4>
<pre><code>e asm.pseudo=true
0x00404870      31ed           ebp = 0
0x00404872      4989d1         r9 = rdx
0x00404875      5e             pop rsi
0x00404876      4889e2         rdx = rsp
0x00404879      4883e4f0       rsp &amp;= 0xfffffffffffffff0
</code></pre>
<h4 id="asmsyntax-select-assembly-syntax-intel-att-masm"><a class="header" href="#asmsyntax-select-assembly-syntax-intel-att-masm">asm.syntax: Select assembly syntax (intel, att, masm...)</a></h4>
<pre><code>e asm.syntax=att
0x00404870      31ed           xor %ebp, %ebp
0x00404872      4989d1         mov %rdx, %r9
0x00404875      5e             pop %rsi
0x00404876      4889e2         mov %rsp, %rdx
0x00404879      4883e4f0       and $0xfffffffffffffff0, %rsp
</code></pre>
<h4 id="asmdescribe-show-opcode-description"><a class="header" href="#asmdescribe-show-opcode-description">asm.describe: Show opcode description</a></h4>
<pre><code>e asm.describe=true
0x00404870  xor ebp, ebp   ; logical exclusive or
0x00404872  mov r9, rdx    ; moves data from src to dst
0x00404875  pop rsi        ; pops last element of stack and stores the result in argument
0x00404876  mov rdx, rsp   ; moves data from src to dst
0x00404879  and rsp, -0xf  ; binary and operation between src and dst, stores result on dst
</code></pre>
<h1 id="visual-assembler"><a class="header" href="#visual-assembler">Visual Assembler</a></h1>
<p>You can use Visual Mode to assemble code (patch) using <code>A</code>.
For example, let's <code>xor</code> the EAX register instead of EBP register, here.
To assemble, seek to the location you want to patch and press <code>A</code>.</p>
<p><img src="visual_mode/../pics/before.png" alt="Before" /></p>
<p>Notice the preview of the disassembly and arrows. After assembling the instruction,
you can see that the branch reference lines have been changed, and it is now pointing to 
the offset of the newly assembled <code>jne</code> instruction:</p>
<p><img src="visual_mode/../pics/after.png" alt="After" /></p>
<p>You need to open the file in writing mode (<code>rizin -w</code> or <code>oo+</code>) in order to patch the file.
You can also use the cache mode: <code>e io.cache=true</code> and <code>wc?</code>.</p>
<p>Remember that patching files in debug mode only patches the memory, not the file.</p>
<h1 id="visual-configuration-editor-1"><a class="header" href="#visual-configuration-editor-1">Visual Configuration Editor</a></h1>
<p><code>Ve</code> or <code>e</code> in visual mode allows you to edit rizin configuration visually.
For example, if you want to change the assembly display just select <code>asm</code> in the list and choose your assembly display flavor.</p>
<p><img src="visual_mode/select_asm.png" alt="First Select asm" /></p>
<p>Example switch to pseudo disassembly:</p>
<p><img src="visual_mode/pseudo_disable.png" alt="Pseudo disassembly disabled" /></p>
<p><img src="visual_mode/pseudo_enable.png" alt="Pseudo disassembly enabled" /></p>
<h1 id="visual-panels"><a class="header" href="#visual-panels">Visual Panels</a></h1>
<h2 id="concept"><a class="header" href="#concept">Concept</a></h2>
<p>Visual Panels is characterized by the following core functionalities:</p>
<ol>
<li>Split Screen</li>
<li>Display multiple screens such as Symbols, Registers, Stack, as well as custom panels</li>
<li>Menu will cover all those commonly used commands for you so that you don't have to memorize any of them</li>
</ol>
<p>CUI met some useful GUI as the menu, that is Visual Panels.</p>
<p>Panels can be accessed by using <code>v</code> or by using <code>!</code> from the visual mode.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><img src="visual_mode/panels_overview.png" alt="Panels Overview" /></p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<pre><code>|Visual Ascii Art Panels:
| |      split the current panel vertically
| -      split the current panel horizontally
| :      run rizin command in prompt
| ;      add/remove comment
| _      start the hud input mode
| \      show the user-friendly hud
| ?      show this help
| .      seek to PC or entrypoint
| *      show decompiler in the current panel
| &quot;      create a panel from the list and replace the current one
| /      highlight the keyword
| (      toggle snow
| &amp;      toggle cache
| [1-9]  follow jmp/call identified by shortcut (like ;[1])
| ' '    (space) toggle graph / panels
| tab    go to the next panel
| Enter  start Zoom mode
| a      toggle auto update for decompiler
| b      browse symbols, flags, configurations, classes, ...
| c      toggle cursor
| C      toggle color
| d      define in the current address. Same as Vd
| D      show disassembly in the current panel
| e      change title and command of current panel
| f      set/add filter keywords
| F      remove all the filters
| g      go/seek to given offset
| G      go/seek to highlight
| i      insert hex
| hjkl   move around (left-down-up-right)
| HJKL   move around (left-down-up-right) by page
| m      select the menu panel
| M      open new custom frame
| n/N    seek next/prev function/flag/hit (scr.nkey)
| p/P    rotate panel layout
| q      quit, or close a tab
| Q      close all the tabs and quit
| r      toggle callhints/jmphints/leahints
| R      randomize color palette (ecr)
| s/S    step in / step over
| t/T    tab prompt / close a tab
| u/U    undo / redo seek
| w      start Window mode
| V      go to the graph mode
| xX     show xrefs/refs of current function from/to data/code
| z      swap current panel with the first one
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Use <code>tab</code> to move around the panels until you get to the targeted panel. Then, use <code>hjkl</code>, just like in vim, to scroll the panel you are currently on.
Use <code>S</code> and <code>s</code> to step over/in, and all the panels should be updated dynamically while you are debugging.
Either in the Registers or Stack panels, you can edit the values by inserting hex. This will be explained later.
While hitting <code>tab</code> can help you moving between panels, it is highly recommended to use <code>m</code> to open the menu.
As usual, you can use <code>hjkl</code> to move around the menu and will find tons of useful stuff there.
You can also press <code>&quot;</code> to quickly browse through the different options View offers and change the contents of the selected panel.</p>
<h2 id="split-screen"><a class="header" href="#split-screen">Split Screen</a></h2>
<p><code>|</code> is for the vertical and <code>-</code> is for the horizontal split. You can delete any panel by pressing <code>X</code>.</p>
<p>Split panels can be resized from Window Mode, which is accessed with <code>w</code>.</p>
<h2 id="window-mode-commands"><a class="header" href="#window-mode-commands">Window Mode Commands</a></h2>
<pre><code>|Panels Window mode help:
| ?      show this help
| ??     show the user-friendly hud
| Enter  start Zoom mode
| c      toggle cursor
| hjkl   move around (left-down-up-right)
| JK     resize panels vertically
| HL     resize panels horizontally
| q      quit Window mode
</code></pre>
<h2 id="edit-values"><a class="header" href="#edit-values">Edit Values</a></h2>
<p>Either in the Register or Stack panel, you can edit the values. Use <code>c</code> to activate cursor mode and you can move the cursor by pressing <code>hjkl</code>, as usual. Then, hit <code>i</code>, just like the insert mode of vim, to insert a value.</p>
<h2 id="tabs"><a class="header" href="#tabs">Tabs</a></h2>
<p>Visual Panels also offer tabs to quickly access multiple forms of information easily. Press <code>t</code> to enter Tab Mode. All the tabs numbers will be visible in the top right corner.</p>
<p>By default you will have one tab and you can press <code>t</code> to create a new tab with the same panels and <code>T</code> to create a new panel from scratch.</p>
<p>For traversing through the tabs, you can type in the tab number while in Tab Mode.</p>
<p>And pressing <code>-</code> deletes the tab you are in.</p>
<h2 id="saving-layouts"><a class="header" href="#saving-layouts">Saving layouts</a></h2>
<p>You can save your custom layout of your visual panels either by picking the option 'Save Layout' from the File menu of the menu bar or by running:</p>
<pre><code>v= test
</code></pre>
<p>Where <code>test</code> is the name with which you'd like to save it.</p>
<p>You can open a saved layout by passing the name as the parameter to <code>v</code>:</p>
<pre><code>v test
</code></pre>
<p>More about that can be found under <code>v?</code>.</p>
<h1 id="searching-for-bytes"><a class="header" href="#searching-for-bytes">Searching for Bytes</a></h1>
<p>The rizin search engine is based on work done by esteve, plus multiple features implemented on top of it. It supports multiple keyword searches, binary masks, and hexadecimal values. It automatically creates flags for search hit locations ease future referencing.</p>
<p>Search is initiated by <code>/</code> command.</p>
<pre><code>[0x00000000]&gt; /?
|Usage: /[!bf] [arg]Search stuff (see 'el search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00               search for string 'foo\0'
| /j foo\x00              search for string 'foo\0' (json output)
| /! ff                   search for first occurrence not matching, command modifier
| /!x 00                  inverse hexa search (find first byte != 0x00)
| /+ /bin/sh              construct the string with chunks
| //                      repeat last search
| /a jmp eax              assemble opcode and search its bytes
| /A jmp                  find analyzed instructions of this type (/A? for help)
| /b                      search backwards, command modifier, followed by other command
| /B                      search recognized RzBin headers
| /c jmp [esp]            search for asm code matching the given string
| /ce rsp,rbp             search for esil expressions matching
| /C[ar]                  search for crypto materials
| /d 101112               search for a deltified sequence of bytes
| /e /E.F/i               match regular expression
| /E esil-expr            offset matching given esil expressions %%= here
| /f                      search forwards, command modifier, followed by other command
| /F file [off] [sz]      search contents of file with offset and size
| /g[g] [from]            find all graph paths A to B (/gg follow jumps, see search.count and
analysis.depth)
| /h[t] [hash] [len]      find block matching this hash. See ph
| /i foo                  search for string 'foo' ignoring case
| /m magicfile            search for matching magic file (use blocksize)
| /o [n]                  show offset of n instructions backward
| /O [n]                  same as /o, but with a different fallback if analysis cannot be used
| /p patternsize          search for pattern of given size
| /P patternsize          search similar blocks
| /r[erwx][?] sym.printf  analyze opcode reference an offset (/re for esil)
| /R [grepopcode]         search for matching ROP gadgets, semicolon-separated
| /s                      search for all syscalls in a region (EXPERIMENTAL)
| /v[1248] value          look for an `cfg.bigendian` 32bit value
| /V[1248] min max        look for an `cfg.bigendian` 32bit value in range
| /w foo                  search for wide string 'f\0o\0o\0'
| /wi foo                 search for wide string ignoring case 'f\0o\0o\0'
| /x ff..33               search for hex string ignoring some nibbles
| /x ff0033               search for hex string
| /x ff43:ffd0            search for hexpair with mask
| /z min max              search for strings of given size
</code></pre>
<p>Because everything is treated as a file in rizin, it does not matter whether you search in a socket, a remote device, in process memory, or a file.</p>
<p>note that '/<em>' starts multiline comment. It's not for searching. type '</em>/' to end comment.</p>
<h2 id="basic-search"><a class="header" href="#basic-search">Basic Search</a></h2>
<p>A basic search for a plain text string in a file would be something like:</p>
<pre><code>$ rizin -q -c &quot;/ lib&quot; /bin/ls
Searching 3 bytes from 0x00400000 to 0x0041ae08: 6c 69 62 
hits: 9
0x00400239 hit0_0 &quot;lib64/ld-linux-x86-64.so.2&quot;
0x00400f19 hit0_1 &quot;libselinux.so.1&quot;
0x00400fae hit0_2 &quot;librt.so.1&quot;
0x00400fc7 hit0_3 &quot;libacl.so.1&quot;
0x00401004 hit0_4 &quot;libc.so.6&quot;
0x004013ce hit0_5 &quot;libc_start_main&quot;
0x00416542 hit0_6 &quot;libs/&quot;
0x00417160 hit0_7 &quot;lib/xstrtol.c&quot;
0x00417578 hit0_8 &quot;lib&quot;
</code></pre>
<p>As can be seen from the output above, rizin generates a &quot;hit&quot; flag for every entry found. You can then use the <code>ps</code> command to see the strings stored at the offsets marked by the flags in this group, and they will have names of the form <code>hit0_&lt;index&gt;</code>:</p>
<pre><code>[0x00404888]&gt; / ls
...
[0x00404888]&gt; ps @ hit0_0
lseek
</code></pre>
<p>You can search for wide-char strings (e.g., unicode letters) using the <code>/w</code> command:</p>
<pre><code>[0x00000000]&gt; /w Hello
0 results found.
</code></pre>
<p>Using Rizin, you can also automatically search for magic signatures in the file. This can be done using <code>/m</code>. The offset and the file format will be displayed after the search.</p>
<pre><code>[0x00000000]&gt; /m
-- 0 b1606
0x00000000 1 JPEG image , EXIF standard
0x0000000c 1 TIFF image data, big-endian
0x000b1510 1 7-zip archive data, version 0.3
</code></pre>
<p>To perform a case-insensitive search for strings use <code>/i</code>:</p>
<pre><code>[0x0040488f]&gt; /i Stallman
Searching 8 bytes from 0x00400238 to 0x0040488f: 53 74 61 6c 6c 6d 61 6e
[# ]hits: 004138 &lt; 0x0040488f  hits = 0
</code></pre>
<p>It is possible to specify hexadecimal escape sequences in the search string by prepending them with &quot;\x&quot;:</p>
<pre><code>[0x00000000]&gt; / \x7FELF
</code></pre>
<p>if, instead, you are searching for a string of hexadecimal values, you're probably better of using the <code>/x</code> command:</p>
<pre><code>[0x00000000]&gt; /x 7F454C46
</code></pre>
<p>Once the search is done, the results are stored in the <code>searches</code> flag space.</p>
<pre><code>[0x00000000]&gt; fs
0    0 . strings
1    0 . symbols
2    6 . searches

[0x00000000]&gt; f
0x00000135 512 hit0_0
0x00000b71 512 hit0_1
0x00000bad 512 hit0_2
0x00000bdd 512 hit0_3
0x00000bfb 512 hit0_4
0x00000f2a 512 hit0_5
</code></pre>
<p>To remove &quot;hit&quot; flags after you do not need them anymore, use the <code>f- hit*</code> command.</p>
<p>Often, during long search sessions, you will need to launch the latest search more than once. You can use the <code>//</code> command to repeat the last search.</p>
<pre><code>[0x00000f2a]&gt; //     ; repeat last search
</code></pre>
<h2 id="configuring-search-options"><a class="header" href="#configuring-search-options">Configuring Search Options</a></h2>
<p>The rizin search engine can be configured through several configuration variables, modifiable with the <code>e</code> command.</p>
<pre><code>e cmd.hit=x         ; rizin command to execute on every search hit
e search.distance=0 ; search string distance
e search.in=foo     ; specify search boundarie. Supported values are listed under e search.in=??
e search.align=4    ; only show search results aligned by specified boundary.
e search.from=0     ; start address
e search.to=0       ; end address
e search.asmstr=0   ; search for string instead of assembly
e search.flags=true ; if enabled, create flags on hits
</code></pre>
<p>The <code>search.align</code> variable is used to limit valid search hits to certain alignment. For example, with <code>e search.align=4</code> you will see only hits found at 4-bytes aligned offsets.</p>
<p>The <code>search.flags</code> boolean variable instructs the search engine to flag hits so that they can be referenced later. If a currently running search is interrupted with <code>Ctrl-C</code> keyboard sequence, current search position is flagged with <code>search_stop</code>.</p>
<h2 id="pattern-matching-search"><a class="header" href="#pattern-matching-search">Pattern Matching Search</a></h2>
<p>The <code>/p</code> command allows you to apply repeated pattern searches on IO backend storage. It is possible to identify repeated byte sequences without explicitly specifying them. The only command's parameter sets minimum detectable pattern length.
Here is an example:</p>
<pre><code>[0x00000000]&gt; /p 10
</code></pre>
<p>This command output will show different patterns found and how many times each of them is encountered.</p>
<h2 id="search-automation"><a class="header" href="#search-automation">Search Automation</a></h2>
<p>The <code>cmd.hit</code> configuration variable is used to define a rizin command to be executed when a matching entry is found by the search engine. If you want to run several commands, separate them with <code>;</code>. Alternatively, you can arrange them in a separate script, and then invoke it as a whole with <code>. script-file-name</code> command.
For example:</p>
<pre><code>[0x00404888]&gt; e cmd.hit=&quot;p8 8&quot;
[0x00404888]&gt; / lib
Searching 3 bytes from 0x00400000 to 0x0041ae08: 6c 69 62
hits: 9
0x00400239 hit4_0 &quot;lib64/ld-linux-x86-64.so.2&quot;
31ed4989d15e4889
0x00400f19 hit4_1 &quot;libselinux.so.1&quot;
31ed4989d15e4889
0x00400fae hit4_2 &quot;librt.so.1&quot;
31ed4989d15e4889
0x00400fc7 hit4_3 &quot;libacl.so.1&quot;
31ed4989d15e4889
0x00401004 hit4_4 &quot;libc.so.6&quot;
31ed4989d15e4889
0x004013ce hit4_5 &quot;libc_start_main&quot;
31ed4989d15e4889
0x00416542 hit4_6 &quot;libs/&quot;
31ed4989d15e4889
0x00417160 hit4_7 &quot;lib/xstrtol.c&quot;
31ed4989d15e4889
0x00417578 hit4_8 &quot;lib&quot;
31ed4989d15e4889
</code></pre>
<h2 id="searching-backwards"><a class="header" href="#searching-backwards">Searching Backwards</a></h2>
<p>Sometimes you want to find a keyword backwards. This is, before the current offset, to do this you can seek back and search forward by adding some search.from/to restrictions, or use the <code>/b</code> command.</p>
<pre><code>[0x100001200]&gt; / nop
0x100004b15 hit0_0 .STUWabcdefghiklmnopqrstuvwxbin/ls.
0x100004f50 hit0_1 .STUWabcdefghiklmnopqrstuwx1] [file .
[0x100001200]&gt; /b nop
[0x100001200]&gt; s 0x100004f50p
[0x100004f50]&gt; /b nop
0x100004b15 hit2_0 .STUWabcdefghiklmnopqrstuvwxbin/ls.
[0x100004f50]&gt;
</code></pre>
<p>Note that <code>/b</code> is doing the same as <code>/</code>, but backward, so what if we want to use <code>/x</code> backward? We can use <code>/bx</code>, and the same goes for other search subcommands:</p>
<pre><code>[0x100001200]&gt; /x 90
0x100001a23 hit1_0 90
0x10000248f hit1_1 90
0x1000027b2 hit1_2 90
0x100002b2e hit1_3 90
0x1000032b8 hit1_4 90
0x100003454 hit1_5 90
0x100003468 hit1_6 90
0x10000355b hit1_7 90
0x100003647 hit1_8 90
0x1000037ac hit1_9 90
0x10000389c hit1_10 90
0x100003c5c hit1_11 90

[0x100001200]&gt; /bx 90
[0x100001200]&gt; s 0x10000355b
[0x10000355b]&gt; /bx 90
0x100003468 hit3_0 90
0x100003454 hit3_1 90
0x1000032b8 hit3_2 90
0x100002b2e hit3_3 90
0x1000027b2 hit3_4 90
0x10000248f hit3_5 90
0x100001a23 hit3_6 90
[0x10000355b]&gt;
</code></pre>
<h2 id="assembler-search"><a class="header" href="#assembler-search">Assembler Search</a></h2>
<p>If you want to search for a certain assembler opcodes, you can use <code>/a</code> commands.</p>
<p>The command <code>/ad/ jmp [esp]</code> searches for the specified category of assembly mnemonic:</p>
<pre><code>[0x00404888]&gt; /ad/ jmp qword [rdx]
f hit_0 @ 0x0040e50d   # 2: jmp qword [rdx]
f hit_1 @ 0x00418dbb   # 2: jmp qword [rdx]
f hit_2 @ 0x00418fcb   # 3: jmp qword [rdx]
f hit_3 @ 0x004196ab   # 6: jmp qword [rdx]
f hit_4 @ 0x00419bf3   # 3: jmp qword [rdx]
f hit_5 @ 0x00419c1b   # 3: jmp qword [rdx]
f hit_6 @ 0x00419c43   # 3: jmp qword [rdx]
</code></pre>
<p>The command <code>/a jmp eax</code> assembles a string to machine code, and then searches for the resulting bytes:</p>
<pre><code>[0x00404888]&gt; /a jmp eax
hits: 1
0x004048e7 hit3_0 ffe00f1f8000000000b8
</code></pre>
<h2 id="searching-for-aes-keys"><a class="header" href="#searching-for-aes-keys">Searching for AES Keys</a></h2>
<p>Thanks to Victor Muñoz, rizin now has support of the algorithm he developed, capable of finding <strong>expanded AES</strong> keys with <code>/Ca</code> command. It searches from current seek position up to the <code>search.distance</code> limit, or until end of file is reached. You can interrupt current search by pressing <code>Ctrl-C</code>. For example, to look for AES keys in physical memory of your system:</p>
<pre><code>$ sudo rizin /dev/mem
[0x00000000]&gt; /ca
0 AES keys found
</code></pre>
<p>If you are simply looking for plaintext AES keys in your binary, <code>/Ca</code> will not find them, but you might want to search with <code>is~AES</code> instead if the programmer left those hints for you:</p>
<pre><code>[0x00000000]&gt; /Ca
Searching 0 byte in [0x100000-0x1f0000]
hits: 0
Searching 0 byte in [0x196e4-0x1b91c]
hits: 0
Searching 0 byte in [0x194b4-0x196e4]
hits: 0
Searching 0 byte in [0x8000-0x114b4]
hits: 0
[0x00000000]&gt; is~AES
010 0x000096d4 0x000196d4 GLOBAL    OBJ   16 AES_KEY
</code></pre>
<p>Other than that, AES keys might show up in different ways in the binary: encrypted, hidden by another encrypting routine, so there's no absolute way other than understanding the binary being analyzed. For instance, <code>p=e</code> might give some hints if high(er) entropy sections are found trying to cover up a hardcoded secret. As an example on entropy searching, since rizin 3.2.0, there's the possibility to delimit entropy sections for later use like so:</p>
<pre><code>[0x00000000]&gt; b
0x100
[0x00000000]&gt; b 4096
[0x00000000]&gt; /s
0x00100000 - 0x00101000 ~ 5.556094
0x014e2c88 - 0x014e3c88 ~ 0.000000
0x01434374 - 0x01435374 ~ 6.332087
0x01435374 - 0x0144c374 ~ 3.664636
0x0144c374 - 0x0144d374 ~ 1.664368
0x0144d374 - 0x0144f374 ~ 4.229199
0x0144f374 - 0x01451374 ~ 2.000000
(...)
[0x00000000]&gt; /s*
f entropy_section_0 0x00001000 0x00100000
f entropy_section_1 0x00001000 0x014e2c88
f entropy_section_2 0x00001000 0x01434374
f entropy_section_3 0x00017000 0x01435374
f entropy_section_4 0x00001000 0x0144c374
f entropy_section_5 0x00002000 0x0144d374
f entropy_section_6 0x00002000 0x0144f374
</code></pre>
<p>The blocksize is increased to 4096 bytes from the default 100 bytes so that the entropy search <code>/s</code> can work on reasonably sized chunks for entropy analysis. The sections flags can be applied with the dot operator, <code>./s*</code> and then looped through <code>px 32 @@f:entropy*</code>.</p>
<p>Moreover AES keys might be referenced from strings or pointed from the imports, for instance, so the <code>/</code> and other search-related commands can come in handy in this regard.</p>
<h1 id="disassembling"><a class="header" href="#disassembling">Disassembling</a></h1>
<p>Disassembling in rizin is just a way to represent an array of bytes. It is handled as a special print mode within <code>p</code> command.</p>
<p>In the old times, when the rizin core was smaller, the disassembler was handled by an external rsc file. That is, rizin first dumped current block into a file, and then simply called <code>objdump</code> configured to disassemble for Intel, ARM or other supported architectures.</p>
<p>It was a working and unix friendly solution, but it was inefficient as it repeated the same expensive actions over and over, because there were no caches. As a result, scrolling was terribly slow.</p>
<p>So there was a need to create a generic disassembler library to support multiple plugins for different architectures. We can list the current loaded plugins with</p>
<pre><code>$ rz-asm -L
</code></pre>
<p>Or from inside rizin:</p>
<pre><code>&gt; e asm.arch=??
</code></pre>
<p>This was many years before capstone appeared. So rizin was using udis86 and olly disassemblers, many gnu (from binutils).</p>
<p>Nowadays, the disassembler support is one of the basic features of rizin. It now has many options, endianness, including target architecture flavor and disassembler variants, among other things.</p>
<p>To see the disassembly, use the <code>pd</code> command. It accepts a numeric argument to specify how many opcodes of current block you want to see. Most of the commands in rizin consider the current block size as the default limit for data input. If you want to disassemble more bytes, set a new block size using the <code>b</code> command.</p>
<pre><code>[0x00000000]&gt; b 100    ; set block size to 100
[0x00000000]&gt; pd       ; disassemble 100 bytes
[0x00000000]&gt; pd 3     ; disassemble 3 opcodes
[0x00000000]&gt; pD 30    ; disassemble 30 bytes
</code></pre>
<p>You can also pass negative numbers as the numeric argument, if you want to disassemble something that lies before the current offset:</p>
<pre><code>[0x00005bc0]&gt; pd -2
            0x00005bb8      ret
            0x00005bb9      nop dword [rax]
[0x00005bc0]&gt; pd 2
            ;-- entry.fini0:
            0x00005bc0      endbr64
            0x00005bc4      cmp byte [0x000232c8], 0
</code></pre>
<p>The <code>pD</code> command works like <code>pd</code> but accepts the number of input bytes as its argument, instead of the number of opcodes.</p>
<p>You can also get information about the pointer chains using the command <code>pdp</code>. This can be helpful while dealing with ROP chains.</p>
<p>The &quot;pseudo&quot; syntax may be somewhat easier for a human to understand than the default assembler notations. But it can become annoying if you read lots of code. To play with it:</p>
<pre><code>[0x00405e1c]&gt; e asm.pseudo=true
[0x00405e1c]&gt; pd 3
		  ; JMP XREF from 0x00405dfa (fcn.00404531)
		  0x00405e1c    488b9424a80. rdx = [rsp+0x2a8]
		  0x00405e24    64483314252. rdx ^= [fs:0x28]
		  0x00405e2d    4889d8       rax = rbx

[0x00405e1c]&gt; e asm.syntax=intel
[0x00405e1c]&gt; pd 3
		  ; JMP XREF from 0x00405dfa (fcn.00404531)
		  0x00405e1c    488b9424a80. mov rdx, [rsp+0x2a8]
		  0x00405e24    64483314252. xor rdx, [fs:0x28]
		  0x00405e2d    4889d8       mov rax, rbx

[0x00405e1c]&gt; e asm.syntax=att
[0x00405e1c]&gt; pd 3
		  ; JMP XREF from 0x00405dfa (fcn.00404531)
		  0x00405e1c    488b9424a80. mov 0x2a8(%rsp), %rdx
		  0x00405e24    64483314252. xor %fs:0x28, %rdx
		  0x00405e2d    4889d8       mov %rbx, %rax
</code></pre>
<p>And as always, you can print the disassembly in JSON using <code>pdj</code> and get more information about the other associated commands by running <code>pd?</code>.</p>
<h2 id="adding-metadata-to-disassembly"><a class="header" href="#adding-metadata-to-disassembly">Adding Metadata to Disassembly</a></h2>
<p>The typical work involved in reversing binary files makes powerful annotation capabilities essential.
Rizin offers multiple ways to store and retrieve such metadata.</p>
<p>By following common basic UNIX principles, it is easy to write a small utility in a scripting language which uses <code>objdump</code>, <code>otool</code> or any other existing utility to obtain information from a binary and to import it into rizin. For example, take a look at <a href="https://github.com/williballenthin/python-idb">python-idb</a>-based <a href="https://github.com/rizinorg/rizin-extras/blob/master/rz-ida/rz-ida.py"><code>rz-ida.py</code></a> which opens IDB files directly without IDA Pro installed. You can load the resulting file with the <code>.</code> (dot) command into the rizin:</p>
<pre><code>[0x00000000]&gt; . file.rz
</code></pre>
<p>The <code>C</code> command is used to manage comments and data conversions. You can define a range of program's bytes to be interpreted as either code, binary data or string. It is also possible to execute external code at every specified flag location in order to fetch some metadata, such as a comment, from an external file or database.</p>
<p>There are many different metadata manipulation commands, here is the glimpse of all of them:</p>
<pre><code>[0x00404cc0]&gt; C?
| Usage: C[-LCvsdfm*?][*?] [...]   # Metadata management
| C                                              list meta info in human friendly form
| C*                                             list meta info in rizin commands
| C*.                                            list meta info of current offset in rizin commands
| C- [len] [[@]addr]                             delete metadata at given address range
| C.                                             list meta info of current offset in human friendly form
| CC! [@addr]                                    edit comment with $EDITOR
| CC[?] [-] [comment-text] [@addr]               add/remove comment
| CC.[addr]                                      show comment in current address
| CCa[-at]|[at] [text] [@addr]                   add/remove comment at given address
| CCu [comment-text] [@addr]                     add unique comment
| CF[sz] [fcn-sign..] [@addr]                    function signature
| CL[-][*] [file:line] [addr]                    show or add 'code line' information (bininfo)
| CS[-][space]                                   manage meta-spaces to filter comments, etc..
| C[Cthsdmf]                                     list comments/types/hidden/strings/data/magic/formatted in human friendly form
| C[Cthsdmf]*                                    list comments/types/hidden/strings/data/magic/formatted in rizin commands
| Cd[-] [size] [repeat] [@addr]                  hexdump data array (Cd 4 10 == dword [10])
| Cd. [@addr]                                    show size of data at current address
| Cf[?][-] [sz] [0|cnt][fmt] [a0 a1...] [@addr]  format memory (see pf?)
| Ch[-] [size] [@addr]                           hide data
| Cm[-] [sz] [fmt..] [@addr]                     magic parse (see pm?)
| Cs[?] [-] [size] [@addr]                       add string
| Ct[?] [-] [comment-text] [@addr]               add/remove type analysis comment
| Ct.[@addr]                                     show comment at current or specified address
| Cv[bsr][?]                                     add comments to args
| Cz[@addr]                                      add string (see Cs?)
</code></pre>
<p>Simply to add the comment to a particular line/address you can use <code>Ca</code> command:</p>
<pre><code>[0x00000000]&gt; CCa 0x0000002 this guy seems legit
[0x00000000]&gt; pd 2
0x00000000    0000         add [rax], al
;      this guy seems legit
0x00000002    0000         add [rax], al
</code></pre>
<p>The <code>C?</code> family of commands lets you mark a range as one of several kinds of types. Three basic types are: code (disassembly is done using asm.arch), data (an array of data elements) or string. Use the <code>Cs</code> command to define a string, use the <code>Cd</code> command for defining an array of data elements, and use the <code>Cf</code> command to define more complex data structures like structs.</p>
<p>Annotating data types is most easily done in visual mode, using the &quot;d&quot; key, short for &quot;data type change&quot;. First, use the cursor to select a range of bytes (press <code>c</code> key to toggle cursor mode and use HJKL keys to expand selection), then press 'd' to get a menu of possible actions/types. For example, to mark the range as a string, use the 's' option from the menu. You can achieve the same result from the shell using the <code>Cs</code> command:</p>
<pre><code>[0x00000000]&gt; f string_foo @ 0x800
[0x00000000]&gt; Cs 10 @ string_foo
</code></pre>
<p>The <code>Cf</code> command is used to define a memory format string (the same syntax used by the <code>pf</code> command). Here's an example:</p>
<pre><code>[0x7fd9f13ae630]&gt; Cf 16 2xi foo bar
[0x7fd9f13ae630]&gt; pd
;-- rip:
0x7fd9f13ae630 format 2xi foo bar {
0x7fd9f13ae630 [0] {
 foo : 0x7fd9f13ae630 = 0xe8e78948
 bar : 0x7fd9f13ae634 = 14696
}
0x7fd9f13ae638 [1] {
 foo : 0x7fd9f13ae638 = 0x8bc48949
 bar : 0x7fd9f13ae63c = 571928325
}
} 16
0x7fd9f13ae633    e868390000   call 0x7fd9f13b1fa0
0x7fd9f13ae638    4989c4       mov r12, rax
</code></pre>
<p>The <code>[sz]</code> argument to <code>Cf</code> is used to define how many bytes the struct should take up in the disassembly, and is completely independent from the size of the data structure defined by the format string. This may seem confusing, but has several uses. For example, you may want to see the formatted structure displayed in the disassembly, but still have those locations be visible as offsets and with raw bytes. Sometimes, you find large structures, but only identified a few fields, or only interested in specific fields. Then, you can tell rizin to display only those fields, using the format string and using 'skip' fields, and also have the disassembly continue after the entire structure, by giving it full size using the <code>sz</code> argument.</p>
<p>Using <code>Cf</code>, it's easy to define complex structures with simple one-liners. See <code>pf?</code> for more information.
Remember that all these <code>C</code> commands can also be accessed from the visual mode by pressing the <code>d</code> (data conversion) key.
Note that unlike <a href="disassembling/../analysis/types.html"><code>t</code></a> commands <code>Cf</code> doesn't change analysis results. It is only
a visual boon.</p>
<p>Sometimes just adding a single line of comments is not enough, in this case rizin allows you to
create a link for a particular text file. You can use it with <code>CC,</code> command or by pressing <code>,</code> key in
the visual mode. This will open an <code>$EDITOR</code> to create a new file, or if filename does exist, just
will create a link. It will be shown in the disassembly comments:</p>
<pre><code>[0x00003af7 11% 290 /bin/ls]&gt; pd $r @ main+55 # 0x3af7
│0x00003af7  call sym.imp.setlocale        ;[1] ; ,(locale-help.txt) ; char *setlocale(int category, const char *locale)
│0x00003afc  lea rsi, str.usr_share_locale ; 0x179cc ; &quot;/usr/share/locale&quot;
│0x00003b03  lea rdi, [0x000179b2]         ; &quot;coreutils&quot;
│0x00003b0a  call sym.imp.bindtextdomain   ;[2] ; char *bindtextdomain(char *domainname, char *dirname)
</code></pre>
<p>Note <code>,(locale-help.txt)</code> appeared in the comments, if we press <code>,</code> again in the visual mode, it
will open the file. Using this mechanism we can create a long descriptions of some particular places
in disassembly, link datasheets or related articles.</p>
<h1 id="esil"><a class="header" href="#esil">ESIL</a></h1>
<p>ESIL stands for 'Evaluable Strings Intermediate Language'. It aims to describe a <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a>-like representation for every target CPU opcode semantics. ESIL representations can be evaluated (interpreted) in order to emulate individual instructions. Each command of an ESIL expression is separated by a comma. Its virtual machine can be described as this:</p>
<pre><code>   while ((word=haveCommand())) {
     if (word.isOperator()) {
       esilOperators[word](esil);
     } else {
       esil.push (word);
     }
     nextCommand();
   }
</code></pre>
<p>As we can see ESIL uses a stack-based interpreter similar to what is commonly used for calculators. You have two categories of inputs: values and operators. A value simply gets pushed on the stack, an operator then pops values (its arguments if you will) off the stack, performs its operation and pushes its results (if any) back on. We can think of ESIL as a post-fix notation of the operations we want to do.</p>
<p>So let's see an example:</p>
<pre><code>4,esp,-=,ebp,esp,=[4]
</code></pre>
<p>Can you guess what this is? If we take this post-fix notation and transform it back to in-fix we get</p>
<pre><code>esp -= 4
4bytes(dword) [esp] = ebp
</code></pre>
<p>We can see that this corresponds to the x86 instruction <code>push ebp</code>! Isn't that cool?
The aim is to be able to express most of the common operations performed by CPUs, like binary arithmetic operations, memory loads and stores, processing syscalls. This way if we can transform the instructions to ESIL we can see what a program does while it is running even for the most cryptic architectures you definitely don't have a device to debug on for.</p>
<h2 id="using-esil"><a class="header" href="#using-esil">Using ESIL</a></h2>
<p>rizin's visual mode is great to inspect the ESIL evaluations.</p>
<p>There are 3 environment variables that are important for watching what a program does:</p>
<pre><code>[0x00000000]&gt; e emu.str=true
</code></pre>
<p><code>asm.emu</code> tells rizin if you want ESIL information to be displayed. If it is set to true, you will see comments appear to the right of your disassembly that tell you how the contents of registers and memory addresses are changed by the current instruction. For example, if you have an instruction that subtracts a value from a register it tells you what the value was before and what it becomes after. This is super useful so you don't have to sit there yourself and track which value goes where.</p>
<p>One problem with this is that it is a lot of information to take in at once and sometimes you simply don't need it. rizin has a nice compromise for this. That is what the <code>emu.str</code> variable is for (<code>asm.emustr</code> on &lt;= 2.2). Instead of this super verbose output with every register value, this only adds really useful information to the output, e.g., strings that are found at addresses a program uses or whether a jump is likely to be taken or not.</p>
<p>The third important variable is <code>asm.esil</code>. This switches your disassembly to no longer show you the actual disassembled instructions, but instead now shows you corresponding ESIL expressions that describe what the instruction does.
So if you want to take a look at how instructions are expressed in ESIL simply set &quot;asm.esil&quot; to true.</p>
<pre><code>[0x00000000]&gt; e asm.esil=true
</code></pre>
<p>In visual mode you can also toggle this by simply typing <code>O</code>.</p>
<h2 id="esil-commands"><a class="header" href="#esil-commands">ESIL Commands</a></h2>
<ul>
<li>&quot;ae&quot; : Evaluate ESIL expression.</li>
</ul>
<pre><code>[0x00000000]&gt; &quot;ae 1,1,+&quot;
0x2
[0x00000000]&gt;
</code></pre>
<ul>
<li>&quot;aes&quot; : ESIL Step.</li>
</ul>
<pre><code>[0x00000000]&gt; aes
[0x00000000]&gt;10aes
</code></pre>
<ul>
<li>&quot;aeso&quot; : ESIL Step Over.</li>
</ul>
<pre><code>[0x00000000]&gt; aeso
[0x00000000]&gt;10aeso
</code></pre>
<ul>
<li>&quot;aesu&quot; : ESIL Step Until.</li>
</ul>
<pre><code>[0x00001000]&gt; aesu 0x1035
ADDR BREAK
[0x00001019]&gt;
</code></pre>
<ul>
<li>&quot;ar&quot; : Show/modify ESIL registry.</li>
</ul>
<pre><code>[0x00001ec7]&gt; ar r_00 = 0x1035
[0x00001ec7]&gt; ar r_00
0x00001035
[0x00001019]&gt;
</code></pre>
<h3 id="esil-instruction-set"><a class="header" href="#esil-instruction-set">ESIL Instruction Set</a></h3>
<p>Here is the complete instruction set used by the ESIL VM:</p>
<table><thead><tr><th>ESIL Opcode</th><th>Operands</th><th>Name</th><th>Operation</th><th>example</th></tr></thead><tbody>
<tr><td>TRAP</td><td>src</td><td>Trap</td><td>Trap signal</td><td></td></tr>
<tr><td><strong>$</strong></td><td>src</td><td>Syscall</td><td>syscall</td><td></td></tr>
<tr><td><strong>$$</strong></td><td>src</td><td>Instruction address</td><td>Get address of current instruction<br>stack=instruction address</td><td></td></tr>
<tr><td><strong>==</strong></td><td>src,dst</td><td>Compare</td><td>stack = (dst == src) ; <br> update_eflags(dst - src)</td><td></td></tr>
<tr><td><strong>&lt;</strong></td><td>src,dst</td><td>Smaller (signed comparison)</td><td>stack = (dst &lt; src) ; <br> update_eflags(dst - src)</td><td>[0x0000000]&gt; &quot;ae 1,5,&lt;&quot; <br>0x0<br>&gt; &quot;ae 5,5&quot;<br>0x0&quot;</td></tr>
<tr><td><strong>&lt;=</strong></td><td>src,dst</td><td>Smaller or Equal (signed comparison)</td><td>stack = (dst &lt;= src) ; <br> update_eflags(dst - src)</td><td>[0x0000000]&gt; &quot;ae 1,5,&lt;&quot; <br>0x0<br>&gt; &quot;ae 5,5&quot;<br>0x1&quot;</td></tr>
<tr><td><strong>&gt;</strong></td><td>src,dst</td><td>Bigger (signed comparison)</td><td>stack = (dst &gt; src) ; <br> update_eflags(dst - src)</td><td>&gt; &quot;ae 1,5,&gt;&quot;<br>0x1<br>&gt; &quot;ae 5,5,&gt;&quot;<br>0x0</td></tr>
<tr><td><strong>&gt;=</strong></td><td>src,dst</td><td>Bigger or Equal (signed comparison)</td><td>stack = (dst &gt;= src) ; <br> update_eflags(dst - src)</td><td>&gt; &quot;ae 1,5,&gt;=&quot;<br>0x1<br>&gt; &quot;ae 5,5,&gt;=&quot;<br>0x1</td></tr>
<tr><td><strong>&lt;&lt;</strong></td><td>src,dst</td><td>Shift Left</td><td>stack = dst &lt;&lt; src</td><td>&gt; &quot;ae 1,1,&lt;&lt;&quot;<br>0x2<br>&gt; &quot;ae 2,1,&lt;&lt;&quot;<br>0x4</td></tr>
<tr><td><strong>&gt;&gt;</strong></td><td>src,dst</td><td>Shift Right</td><td>stack = dst &gt;&gt; src</td><td>&gt; &quot;ae 1,4,&gt;&gt;&quot;<br>0x2<br>&gt; &quot;ae 2,4,&gt;&gt;&quot;<br>0x1</td></tr>
<tr><td><strong>&lt;&lt;&lt;</strong></td><td>src,dst</td><td>Rotate Left</td><td>stack=dst ROL src</td><td>&gt; &quot;ae 31,1,&lt;&lt;&lt;&quot;<br>0x80000000<br>&gt; &quot;ae 32,1,&lt;&lt;&lt;&quot;<br>0x1</td></tr>
<tr><td><strong>&gt;&gt;&gt;</strong></td><td>src,dst</td><td>Rotate Right</td><td>stack=dst ROR src</td><td>&gt; &quot;ae 1,1,&gt;&gt;&gt;&quot;<br>0x80000000<br>&gt; &quot;ae 32,1,&gt;&gt;&gt;&quot;<br>0x1</td></tr>
<tr><td><strong>&amp;</strong></td><td>src,dst</td><td>AND</td><td>stack = dst &amp; src</td><td>&gt; &quot;ae 1,1,&amp;&quot;<br>0x1<br>&gt; &quot;ae 1,0,&amp;&quot;<br>0x0<br>&gt;  &quot;ae 0,1,&amp;&quot;<br>0x0<br>&gt; &quot;ae 0,0,&amp;&quot;<br>0x0</td></tr>
<tr><td><strong>|</strong></td><td>src,dst</td><td>OR</td><td>stack = dst | src</td><td>&gt; &quot;ae 1,1,|&quot;<br>0x1<br>&gt; &quot;ae 1,0,|&quot;<br>0x1<br>&gt; &quot;ae 0,1,|&quot;<br>0x1<br>&gt; &quot;ae 0,0,|&quot;<br>0x0</td></tr>
<tr><td><strong>^</strong></td><td>src,dst</td><td>XOR</td><td>stack = dst ^src</td><td>&gt; &quot;ae 1,1,^&quot;<br>0x0<br>&gt; &quot;ae 1,0,^&quot;<br>0x1<br>&gt; &quot;ae 0,1,^&quot;<br>0x1<br>&gt; &quot;ae 0,0,^&quot;<br>0x0</td></tr>
<tr><td><strong>+</strong></td><td>src,dst</td><td>ADD</td><td>stack = dst + src</td><td>&gt; &quot;ae 3,4,+&quot;<br>0x7<br>&gt; &quot;ae 5,5,+&quot;<br>0xa</td></tr>
<tr><td><strong>-</strong></td><td>src,dst</td><td>SUB</td><td>stack = dst - src</td><td>&gt; &quot;ae 3,4,-&quot;<br>0x1<br>&gt; &quot;ae 5,5,-&quot;<br>0x0<br>&gt; &quot;ae 4,3,-&quot;<br>0xffffffffffffffff</td></tr>
<tr><td><strong>*</strong></td><td>src,dst</td><td>MUL</td><td>stack = dst * src</td><td>&gt; &quot;ae 3,4,*&quot;<br>0xc<br>&gt; &quot;ae 5,5,*&quot;<br>0x19</td></tr>
<tr><td><strong>/</strong></td><td>src,dst</td><td>DIV</td><td>stack = dst / src</td><td>&gt; &quot;ae 2,4,/&quot;<br>0x2<br>&gt; &quot;ae 5,5,/&quot;<br>0x1<br>&gt; &quot;ae 5,9,/&quot;<br>0x1</td></tr>
<tr><td><strong>%</strong></td><td>src,dst</td><td>MOD</td><td>stack = dst % src</td><td>&gt; &quot;ae 2,4,%&quot;<br>0x0<br>&gt; &quot;ae 5,5,%&quot;<br>0x0<br>&gt; &quot;ae 5,9,%&quot;<br>0x4</td></tr>
<tr><td><strong>~</strong></td><td>bits,src</td><td>SIGNEXT</td><td>stack = src sign extended</td><td>&gt; &quot;ae 8,0x80,~&quot;<br>0xffffffffffffff80</td></tr>
<tr><td><strong>~/</strong></td><td>src,dst</td><td>SIGNED DIV</td><td>stack = dst / src (signed)</td><td>&gt; &quot;ae 2,-4,~/&quot;<br>0xfffffffffffffffe</td></tr>
<tr><td><strong>~%</strong></td><td>src,dst</td><td>SIGNED MOD</td><td>stack = dst % src (signed)</td><td>&gt; &quot;ae 2,-5,~%&quot;<br>0xffffffffffffffff</td></tr>
<tr><td><strong>!</strong></td><td>src</td><td>NEG</td><td>stack = !!!src</td><td>&gt; &quot;ae 1,!&quot;<br>0x0<br>&gt; &quot;ae 4,!&quot;<br>0x0<br>&gt; &quot;ae 0,!&quot;<br>0x1<br></td></tr>
<tr><td><strong>++</strong></td><td>src</td><td>INC</td><td>stack = src++</td><td>&gt; ar r_00=0;ar r_00<br>0x00000000<br>&gt; &quot;ae r_00,++&quot;<br>0x1<br>&gt; ar r_00<br>0x00000000<br>&gt; &quot;ae 1,++&quot;<br>0x2</td></tr>
<tr><td><strong>--</strong></td><td>src</td><td>DEC</td><td>stack = src--</td><td>&gt; ar r_00=5;ar r_00<br>0x00000005<br>&gt; &quot;ae r_00,--&quot;<br>0x4<br>&gt; ar r_00<br>0x00000005<br>&gt; &quot;ae 5,--&quot;<br>0x4</td></tr>
<tr><td><strong>=</strong></td><td>src,reg</td><td>EQU</td><td>reg = src</td><td>&gt; &quot;ae 3,r_00,=&quot;<br>&gt; aer r_00<br>0x00000003<br>&gt; &quot;ae r_00,r_01,=&quot;<br>&gt; aer r_01<br>0x00000003</td></tr>
<tr><td><strong>+=</strong></td><td>src,reg</td><td>ADD eq</td><td>reg = reg + src</td><td>&gt; ar r_01=5;ar r_00=0;ar r_00<br>0x00000000<br>&gt; &quot;ae r_01,r_00,+=&quot;<br>&gt; ar r_00<br>0x00000005<br>&gt; &quot;ae 5,r_00,+=&quot;<br>&gt; ar r_00<br>0x0000000a</td></tr>
<tr><td><strong>-=</strong></td><td>src,reg</td><td>SUB eq</td><td>reg = reg - src</td><td>&gt; &quot;ae r_01,r_00,-=&quot;<br>&gt; ar r_00<br>0x00000004<br>&gt; &quot;ae 3,r_00,-=&quot;<br>&gt; ar r_00<br>0x00000001</td></tr>
<tr><td><strong>*=</strong></td><td>src,reg</td><td>MUL eq</td><td>reg = reg * src</td><td>&gt; ar r_01=3;ar r_00=5;ar r_00<br>0x00000005<br>&gt; &quot;ae r_01,r_00,*=&quot;<br>&gt; ar r_00<br>0x0000000f<br>&gt; &quot;ae 2,r_00,*=&quot;<br>&gt; ar r_00<br>0x0000001e</td></tr>
<tr><td><strong>/=</strong></td><td>src,reg</td><td>DIV eq</td><td>reg = reg / src</td><td>&gt; ar r_01=3;ar r_00=6;ar r_00<br>0x00000006<br>&gt; &quot;ae r_01,r_00,/=&quot;<br>&gt; ar r_00<br>0x00000002<br>&gt; &quot;ae 1,r_00,/=&quot;<br>&gt; ar r_00<br>0x00000002</td></tr>
<tr><td><strong>%=</strong></td><td>src,reg</td><td>MOD eq</td><td>reg = reg % src</td><td>&gt;  ar r_01=3;ar r_00=7;ar r_00<br> 0x00000007<br> &gt; &quot;ae r_01,r_00,%=&quot;<br> &gt; ar r_00<br> 0x00000001<br> &gt;  ar r_00=9;ar r_00<br> 0x00000009<br> &gt; &quot;ae 5,r_00,%=&quot;<br> &gt; ar r_00<br> 0x00000004</td></tr>
<tr><td><strong>&lt;&lt;=</strong></td><td>src,reg</td><td>Shift Left eq</td><td>reg = reg &lt;&lt; src</td><td>&gt; ar r_00=1;ar r_01=1;ar r_01<br>0x00000001<br>&gt; &quot;ae r_00,r_01,&lt;&lt;=&quot;<br>&gt; ar r_01<br>0x00000002<br>&gt; &quot;ae 2,r_01,&lt;&lt;=&quot;<br>&gt; ar r_01<br>0x00000008</td></tr>
<tr><td><strong>&gt;&gt;=</strong></td><td>src,reg</td><td>Shift Right eq</td><td>reg = reg &lt;&lt; src</td><td>&gt; ar r_00=1;ar r_01=8;ar r_01<br>0x00000008<br>&gt; &quot;ae r_00,r_01,&gt;&gt;=&quot;<br>&gt; ar r_01<br>0x00000004<br>&gt; &quot;ae 2,r_01,&gt;&gt;=&quot;<br>&gt; ar r_01<br>0x00000001</td></tr>
<tr><td><strong>&amp;=</strong></td><td>src,reg</td><td>AND eq</td><td>reg = reg &amp; src</td><td>&gt; ar r_00=2;ar r_01=6;ar r_01<br>0x00000006<br>&gt; &quot;ae r_00,r_01,&amp;=&quot;<br>&gt; ar r_01<br>0x00000002<br>&gt; &quot;ae 2,r_01,&amp;=&quot;<br>&gt; ar r_01<br>0x00000002<br>&gt; &quot;ae 1,r_01,&amp;=&quot;<br>&gt; ar r_01<br>0x00000000</td></tr>
<tr><td><strong>|=</strong></td><td>src,reg</td><td>OR eq</td><td>reg = reg | src</td><td>&gt; ar r_00=2;ar r_01=1;ar r_01<br>0x00000001<br>&gt; &quot;ae r_00,r_01,|=&quot;<br>&gt; ar r_01<br>0x00000003<br>&gt; &quot;ae 4,r_01,|=&quot;<br>&gt; ar r_01<br>0x00000007</td></tr>
<tr><td><strong>^=</strong></td><td>src,reg</td><td>XOR eq</td><td>reg = reg ^ src</td><td>&gt; ar r_00=2;ar r_01=0xab;ar r_01<br>0x000000ab<br>&gt; &quot;ae r_00,r_01,^=&quot;<br>&gt; ar r_01<br>0x000000a9<br>&gt; &quot;ae 2,r_01,^=&quot;<br>&gt; ar r_01<br>0x000000ab</td></tr>
<tr><td><strong>++=</strong></td><td>reg</td><td>INC eq</td><td>reg = reg + 1</td><td>&gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; &quot;ae r_00,++=&quot;<br>&gt; ar r_00<br>0x00000005</td></tr>
<tr><td><strong>--=</strong></td><td>reg</td><td>DEC eq</td><td>reg = reg - 1</td><td>&gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; &quot;ae r_00,--=&quot;<br>&gt; ar r_00<br>0x00000003</td></tr>
<tr><td><strong>!=</strong></td><td>reg</td><td>NOT eq</td><td>reg = !reg</td><td>&gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; &quot;ae r_00,!=&quot;<br>&gt; ar r_00<br>0x00000000<br>&gt; &quot;ae r_00,!=&quot;<br>&gt; ar r_00<br>0x00000001</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td><td>----------------------------------------------</td></tr>
<tr><td>=[]<br>=[*]<br>=[1]<br>=[2]<br>=[4]<br>=[8]</td><td>src,dst</td><td>poke</td><td>*dst=src</td><td><br>&gt; &quot;ae 0xdeadbeef,0x10000,=[4],&quot;<br><br>&gt; pxw 4@0x10000<br>0x00010000  0xdeadbeef                                ....<br><br>&gt; &quot;ae 0x0,0x10000,=[4],&quot;<br><br>&gt; pxw 4@0x10000<br>0x00010000  0x00000000</td></tr>
<tr><td>[]<br>[*]<br>[1]<br>[2]<br>[4]<br>[8]</td><td>src</td><td>peek</td><td>stack=*src</td><td><br>&gt; w test@0x10000<br><br>&gt; &quot;ae 0x10000,[4],&quot;<br>0x74736574<br><br>&gt; ar r_00=0x10000<br><br>&gt; &quot;ae r_00,[4],&quot;<br>0x74736574</td></tr>
<tr><td>|=[]<br>|=[1]<br>|=[2]<br>|=[4]<br>|=[8]</td><td>reg</td><td>nombre</td><td>code</td><td>&gt; <br>&gt;</td></tr>
<tr><td>SWAP</td><td></td><td>Swap</td><td>Swap two top elements</td><td>SWAP</td></tr>
<tr><td>PICK</td><td>n</td><td>Pick</td><td>Pick nth element<br> from the top of the stack</td><td>2,PICK</td></tr>
<tr><td>RPICK</td><td>m</td><td>Reverse Pick</td><td>Pick nth element<br> from the base of the stack</td><td>0,RPICK</td></tr>
<tr><td>DUP</td><td></td><td>Duplicate</td><td>Duplicate top element in stack</td><td>DUP</td></tr>
<tr><td>NUM</td><td></td><td>Numeric</td><td>If top element is a reference <br> (register name, label, etc),<br> dereference it and push its real value</td><td>NUM</td></tr>
<tr><td>CLEAR</td><td></td><td>Clear</td><td>Clear stack</td><td>CLEAR</td></tr>
<tr><td>BREAK</td><td></td><td>Break</td><td>Stops ESIL emulation</td><td>BREAK</td></tr>
<tr><td>GOTO</td><td>n</td><td>Goto</td><td>Jumps to Nth ESIL word</td><td>GOTO 5</td></tr>
<tr><td>TODO</td><td></td><td>To Do</td><td>Stops execution<br> (reason: ESIL expression not completed)</td><td>TODO</td></tr>
</tbody></table>
<h3 id="esil-flags"><a class="header" href="#esil-flags">ESIL Flags</a></h3>
<p>ESIL VM has an internal state flags that are read-only and can be used to export those values to the underlying target CPU flags. It is because the ESIL VM always calculates all flag changes, while target CPUs only update flags under certain conditions or at specific instructions.</p>
<p>Internal flags are prefixed with <code>$</code> character.</p>
<pre><code>z      - zero flag, only set if the result of an operation is 0
b      - borrow, this requires to specify from which bit (example: $b4 - checks if borrow from bit 4)
c      - carry, same like above (example: $c7 - checks if carry from bit 7)
o      - overflow
p      - parity
r      - regsize ( asm.bits/8 )
s      - sign
ds     - delay slot state
jt     - jump target
js     - jump target set
[0-9]* - Used to set flags and registers without having any side effects,
         i.e. setting esil_cur, esil_old and esil_lastsz.
         (example: &quot;$0,of,=&quot; to reset the overflow flag)
</code></pre>
<h2 id="syntax-and-commands"><a class="header" href="#syntax-and-commands">Syntax and Commands</a></h2>
<p>A target opcode is translated into a comma separated list of ESIL expressions.</p>
<pre><code>xor eax, eax    -&gt;    0,eax,=,1,zf,=
</code></pre>
<p>Memory access is defined by brackets operation:</p>
<pre><code>mov eax, [0x80480]   -&gt;   0x80480,[],eax,=
</code></pre>
<p>Default operand size is determined by size of operation destination.</p>
<pre><code>movb $0, 0x80480     -&gt;   0,0x80480,=[1]
</code></pre>
<p>The <code>?</code> operator uses the value of its argument to decide whether to evaluate the expression in curly braces.</p>
<ol>
<li>Is the value zero?      -&gt; Skip it.</li>
<li>Is the value non-zero?  -&gt; Evaluate it.</li>
</ol>
<pre><code>cmp eax, 123  -&gt;   123,eax,==,$z,zf,=
jz eax        -&gt;   zf,?{,eax,eip,=,}
</code></pre>
<p>If you want to run several expressions under a conditional, put them in curly braces:</p>
<pre><code>zf,?{,eip,esp,=[],eax,eip,=,$r,esp,-=,}
</code></pre>
<p>Whitespaces, newlines and other chars are ignored. So the first thing when processing a ESIL program is to remove spaces:</p>
<pre><code>esil = r_str_replace (esil, &quot; &quot;, &quot;&quot;, R_TRUE);
</code></pre>
<p>Syscalls need special treatment. They are indicated by '$' at the beginning of an expression. You can pass an optional numeric value to specify a number of syscall. An ESIL emulator must handle syscalls. See (r_esil_syscall).</p>
<h2 id="arguments-order-for-non-associative-operations"><a class="header" href="#arguments-order-for-non-associative-operations">Arguments Order for Non-associative Operations</a></h2>
<p>As discussed on IRC, the current implementation works like this:</p>
<pre><code>a,b,-      b - a
a,b,/=     b /= a
</code></pre>
<p>This approach is more readable, but it is less stack-friendly.</p>
<h3 id="special-instructions"><a class="header" href="#special-instructions">Special Instructions</a></h3>
<p>NOPs are represented as empty strings. As it was said previously, syscalls are marked by '$' command. For example, '0x80,$'. It delegates emulation from the ESIL machine to a callback which implements syscalls for a specific OS/kernel.</p>
<p>Traps are implemented with the <code>TRAP</code> command. They are used to throw exceptions for invalid instructions, division by zero, memory read error, or any other needed by specific architectures.</p>
<h3 id="quick-analysis"><a class="header" href="#quick-analysis">Quick Analysis</a></h3>
<p>Here is a list of some quick checks to retrieve information from an ESIL string. Relevant information will be probably found in the first expression of the list.</p>
<pre><code>indexOf('[')    -&gt; have memory references
indexOf(&quot;=[&quot;)   -&gt; write in memory
indexOf(&quot;pc,=&quot;) -&gt; modifies program counter (branch, jump, call)
indexOf(&quot;sp,=&quot;) -&gt; modifies the stack (what if we found sp+= or sp-=?)
indexOf(&quot;=&quot;)    -&gt; retrieve src and dst
indexOf(&quot;:&quot;)    -&gt; unknown esil, raw opcode ahead
indexOf(&quot;$&quot;)    -&gt; accesses internal esil vm flags ex: $z
indexOf(&quot;$&quot;)    -&gt; syscall ex: 1,$
indexOf(&quot;TRAP&quot;) -&gt; can trap
indexOf('++')   -&gt; has iterator
indexOf('--')   -&gt; count to zero
indexOf(&quot;?{&quot;)   -&gt; conditional
equalsTo(&quot;&quot;)    -&gt; empty string, aka nop (wrong, if we append pc+=x)
</code></pre>
<p>Common operations:</p>
<ul>
<li>Check dstreg</li>
<li>Check srcreg</li>
<li>Get destination</li>
<li>Is jump</li>
<li>Is conditional</li>
<li>Evaluate</li>
<li>Is syscall</li>
</ul>
<h3 id="cpu-flags"><a class="header" href="#cpu-flags">CPU Flags</a></h3>
<p>CPU flags are usually defined as single bit registers in the RReg profile. They are sometimes found under the 'flg' register type.</p>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<p>Properties of the VM variables:</p>
<ol>
<li>
<p>They have no predefined bit width. This way it should be easy to extend them to 128, 256 and 512 bits later, e.g. for MMX, SSE, AVX, Neon SIMD.</p>
</li>
<li>
<p>There can be unbound number of variables. It is done for SSA-form compatibility.</p>
</li>
<li>
<p>Register names have no specific syntax. They are just strings.</p>
</li>
<li>
<p>Numbers can be specified in any base supported by RNum (dec, hex, oct, binary ...).</p>
</li>
<li>
<p>Each ESIL backend should have an associated RReg profile to describe the ESIL register specs.</p>
</li>
</ol>
<h3 id="bit-arrays"><a class="header" href="#bit-arrays">Bit Arrays</a></h3>
<p>What to do with them? What about bit arithmetic if use variables instead of registers?</p>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<ol>
<li>ADD (&quot;+&quot;)</li>
<li>MUL (&quot;*&quot;)</li>
<li>SUB (&quot;-&quot;)</li>
<li>DIV (&quot;/&quot;)</li>
<li>MOD (&quot;%&quot;)</li>
</ol>
<h3 id="bit-arithmetic"><a class="header" href="#bit-arithmetic">Bit Arithmetic</a></h3>
<ol>
<li>AND  &quot;&amp;&quot;</li>
<li>OR   &quot;|&quot;</li>
<li>XOR  &quot;^&quot;</li>
<li>SHL  &quot;&lt;&lt;&quot;</li>
<li>SHR  &quot;&gt;&gt;&quot;</li>
<li>ROL  &quot;&lt;&lt;&lt;&quot;</li>
<li>ROR  &quot;&gt;&gt;&gt;&quot;</li>
<li>NEG  &quot;!&quot;</li>
</ol>
<h3 id="floating-point-unit-support"><a class="header" href="#floating-point-unit-support">Floating Point Unit Support</a></h3>
<p>At the moment of this writing, ESIL does not yet support FPU. But you can implement support for unsupported instructions using rz-pipe. Eventually we will get proper support for multimedia and floating point.</p>
<h3 id="handling-x86-rep-prefix-in-esil"><a class="header" href="#handling-x86-rep-prefix-in-esil">Handling x86 REP Prefix in ESIL</a></h3>
<p>ESIL specifies that the parsing control-flow commands must be uppercase. Bear in mind that some architectures have uppercase register names. The corresponding register profile should take care not to reuse any of the following:</p>
<pre><code>3,SKIP   - skip N instructions. used to make relative forward GOTOs
3,GOTO   - goto instruction 3
LOOP     - alias for 0,GOTO
BREAK    - stop evaluating the expression
STACK    - dump stack contents to screen
CLEAR    - clear stack
</code></pre>
<h4 id="usage-example-1"><a class="header" href="#usage-example-1">Usage Example:</a></h4>
<p>rep cmpsb</p>
<pre><code>cx,!,?{,BREAK,},esi,[1],edi,[1],==,?{,BREAK,},esi,++,edi,++,cx,--,0,GOTO
</code></pre>
<h3 id="unimplementedunhandled-instructions"><a class="header" href="#unimplementedunhandled-instructions">Unimplemented/Unhandled Instructions</a></h3>
<p>Those are expressed with the 'TODO' command. They act as a 'BREAK', but displays a warning message describing that an instruction is not implemented and will not be emulated. For example:</p>
<pre><code>fmulp ST(1), ST(0)      =&gt;      TODO,fmulp ST(1),ST(0)
</code></pre>
<h3 id="esil-disassembly-example"><a class="header" href="#esil-disassembly-example">ESIL Disassembly Example:</a></h3>
<pre><code>[0x1000010f8]&gt; e asm.esil=true
[0x1000010f8]&gt; pd $r @ entry0
0x1000010f8    55           8,rsp,-=,rbp,rsp,=[8]
0x1000010f9    4889e5       rsp,rbp,=
0x1000010fc    4883c768     104,rdi,+=
0x100001100    4883c668     104,rsi,+=
0x100001104    5d           rsp,[8],rbp,=,8,rsp,+=
0x100001105    e950350000   0x465a,rip,= ;[1]
0x10000110a    55           8,rsp,-=,rbp,rsp,=[8]
0x10000110b    4889e5       rsp,rbp,=
0x10000110e    488d4668     rsi,104,+,rax,=
0x100001112    488d7768     rdi,104,+,rsi,=
0x100001116    4889c7       rax,rdi,=
0x100001119    5d           rsp,[8],rbp,=,8,rsp,+=
0x10000111a    e93b350000   0x465a,rip,= ;[1]
0x10000111f    55           8,rsp,-=,rbp,rsp,=[8]
0x100001120    4889e5       rsp,rbp,=
0x100001123    488b4f60     rdi,96,+,[8],rcx,=
0x100001127    4c8b4130     rcx,48,+,[8],r8,=
0x10000112b    488b5660     rsi,96,+,[8],rdx,=
0x10000112f    b801000000   1,eax,=
0x100001134    4c394230     rdx,48,+,[8],r8,==,cz,?=
0x100001138    7f1a         sf,of,!,^,zf,!,&amp;,?{,0x1154,rip,=,} ;[2]
0x10000113a    7d07         of,!,sf,^,?{,0x1143,rip,} ;[3]
0x10000113c    b8ffffffff   0xffffffff,eax,= ;  0xffffffff
0x100001141    eb11         0x1154,rip,= ;[2]
0x100001143    488b4938     rcx,56,+,[8],rcx,=
0x100001147    48394a38     rdx,56,+,[8],rcx,==,cz,?=
</code></pre>
<h3 id="introspection"><a class="header" href="#introspection">Introspection</a></h3>
<p>To ease ESIL parsing we should have a way to express introspection expressions to extract the data that we want. For example, we may want to get the target address of a jump. The parser for ESIL expressions should offer an API to make it possible to extract information by analyzing the expressions easily.</p>
<pre><code>&gt;  ao~esil,opcode
opcode: jmp 0x10000465a
esil: 0x10000465a,rip,=
</code></pre>
<p>We need a way to retrieve the numeric value of 'rip'. This is a very simple example, but there are more complex, like conditional ones. We need expressions to be able to get:</p>
<ul>
<li>opcode type</li>
<li>destination of a jump</li>
<li>condition depends on</li>
<li>all regs modified (write)</li>
<li>all regs accessed (read)</li>
</ul>
<h3 id="api-hooks"><a class="header" href="#api-hooks">API HOOKS</a></h3>
<p>It is important for emulation to be able to setup hooks in the parser, so we can extend it to implement analysis without having to change it again and again. That is, every time an operation is about to be executed, a user hook is called. It can be used for example to determine if <code>RIP</code> is going to change, or if the instruction updates the stack.
Later, we can split that callback into several ones to have an event-based analysis API that may be extended in JavaScript like this:</p>
<pre><code>esil.on('regset', function(){..
esil.on('syscall', function(){esil.regset('rip'
</code></pre>
<p>For the API, see the functions <code>hook_flag_read()</code>, <code>hook_execute()</code> and <code>hook_mem_read()</code>. A callback should return true or 1 if you want to override the action that it takes. For example, to deny memory reads in a region, or voiding memory writes, effectively making it read-only.
Return false or 0 if you want to trace ESIL expression parsing.</p>
<p>Other operations require bindings to external functionalities to work. In this case, <code>rz_ref</code> and <code>rz_io</code>. This must be defined when initializing the ESIL VM.</p>
<ul>
<li>Io Get/Set
<pre><code>Out ax, 44
44,ax,:ou
</code></pre>
</li>
<li>Selectors (cs,ds,gs...)
<pre><code>Mov eax, ds:[ebp+8]
Ebp,8,+,:ds,eax,=
</code></pre>
</li>
</ul>
<h1 id="data-and-code-analysis"><a class="header" href="#data-and-code-analysis">Data and Code Analysis</a></h1>
<p>Rizin has a very rich set of commands and configuration options to perform data and code analysis,
to extract useful information from a binary, like pointers, string references,
basic blocks, opcode data, jump targets, cross-references, and much more.
These operations are handled by the <code>a</code> (analyze) command family:</p>
<pre><code>|Usage: a[abdefFghoprxstc] [...]
| aa[?]              analyze all (fcns + bbs) (aa0 to avoid sub renaming)
| a8 [hexpairs]      analyze bytes
| ab[b] [addr]       analyze block at given address
| abb [len]          analyze N basic blocks in [len] (section.size by default)
| abt [addr]         find paths in the bb function graph from current offset to given address
| ac [cycles]        analyze which op could be executed in [cycles]
| ad[?]              analyze data trampoline (wip)
| ad [from] [to]     analyze data pointers to (from-to)
| ae[?] [expr]       analyze opcode eval expression (see ao)
| af[?]              analyze Functions
| aF                 same as above, but using analysis.depth=1
| ag[?] [options]    draw graphs in various formats
| ah[?]              analysis hints (force opcode size, ...)
| ai [addr]          address information (show perms, stack, heap, ...)
| an [name] [@addr]  show/rename/create whatever flag/function is used at addr
| ao[?] [len]        analyze Opcodes (or emulate it)
| aO[?] [len]        Analyze N instructions in M bytes
| ap                 find prelude for current offset
| ar[?]              like 'dr' but for the esil vm. (registers)
| as[?] [num]        analyze syscall using dbg.reg
| av[?] [.]          show vtables
| ax[?]              manage refs/xrefs (see also afx?)
</code></pre>
<p>In fact, <code>a</code> namespace is one of the biggest in rizin tool and allows to control
very different parts of the analysis:</p>
<ul>
<li>Code flow analysis</li>
<li>Data references analysis</li>
<li>Using loaded symbols</li>
<li>Managing different type of graphs, like CFG and call graph</li>
<li>Manage variables</li>
<li>Manage types</li>
<li>Emulation using ESIL VM</li>
<li>Opcode introspection</li>
<li>Objects information, like virtual tables</li>
</ul>
<h1 id="code-analysis"><a class="header" href="#code-analysis">Code Analysis</a></h1>
<p>Code analysis is a common technique used to extract information from assembly code.</p>
<p>Rizin has different code analysis techniques implemented in the core and available in different commands.</p>
<p>As long as the whole functionalities of rizin are available with the API as well as using commands. This gives you the ability to implement your own analysis loops using any programming language, even with rizin one-liners, shellscripts, or analysis or core native plugins.</p>
<p>The analysis will show up the internal data structures to identify basic blocks, function trees and to extract opcode-level information.</p>
<p>The most common rizin analysis command sequence is <code>aa</code>, which stands for &quot;analyze all&quot;. That all is referring to all symbols and entry-points. If your binary is stripped you will need to use other commands like <code>aaa</code>, <code>aab</code>, <code>aar</code>, <code>aac</code> or so.</p>
<p>Take some time to understand what each command does and the results after running them to find the best one for your needs.</p>
<pre><code>[0x08048440]&gt; aa
[0x08048440]&gt; pdf @ main
		   ; DATA XREF from 0x08048457 (entry0)
/ (fcn) fcn.08048648 141
|     ;-- main:
|     0x08048648    8d4c2404     lea ecx, [esp+0x4]
|     0x0804864c    83e4f0       and esp, 0xfffffff0
|     0x0804864f    ff71fc       push dword [ecx-0x4]
|     0x08048652    55           push ebp
|     ; CODE (CALL) XREF from 0x08048734 (fcn.080486e5)
|     0x08048653    89e5         mov ebp, esp
|     0x08048655    83ec28       sub esp, 0x28
|     0x08048658    894df4       mov [ebp-0xc], ecx
|     0x0804865b    895df8       mov [ebp-0x8], ebx
|     0x0804865e    8975fc       mov [ebp-0x4], esi
|     0x08048661    8b19         mov ebx, [ecx]
|     0x08048663    8b7104       mov esi, [ecx+0x4]
|     0x08048666    c744240c000. mov dword [esp+0xc], 0x0
|     0x0804866e    c7442408010. mov dword [esp+0x8], 0x1 ;  0x00000001
|     0x08048676    c7442404000. mov dword [esp+0x4], 0x0
|     0x0804867e    c7042400000. mov dword [esp], 0x0
|     0x08048685    e852fdffff   call sym..imp.ptrace
|        sym..imp.ptrace(unk, unk)
|     0x0804868a    85c0         test eax, eax
| ,=&lt; 0x0804868c    7911         jns 0x804869f
| |   0x0804868e    c70424cf870. mov dword [esp], str.Don_tuseadebuguer_ ;  0x080487cf
| |   0x08048695    e882fdffff   call sym..imp.puts
| |      sym..imp.puts()
| |   0x0804869a    e80dfdffff   call sym..imp.abort
| |      sym..imp.abort()
| `-&gt; 0x0804869f    83fb02       cmp ebx, 0x2
|,==&lt; 0x080486a2    7411         je 0x80486b5
||    0x080486a4    c704240c880. mov dword [esp], str.Youmustgiveapasswordforusethisprogram_ ;  0x0804880c
||    0x080486ab    e86cfdffff   call sym..imp.puts
||       sym..imp.puts()
||    0x080486b0    e8f7fcffff   call sym..imp.abort
||       sym..imp.abort()
|`--&gt; 0x080486b5    8b4604       mov eax, [esi+0x4]
|     0x080486b8    890424       mov [esp], eax
|     0x080486bb    e8e5feffff   call fcn.080485a5
|        fcn.080485a5() ; fcn.080484c6+223
|     0x080486c0    b800000000   mov eax, 0x0
|     0x080486c5    8b4df4       mov ecx, [ebp-0xc]
|     0x080486c8    8b5df8       mov ebx, [ebp-0x8]
|     0x080486cb    8b75fc       mov esi, [ebp-0x4]
|     0x080486ce    89ec         mov esp, ebp
|     0x080486d0    5d           pop ebp
|     0x080486d1    8d61fc       lea esp, [ecx-0x4]
\     0x080486d4    c3           ret
</code></pre>
<p>In this example, we analyze the whole file (<code>aa</code>) and then print disassembly of the <code>main()</code> function (<code>pdf</code>).
The <code>aa</code> command belongs to the family of auto analysis commands and performs only the most basic
auto analysis steps. In rizin there are many different types of auto analysis commands with a
different analysis depth, including partial emulation: <code>aa</code>, <code>aaa</code>, <code>aab</code>, <code>aaaa</code>, ...
There is also a mapping of those commands to the rizin CLI options: <code>rizin -A</code>, <code>rizin -AA</code>, and so on.</p>
<p>It is common sense that completely automated analysis can produce non sequitur results, thus
rizin provides separate commands for the particular stages of the analysis allowing fine-grained
control of the analysis process. Moreover, there is a treasure trove of configuration variables
for controlling the analysis outcomes. You can find them in <code>analysis.*</code> and <code>emu.*</code>
cfg variables' namespaces.</p>
<h2 id="analyze-functions"><a class="header" href="#analyze-functions">Analyze functions</a></h2>
<p>One of the most important &quot;basic&quot; analysis commands is the set of <code>af</code> subcommands. <code>af</code> means
&quot;analyze function&quot;. Using this command you can either allow automatic analysis of the particular
function or perform a completely manual one.</p>
<pre><code>[0x00000000]&gt; af?
Usage: af
| af ([name]) ([addr])                  analyze functions (start at addr or $$)
| afr ([name]) ([addr])                 analyze functions recursively
| af+ addr name [type] [diff]           hand craft a function (requires afb+)
| af- [addr]                            clean all function analysis data (or function at addr)
| afa                                   analyze function arguments in a call (afal honors dbg.funcarg)
| afb+ fcnA bbA sz [j] [f] ([t]( [d]))  add bb to function @ fcnaddr
| afb[?] [addr]                         List basic blocks of given function
| afbF([0|1])                           Toggle the basic-block 'folded' attribute
| afB 16                                set current function as thumb (change asm.bits)
| afC[lc] ([addr])@[addr]               calculate the Cycles (afC) or Cyclomatic Complexity (afCc)
| afc[?] type @[addr]                   set calling convention for function
| afd[addr]                             show function + delta for given offset
| afF[1|0|]                             fold/unfold/toggle
| afi [addr|fcn.name]                   show function(s) information (verbose afl)
| afj [tableaddr] [count]               analyze function jumptable
| afl[?] [ls*] [fcn name]               list functions (addr, size, bbs, name) (see afll)
| afm name                              merge two functions
| afM name                              print functions map
| afn[?] name [addr]                    rename name for function at address (change flag too)
| afna                                  suggest automatic name for current offset
| afo[?j] [fcn.name]                    show address for the function name or current offset
| afs[!] ([fcnsign])                    get/set function signature at current address (afs! uses cfg.editor)
| afS[stack_size]                       set stack frame size for function at current address
| afsr [function_name] [new_type]       change type for given function
| aft[?]                                type matching, type propagation
| afu addr                              resize and analyze function from current address until addr
| afv[absrx]?                           manipulate args, registers and variables in function
| afx                                   list function references
</code></pre>
<p>You can use <code>afl</code> to list the functions found by the analysis.</p>
<p>There are a lot of useful commands under <code>afl</code> such as <code>aflj</code>, which lists the function in JSON format and <code>aflm</code>, which lists the functions in the syntax found in makefiles.</p>
<p>There's also <code>afl=</code>, which displays ASCII-art bars with function ranges.</p>
<p>You can find the rest of them under <code>afl?</code>.</p>
<p>Some of the most challenging tasks while performing a function analysis are merge, crop, and resize.
As with other analysis commands, you have two modes: semi-automatic and manual.
For the semi-automatic, you can use <code>afm &lt;function name&gt;</code> to merge the current function with
the one specified by name as an argument, <code>aff</code> to readjust the function after analysis changes or function edits,
<code>afu &lt;address&gt;</code> to do the resize and analysis of the current function until the specified address.</p>
<p>Apart from those semi-automatic ways to edit/analyze the function, you can handcraft it in the manual mode with <code>af+</code> command and edit basic blocks of it using <code>afb</code> commands.
Before changing the basic blocks of the function it is recommended to check the already presented ones:</p>
<pre><code>[0x00003ac0]&gt; afb
0x00003ac0 0x00003b7f 01:001A 191 f 0x00003b7f
0x00003b7f 0x00003b84 00:0000 5 j 0x00003b92 f 0x00003b84
0x00003b84 0x00003b8d 00:0000 9 f 0x00003b8d
0x00003b8d 0x00003b92 00:0000 5
0x00003b92 0x00003ba8 01:0030 22 j 0x00003ba8
0x00003ba8 0x00003bf9 00:0000 81
</code></pre>
<h3 id="handcraft-function"><a class="header" href="#handcraft-function">Handcraft function</a></h3>
<p>before starting, let's prepare a binary file first, for example:</p>
<pre><code class="language-C">int code_block()
{
  int result = 0;

  for(int i = 0; i &lt; 10; ++i)
    result += 1;

  return result;
}
</code></pre>
<p>then compile it with <code>gcc -c example.c -m32 -O0 -fno-pie</code>, we will get the object file <code>example.o</code>. open it with rizin.</p>
<p>since we haven't analyzed it yet, the <code>pdf</code> command will not print out the disassembly here:</p>
<pre><code>$ rizin example.o
[0x08000034]&gt; pdf
p: Cannot find function at 0x08000034
[0x08000034]&gt; pd
            ;-- section..text:
            ;-- .text:
            ;-- code_block:
            ;-- eip:
            0x08000034      55             push ebp                    ; [01] -r-x section size 41 named .text
            0x08000035      89e5           mov ebp, esp
            0x08000037      83ec10         sub esp, 0x10
            0x0800003a      c745f8000000.  mov dword [ebp - 8], 0
            0x08000041      c745fc000000.  mov dword [ebp - 4], 0
        ,=&lt; 0x08000048      eb08           jmp 0x8000052
       .--&gt; 0x0800004a      8345f801       add dword [ebp - 8], 1
       :|   0x0800004e      8345fc01       add dword [ebp - 4], 1
       :`-&gt; 0x08000052      837dfc09       cmp dword [ebp - 4], 9
       `==&lt; 0x08000056      7ef2           jle 0x800004a
            0x08000058      8b45f8         mov eax, dword [ebp - 8]
            0x0800005b      c9             leave
            0x0800005c      c3             ret

</code></pre>
<p>our goal is to handcraft a function with the following structure</p>
<p><img src="analysis/analyze_one.png" alt="analyze_one" /></p>
<p>create a function at 0x8000034 named code_block:</p>
<pre><code>[0x8000034]&gt; af+ 0x8000034 code_block
</code></pre>
<p>In most cases, we use jump or call instructions as code block boundaries. so the range of first block is from <code>0x08000034 push ebp</code> to <code>0x08000048 jmp 0x8000052</code>.
use <code>afb+</code> command to add it.</p>
<pre><code>[0x08000034]&gt; afb+ code_block 0x8000034 0x800004a-0x8000034 0x8000052
</code></pre>
<p>note that the basic syntax of <code>afb+</code> is <code>afb+ function_address block_address block_size [jump] [fail]</code>. the final instruction of this block points to a new address(jmp 0x8000052), thus we add the address of jump target (0x8000052) to reflect the jump info.</p>
<p>the next block (0x08000052 ~ 0x08000056) is more likely an if conditional statement which has two branches. It will jump to 0x800004a if <code>jle-less or equal</code>, otherwise (the fail condition) jump to next instruction -- 0x08000058.:</p>
<pre><code>[0x08000034]&gt; afb+ code_block 0x8000052 0x8000058-0x8000052 0x800004a 0x8000058
</code></pre>
<p>follow the control flow and create the remaining two blocks (two branches) :</p>
<pre><code>[0x08000034]&gt; afb+ code_block 0x800004a 0x8000052-0x800004a 0x8000052
[0x08000034]&gt; afb+ code_block 0x8000058 0x800005d-0x8000058
</code></pre>
<p>check our work:</p>
<pre><code>[0x08000034]&gt; afb
0x08000034 0x0800004a 00:0000 22 j 0x08000052
0x0800004a 0x08000052 00:0000 8 j 0x08000052
0x08000052 0x08000058 00:0000 6 j 0x0800004a f 0x08000058
0x08000058 0x0800005d 00:0000 5
[0x08000034]&gt; VV
</code></pre>
<p><img src="analysis/handcraft_one.png" alt="handcraft_one" /></p>
<p>There are two very important commands for this: <code>afc</code> and <code>afB</code>. The latter is a must-know command for some platforms like ARM. It provides a way to change the &quot;bitness&quot; of a particular function by allowing to select between ARM and Thumb modes.</p>
<p><code>afc</code> on the other side, allows to manually specify function calling convention. You can find more information on its usage in <a href="analysis/calling_conventions.html">calling_conventions</a>.</p>
<h2 id="recursive-analysis"><a class="header" href="#recursive-analysis">Recursive analysis</a></h2>
<p>There are 5 important program-wide half-automated analysis commands:</p>
<ul>
<li><code>aab</code> - perform basic-block analysis (&quot;Nucleus&quot; algorithm)</li>
<li><code>aac</code> - analyze function calls from one (selected or current function)</li>
<li><code>aaf</code> - analyze all function calls</li>
<li><code>aar</code> - analyze data references</li>
<li><code>aad</code> - analyze pointers to pointers references</li>
</ul>
<p>Those are only generic semi-automated reference searching algorithms. Rizin provides a
wide choice of manual references' creation of any kind. For this fine-grained control,
you can use <code>ax</code> commands.</p>
<pre><code>Usage: ax[?d-l*]   # see also 'afx?'
| ax              list refs
| ax*             output rizin commands
| ax addr [at]    add code ref pointing to addr (from curseek)
| ax- [at]        clean all refs/refs from addr
| ax-*            clean all refs/refs
| axc addr [at]   add generic code ref
| axC addr [at]   add code call ref
| axg [addr]      show xrefs graph to reach current function
| axg* [addr]     show xrefs graph to given address, use .axg*;aggv
| axgj [addr]     show xrefs graph to reach current function in json format
| axd addr [at]   add data ref
| axq             list refs in quiet/human-readable format
| axj             list refs in json format
| axF [flg-glob]  find data/code references of flags
| axm addr [at]   copy data/code references pointing to addr to also point to curseek (or at)
| axt [addr]      find data/code references to this address
| axf [addr]      find data/code references from this address
| axv [addr]      list local variables read-write-exec references
| ax. [addr]      find data/code references from and to this address
| axff[j] [addr]  find data/code references from this function
| axs addr [at]   add string ref
</code></pre>
<p>The most commonly used <code>ax</code> commands are <code>axt</code> and <code>axf</code>, especially as a part of various rz-pipe
scripts. Let's say we see the string in the data or a code section and want to find all places
it was referenced from, we should use <code>axt</code>:</p>
<pre><code>[0x0001783a]&gt; pd 2
;-- str.02x:
; STRING XREF from 0x00005de0 (sub.strlen_d50)
; CODE XREF from 0x00017838 (str.._s_s_s + 7)
0x0001783a     .string &quot;%%%02x&quot; ; len=7
;-- str.src_ls.c:
; STRING XREF from 0x0000541b (sub.free_b04)
; STRING XREF from 0x0000543a (sub.__assert_fail_41f + 27)
; STRING XREF from 0x00005459 (sub.__assert_fail_41f + 58)
; STRING XREF from 0x00005f9e (sub._setjmp_e30)
; CODE XREF from 0x0001783f (str.02x + 5)
0x00017841 .string &quot;src/ls.c&quot; ; len=9
[0x0001783a]&gt; axt
sub.strlen_d50 0x5de0 [STRING] lea rcx, str.02x
(nofunc) 0x17838 [CODE] jae str.02x
</code></pre>
<p>There are also some useful commands under <code>axt</code>. Use <code>axtg</code> to generate rizin commands which will help you to create graphs according to the XREFs.</p>
<pre><code>[0x08048320]&gt; s main
[0x080483e0]&gt; axtg
agn 0x8048337 &quot;entry0 + 23&quot;
agn 0x80483e0 &quot;main&quot;
age 0x8048337 0x80483e0
</code></pre>
<p>Use <code>axt*</code> to split the rizin commands and set flags on those corresponding XREFs.</p>
<p>Also under <code>ax</code> is <code>axg</code>, which finds the path between two points in the file by showing an XREFs graph to reach the location or function. For example:</p>
<pre><code>:&gt; axg sym.imp.printf
- 0x08048a5c fcn 0x08048a5c sym.imp.printf
  - 0x080483e5 fcn 0x080483e0 main
  - 0x080483e0 fcn 0x080483e0 main
    - 0x08048337 fcn 0x08048320 entry0
  - 0x08048425 fcn 0x080483e0 main
</code></pre>
<p>Use <code>axg*</code> to generate rizin commands which will help you to create graphs using <code>agn</code> and <code>age</code> commands, according to the XREFs.</p>
<p>Apart from predefined algorithms to identify functions there is a way to specify
a function prelude with a configuration option <code>analysis.prelude</code>. For example, like
<code>e analysis.prelude=0x554889e5</code> which means</p>
<pre><code>push rbp
mov rbp, rsp
</code></pre>
<p>on x86_64 platform. It should be specified <em>before</em> any analysis commands.</p>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>Rizin allows changing the behavior of almost any analysis stages or commands.
There are different kinds of configuration options:</p>
<ul>
<li>Flow control</li>
<li>Basic blocks control</li>
<li>References control</li>
<li>IO/Ranges</li>
<li>Jump tables analysis control</li>
<li>Platform/target-specific options</li>
</ul>
<h3 id="control-flow-configuration"><a class="header" href="#control-flow-configuration">Control flow configuration</a></h3>
<p>The two most commonly used options for changing the behavior of control flow analysis in rizin are
<code>analysis.hasnext</code> and <code>analysis.jmp.after</code>. The first one allows forcing rizin to continue the analysis
after the end of the function, even if the next chunk of the code wasn't called anywhere, thus
analyzing all of the available functions. The latter one allows forcing rizin to continue
the analysis even after unconditional jumps.</p>
<p>In addition to those we can also set <code>analysis.jmp.indir</code> to follow the indirect jumps, continuing analysis;
<code>analysis.pushret</code> to analyze <code>push ...; ret</code> sequence as a jump; <code>analysis.nopskip</code> to skip the NOP
sequences at a function beginning.</p>
<p>For now, rizin also allows you to change the maximum basic block size with <code>analysis.bb.maxsize</code> option
. The default value just works in most use cases, but it's useful to increase that for example when
dealing with obfuscated code. Beware that some of the basic block
control options may disappear in the future in favor of more automated ways to set those.</p>
<p>For some unusual binaries or targets, there is an option <code>analysis.noncode</code>. Rizin doesn't try
to analyze data sections as a code by default. But in some cases - malware, packed binaries,
binaries for embedded systems, it is often a case. Thus - this option.</p>
<h3 id="reference-control"><a class="header" href="#reference-control">Reference control</a></h3>
<p>The most crucial options that change the analysis results drastically. Sometimes some can be
disabled to save time and memory when analyzing big binaries.</p>
<ul>
<li><code>analysis.jmp.ref</code> - to allow references creation for unconditional jumps</li>
<li><code>analysis.jmp.cref</code> - same, but for conditional jumps</li>
<li><code>analysis.datarefs</code> - to follow the data references in code</li>
<li><code>analysis.refstr</code> - search for strings in data references</li>
<li><code>analysis.strings</code> - search for strings and creating references</li>
</ul>
<p>Note that strings references control is disabled by default because it increases the analysis time.</p>
<h3 id="analysis-ranges"><a class="header" href="#analysis-ranges">Analysis ranges</a></h3>
<p>There are a few options for this:</p>
<ul>
<li><code>analysis.limits</code> - enables the range limits for analysis operations</li>
<li><code>analysis.from</code> - starting address of the limit range</li>
<li><code>analysis.to</code> - the corresponding end of the limit range</li>
<li><code>analysis.in</code> - specify search boundaries for analysis. You can set it to <code>io.maps</code>, <code>io.sections.exec</code>, <code>dbg.maps</code> and many more. For example:
<ul>
<li>To analyze a specific memory map with <code>analysis.from</code> and <code>analysis.to</code>, set <code>analysis.in = dbg.maps</code>.</li>
<li>To analyze in the boundaries set by <code>analysis.from</code> and <code>analysis.to</code>, set <code>analysis.in=range</code>.</li>
<li>To analyze in the current mapped segment or section, you can put <code>analysis.in=bin.segment</code> or <code>analysis.in=bin.section</code>, respectively.</li>
<li>To analyze in the current memory map, specify <code>analysis.in=dbg.map</code>.</li>
<li>To analyze in the stack or heap, you can set <code>analysis.in=dbg.stack</code> or <code>analysis.in=dbg.heap</code>.</li>
<li>To analyze in the current function or basic block, you can specify <code>analysis.in=analysis.fcn</code> or <code>analysis.in=analysis.bb</code>.</li>
</ul>
</li>
</ul>
<p>Please see <code>e analysis.in=??</code> for the complete list.</p>
<h3 id="jump-tables"><a class="header" href="#jump-tables">Jump tables</a></h3>
<p>Jump tables are one of the trickiest targets in binary reverse engineering. There are hundreds
of different types, the end result depending on the compiler/linker and LTO stages of optimization.
Thus rizin allows enabling some experimental jump tables detection algorithms using <code>analysis.jmp.tbl</code>
option. Eventually, algorithms moved into the default analysis loops once they start to work on
every supported platform/target/test-case.
Two more options can affect the jump tables analysis results too:</p>
<ul>
<li><code>analysis.jmp.indir</code> - follow the indirect jumps, some jump tables rely on them</li>
<li><code>analysis.datarefs</code> - follow the data references, some jump tables use those</li>
</ul>
<h3 id="platform-specific-controls"><a class="header" href="#platform-specific-controls">Platform specific controls</a></h3>
<p>There are two common problems when analyzing embedded targets: ARM/Thumb detection and MIPS GP
value. In the case of ARM binaries rizin supports some auto-detection of ARM/Thumb mode switches, but
beware that it uses partial ESIL emulation, thus slowing the analysis process. If you will not
like the results, particular functions' mode can be overridden with <code>afB</code> command.</p>
<p>The MIPS GP problem is even trickier. It is basic knowledge that GP value can be different not only
for the whole program but also for some functions. To partially solve that there are options
<code>analysis.gp</code> and <code>analysis.gpfixed</code>. The first one sets the GP value for the whole program or particular
function. The latter allows to &quot;constantify&quot; the GP value if some code is willing to change its
value, always resetting it if the case. Those are heavily experimental and might be changed in the
future in favor of more automated analysis.</p>
<h2 id="visuals"><a class="header" href="#visuals">Visuals</a></h2>
<p>One of the easiest way to see and check the changes of the analysis commands and variables
is to perform scrolling in a <code>Vv</code> special visual mode, allowing functions preview:</p>
<p><img src="analysis/code_analysis_vv.png" alt="vv" /></p>
<p>When we want to check how analysis changes affect the result in the case of big functions, we can
use minimap instead, allowing us to see a bigger flow graph on the same screen size. To get into
the minimap mode type <code>VV</code> then press <code>p</code> twice:</p>
<p><img src="analysis/code_analysis_vv2.png" alt="vv2" /></p>
<p>This mode allows you to see the disassembly of each node separately, just navigate between them using the <code>Tab</code> key.</p>
<h2 id="analysis-hints"><a class="header" href="#analysis-hints">Analysis hints</a></h2>
<p>It is not an uncommon case that analysis results are not perfect even after you tried every single
configuration option. This is where the &quot;analysis hints&quot; rizin mechanism comes in. It allows
to override some basic opcode or meta-information properties, or even to rewrite the whole opcode
string. These commands are located under <code>ah</code> namespace:</p>
<pre><code>Usage: ah[lba-]  Analysis Hints
| ah?                show this help
| ah? offset         show hint of given offset
| ah                 list hints in a human-readable format
| ah.                list hints in human-readable format from current offset
| ah-                remove all hints
| ah- offset [size]  remove hints at the given offset
| ah* offset         list hints in rizin commands format
| aha ppc @ 0x42     force arch ppc for all address &gt;= 0x42 or until the next hint
| aha 0 @ 0x84       disable the effect of arch hints for all address &gt;= 0x84 or until the next hint
| ahb 16 @ 0x42      force 16bit for all address &gt;= 0x42 or until the next hint
| ahb 0 @ 0x84       disable the effect of bits hints for all address &gt;= 0x84 or until the next hint
| ahc 0x804804       override call/jump address
| ahd foo a0,33      replace opcode string
| ahe 3,eax,+=       set vm analysis string
| ahf 0x804840       override fallback address for call
| ahF 0x10           set stackframe size at the current offset
| ahh 0x804840       highlight this address offset in disasm
| ahi[?] 10          define numeric base for immediates (2, 8, 10, 10u, 16, i, p, S, s)
| ahj                list hints in JSON
| aho call           change opcode type (see aho?) (deprecated, moved to &quot;ahd&quot;)
| ahp addr           set pointer hint
| ahr val            set hint for the return value of a function
| ahs 4              set opcode size=4
| ahS jz             set asm.syntax=jz for this opcode
| aht [?] &lt;type&gt;     Mark immediate as a type offset (deprecated, moved to &quot;aho&quot;)
| ahv val            change opcode's val field (useful to set jmptbl sizes in jmp rax)
</code></pre>
<p>One of the most common cases is to set a particular numeric base for immediates:</p>
<pre><code>[0x00003d54]&gt; ahi?
Usage: ahi [2|8|10|10u|16|bodhipSs] [@ offset]   Define numeric base
| ahi &lt;base&gt;  set numeric base (2, 8, 10, 16)
| ahi 10|d    set base to signed decimal (10), sign bit should depend on receiver size
| ahi 10u|du  set base to unsigned decimal (11)
| ahi b       set base to binary (2)
| ahi o       set base to octal (8)
| ahi h       set base to hexadecimal (16)
| ahi i       set base to IP address (32)
| ahi p       set base to htons(port) (3)
| ahi S       set base to syscall (80)
| ahi s       set base to string (1)

[0x00003d54]&gt; pd 2
0x00003d54      0583000000     add eax, 0x83
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]&gt; ahi d
[0x00003d54]&gt; pd 2
0x00003d54      0583000000     add eax, 131
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]&gt; ahi b
[0x00003d54]&gt; pd 2
0x00003d54      0583000000     add eax, 10000011b
0x00003d59      3d13010000     cmp eax, 0x113
</code></pre>
<p>It is notable that some analysis stages or commands add the internal analysis hints,
which can be checked with <code>ah</code> command:</p>
<pre><code>[0x00003d54]&gt; ah
 0x00003d54 - 0x00003d54 =&gt; immbase=2
[0x00003d54]&gt; ah*
 ahi 2 @ 0x3d54
</code></pre>
<p>Sometimes we need to override jump or call address, for example in case of tricky
relocation, which is unknown for rizin, thus we can change the value manually.
The current analysis information about a particular opcode can be checked with <code>ao</code> command.
We can use <code>ahc</code> command for performing such a change:</p>
<pre><code>[0x00003cee]&gt; pd 2
0x00003cee      e83d080100     call sub.__errno_location_530
0x00003cf3      85c0           test eax, eax
[0x00003cee]&gt; ao
address: 0x3cee
opcode: call 0x14530
mnemonic: call
prefix: 0
id: 56
bytes: e83d080100
refptr: 0
size: 5
sign: false
type: call
cycles: 3
esil: 83248,rip,8,rsp,-=,rsp,=[],rip,=
jump: 0x00014530
direction: exec
fail: 0x00003cf3
stack: null
family: cpu
stackop: null
[0x00003cee]&gt; ahc 0x5382
[0x00003cee]&gt; pd 2
0x00003cee      e83d080100     call sub.__errno_location_530
0x00003cf3      85c0           test eax, eax
[0x00003cee]&gt; ao
address: 0x3cee
opcode: call 0x14530
mnemonic: call
prefix: 0
id: 56
bytes: e83d080100
refptr: 0
size: 5
sign: false
type: call
cycles: 3
esil: 83248,rip,8,rsp,-=,rsp,=[],rip,=
jump: 0x00005382
direction: exec
fail: 0x00003cf3
stack: null
family: cpu
stackop: null
[0x00003cee]&gt; ah
 0x00003cee - 0x00003cee =&gt; jump: 0x5382
</code></pre>
<p>As you can see, despite the unchanged disassembly view the jump address in opcode was changed
(<code>jump</code> option).</p>
<p>If anything of the previously described didn't help, you can simply override shown disassembly with anything you
like:</p>
<pre><code>[0x00003d54]&gt; pd 2
0x00003d54      0583000000     add eax, 10000011b
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]&gt; &quot;ahd myopcode bla, foo&quot;
[0x00003d54]&gt; pd 2
0x00003d54                     myopcode bla, foo
0x00003d55      830000         add dword [rax], 0
</code></pre>
<h1 id="managing-variables"><a class="header" href="#managing-variables">Managing variables</a></h1>
<p>Rizin allows managing local variables, no matter their location, stack or registers.
The variables' auto analysis is enabled by default but can be disabled with <code>analysis.vars</code>
configuration option.</p>
<p>The main variables commands are located in <code>afv</code> namespace:</p>
<pre><code>Usage: afv  [rbs]
| afv*                          output rizin command to add args/locals to flagspace
| afv-([name])                  remove all or given var
| afv=                          list function variables and arguments with disasm refs
| afva                          analyze function arguments/locals
| afvb[?]                       manipulate bp based arguments/locals
| afvd name                     output rizin command for displaying the value of args/locals in the debugger
| afvf                          show BP relative stackframe variables
| afvn [new_name] ([old_name])  rename argument/local
| afvr[?]                       manipulate register based arguments
| afvR [varname]                list addresses where vars are accessed (READ)
| afvs[?]                       manipulate sp based arguments/locals
| afvt [name] [new_type]        change type for given argument/local
| afvW [varname]                list addresses where vars are accessed (WRITE)
| afvx                          show function variable xrefs (same as afvR+afvW)
</code></pre>
<p><code>afvr</code>, <code>afvb</code> and <code>afvs</code> commands are uniform but allow manipulation of
register-based arguments and variables, BP/FP-based arguments and variables,
and SP-based arguments and variables respectively.
If we check the help for <code>afvr</code> we will get the way two others commands works too:</p>
<pre><code>|Usage: afvr [reg] [type] [name]
| afvr                        list register based arguments
| afvr*                       same as afvr but in rizin commands
| afvr [reg] [name] ([type])  define register arguments
| afvrj                       return list of register arguments in JSON format
| afvr- [name]                delete register arguments at the given index
| afvrg [reg] [addr]          define argument get reference
| afvrs [reg] [addr]          define argument set reference
</code></pre>
<p>Like many other things variables detection is performed by rizin automatically, but results
can be changed with those arguments/variables control commands. This kind of analysis
relies heavily on preloaded function prototypes and the calling-convention, thus loading symbols
can improve it. Moreover, after changing something we can rerun variables analysis with
<code>afva</code> command. Quite often variables analysis is accompanied with
<a href="analysis/types.html">types analysis</a>, see <code>afta</code> command.</p>
<p>The most important aspect of reverse engineering - naming things. Of course, you can rename
a variable too, affecting all places it was referenced. This can be achieved with <code>afvn</code> for
<em>any</em> type of argument or variable. Or you can simply remove the variable or argument with
<code>afv-</code> command.</p>
<p>As mentioned before the analysis loop relies heavily on types information while performing
variables analysis stages. Thus comes next very important command - <code>afvt</code>, which
allows you to change the type of variable:</p>
<pre><code>[0x00003b92]&gt; afvs
var int local_8h @ rsp+0x8
var int local_10h @ rsp+0x10
var int local_28h @ rsp+0x28
var int local_30h @ rsp+0x30
var int local_32h @ rsp+0x32
var int local_38h @ rsp+0x38
var int local_45h @ rsp+0x45
var int local_46h @ rsp+0x46
var int local_47h @ rsp+0x47
var int local_48h @ rsp+0x48
[0x00003b92]&gt; afvt local_10h char*
[0x00003b92]&gt; afvs
var int local_8h @ rsp+0x8
var char* local_10h @ rsp+0x10
var int local_28h @ rsp+0x28
var int local_30h @ rsp+0x30
var int local_32h @ rsp+0x32
var int local_38h @ rsp+0x38
var int local_45h @ rsp+0x45
var int local_46h @ rsp+0x46
var int local_47h @ rsp+0x47
var int local_48h @ rsp+0x48
</code></pre>
<p>Less commonly used feature, which is still under heavy development - distinction between
variables being read and written. You can list those being read with <code>afvR</code> command and those
being written with <code>afvW</code> command. Both commands provide a list of the places those operations
are performed:</p>
<pre><code>[0x00003b92]&gt; afvR
local_48h  0x48ee
local_30h  0x3c93,0x520b,0x52ea,0x532c,0x5400,0x3cfb
local_10h  0x4b53,0x5225,0x53bd,0x50cc
local_8h  0x4d40,0x4d99,0x5221,0x53b9,0x50c8,0x4620
local_28h  0x503a,0x51d8,0x51fa,0x52d3,0x531b
local_38h
local_45h  0x50a1
local_47h
local_46h
local_32h  0x3cb1
[0x00003b92]&gt; afvW
local_48h  0x3adf
local_30h  0x3d3e,0x4868,0x5030
local_10h  0x3d0e,0x5035
local_8h  0x3d13,0x4d39,0x5025
local_28h  0x4d00,0x52dc,0x53af,0x5060,0x507a,0x508b
local_38h  0x486d
local_45h  0x5014,0x5068
local_47h  0x501b
local_46h  0x5083
local_32h
[0x00003b92]&gt;
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h2>
<p>The type inference for local variables and arguments is well integrated with the command <code>afta</code>.</p>
<p>Let's see an example of this with a simple <a href="https://github.com/rizinorg/rizinbook/tree/master/examples/hello_world">hello_world</a> binary</p>
<pre><code>[0x000007aa]&gt; pdf
|           ;-- main:
/ (fcn) sym.main 157
| sym.main ();
| ; var int local_20h @ rbp-0x20
| ; var int local_1ch @ rbp-0x1c
| ; var int local_18h @ rbp-0x18
| ; var int local_10h @ rbp-0x10
| ; var int local_8h @ rbp-0x8
| ; DATA XREF from entry0 (0x6bd)
| 0x000007aa  push rbp
| 0x000007ab  mov rbp, rsp
| 0x000007ae  sub rsp, 0x20
| 0x000007b2  lea rax, str.Hello          ; 0x8d4 ; &quot;Hello&quot;
| 0x000007b9  mov qword [local_18h], rax
| 0x000007bd  lea rax, str.r2_folks       ; 0x8da ; &quot; r2-folks&quot;
| 0x000007c4  mov qword [local_10h], rax
| 0x000007c8  mov rax, qword [local_18h]
| 0x000007cc  mov rdi, rax
| 0x000007cf  call sym.imp.strlen         ; size_t strlen(const char *s)
</code></pre>
<ul>
<li>After applying <code>afta</code></li>
</ul>
<pre><code>[0x000007aa]&gt; afta
[0x000007aa]&gt; pdf
| ;-- main:
| ;-- rip:
/ (fcn) sym.main 157
| sym.main ();
| ; var size_t local_20h @ rbp-0x20
| ; var size_t size @ rbp-0x1c
| ; var char *src @ rbp-0x18
| ; var char *s2 @ rbp-0x10
| ; var char *dest @ rbp-0x8
| ; DATA XREF from entry0 (0x6bd)
| 0x000007aa  push rbp
| 0x000007ab  mov rbp, rsp
| 0x000007ae  sub rsp, 0x20
| 0x000007b2  lea rax, str.Hello          ; 0x8d4 ; &quot;Hello&quot;
| 0x000007b9  mov qword [src], rax
| 0x000007bd  lea rax, str.r2_folks       ; 0x8da ; &quot; r2-folks&quot;
| 0x000007c4  mov qword [s2], rax
| 0x000007c8  mov rax, qword [src]
| 0x000007cc  mov rdi, rax                ; const char *s
| 0x000007cf  call sym.imp.strlen         ; size_t strlen(const char *s)
</code></pre>
<p>It also extracts type information from format strings like <code>printf (&quot;fmt : %s , %u , %d&quot;, ...)</code>, the format specifications are extracted from <code>analysis/d/spec.sdb</code></p>
<p>You could create a new profile for specifying a set of format chars depending on different libraries/operating systems/programming languages like this :</p>
<pre><code>win=spec
spec.win.u32=unsigned int
</code></pre>
<p>Then change your default specification to a newly created one using this config variable <code>e analysis.spec=win</code></p>
<p>For more information about primitive and user-defined types support in rizin refer to <a href="analysis/types.html">types</a> chapter.</p>
<h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Rizin supports the C-syntax data types description.
Those types are parsed by a C11-compatible parser and stored in
the internal SDB, thus are introspectable with <code>k</code> command.</p>
<p>Most of the related commands are located in <code>t</code> namespace:</p>
<pre><code>[0x000051c0]&gt; t?
| Usage: t   # cparse types commands
| t                          List all loaded types
| tj                         List all loaded types as json
| t &lt;type&gt;                   Show type in 'pf' syntax
| t*                         List types info in rizin commands
| t- &lt;name&gt;                  Delete types by its name
| t-*                        Remove all types
| tail [filename]            Output the last part of files
| tc [type.name]             List all/given types in C output format
| te[?]                      List all loaded enums
| td[?] &lt;string&gt;             Load types from string
| tf                         List all loaded functions signatures
| tk &lt;sdb-query&gt;             Perform sdb query
| tl[?]                      Show/Link type to an address
| tn[?] [-][addr]            manage noreturn function attributes and marks
| to -                       Open cfg.editor to load types
| to &lt;path&gt;                  Load types from C header file
| toe [type.name]            Open cfg.editor to edit types
| tos &lt;path&gt;                 Load types from parsed Sdb database
| tp  &lt;type&gt; [addr|varname]  cast data at &lt;address&gt; to &lt;type&gt; and print it (XXX: type can contain spaces)
| tpv &lt;type&gt; @ [value]       Show offset formatted for given type
| tpx &lt;type&gt; &lt;hexpairs&gt;      Show value for type with specified byte sequence (XXX: type can contain spaces)
| ts[?]                      Print loaded struct types
| tu[?]                      Print loaded union types
| tx[f?]                     Type xrefs
| tt[?]                      List all loaded typedefs
</code></pre>
<p>Note that the basic (atomic) types are not those from the C standard -
not <code>char</code>, <code>_Bool</code>, or <code>short</code>. Because those types can be different
from one platform to another, rizin uses <code>definite</code> types like as
<code>int8_t</code> or <code>uint64_t</code> and will convert <code>int</code> to <code>int32_t</code> or <code>int64_t</code>
depending on the binary or debuggee platform/compiler.</p>
<p>Basic types can be listed using <code>t</code> command, for the structured types
you need to use <code>ts</code>, <code>tu</code> or <code>te</code> for enums:</p>
<pre><code>[0x000051c0]&gt; t
char
char *
int
int16_t
int32_t
int64_t
int8_t
long
long long
...
</code></pre>
<h3 id="loading-types"><a class="header" href="#loading-types">Loading types</a></h3>
<p>There are three easy ways to define a new type:</p>
<ul>
<li>Directly from the string using <code>td</code> command</li>
<li>From the file using <code>to &lt;filename&gt;</code> command</li>
<li>Open  an <code>$EDITOR</code> to type the definitions in place using <code>to -</code></li>
</ul>
<pre><code>[0x000051c0]&gt; &quot;td struct foo {char* a; int b;}&quot;
[0x000051c0]&gt; cat ~/rizin-regressions/bins/headers/s3.h
struct S1 {
    int x[3];
    int y[4];
    int z;
};
[0x000051c0]&gt; to ~/rizin-regressions/bins/headers/s3.h
[0x000051c0]&gt; ts
foo
S1
</code></pre>
<p>Also, note there is a config option to specify include directories for types parsing</p>
<pre><code>[0x00000000]&gt; el~dir.type
dir.types: Default path to look for cparse type files
[0x00000000]&gt; e dir.types
/usr/include
</code></pre>
<h3 id="printing-types"><a class="header" href="#printing-types">Printing types</a></h3>
<p>Notice below we have used <code>ts</code> command, which basically converts
the C type description (or to be precise it's SDB representation)
into the sequence of <code>pf</code> commands. See more about <a href="analysis/../basic_commands/print_modes.html">print format</a>.</p>
<p>The <code>tp</code> command uses the <code>pf</code> string to print all the members of type at the current offset/given address:</p>
<pre><code>[0x000051c0]&gt; ts foo
pf zd a b
[0x000051c0]&gt; tp foo
 a : 0x000051c0 = 'hello'
 b : 0x000051cc = 10
[0x000051c0]&gt; tp foo 0x000053c0
 a : 0x000053c0 = 'world'
 b : 0x000053cc = 20
</code></pre>
<p>Also, you could fill your own data into the struct and print it using <code>tpx</code> command</p>
<pre><code>[0x000051c0]&gt; tpx foo 4141414144141414141442001000000
 a : 0x000051c0 = AAAAD.....B
 b : 0x000051cc = 16
</code></pre>
<h3 id="linking-types"><a class="header" href="#linking-types">Linking Types</a></h3>
<p>The <code>tp</code> command just performs a temporary cast. But if we want to link some address or variable
with the chosen type, we can use <code>tl</code> command to store the relationship in SDB.</p>
<pre><code>[0x000051c0]&gt; tl S1 = 0x51cf
[0x000051c0]&gt; tll
(S1)
 x : 0x000051cf = [ 2315619660, 1207959810, 34803085 ]
 y : 0x000051db = [ 2370306049, 4293315645, 3860201471, 4093649307 ]
 z : 0x000051eb = 4464399
</code></pre>
<p>Moreover, the link will be shown in the disassembly output or visual mode:</p>
<pre><code>[0x000051c0 15% 300 /bin/ls]&gt; pd $r @ entry0
 ;-- entry0:
 0x000051c0      xor ebp, ebp
 0x000051c2      mov r9, rdx
 0x000051c5      pop rsi
 0x000051c6      mov rdx, rsp
 0x000051c9      and rsp, 0xfffffffffffffff0
 0x000051cd      push rax
 0x000051ce      push rsp
(S1)
 x : 0x000051cf = [ 2315619660, 1207959810, 34803085 ]
 y : 0x000051db = [ 2370306049, 4293315645, 3860201471, 4093649307 ]
 z : 0x000051eb = 4464399
 0x000051f0      lea rdi, loc._edata         ; 0x21f248
 0x000051f7      push rbp
 0x000051f8      lea rax, loc._edata         ; 0x21f248
 0x000051ff      cmp rax, rdi
 0x00005202      mov rbp, rsp
</code></pre>
<p>Once the struct is linked, rizin tries to propagate structure offset in the function at the current offset, to run this analysis on the whole program or at any targeted functions after all structs are linked you have <code>aat</code> command:</p>
<pre><code>[0x00000000]&gt; aa?
| aat [fcn]           Analyze all functions or a given function to convert immediate to linked structure offsets (see tl?)
</code></pre>
<p>Note sometimes the emulation may not be accurate, for example as below :</p>
<pre><code>|0x000006da  push rbp
|0x000006db  mov rbp, rsp
|0x000006de  sub rsp, 0x10
|0x000006e2  mov edi, 0x20               ; &quot;@&quot;
|0x000006e7  call sym.imp.malloc         ;  void *malloc(size_t size)
|0x000006ec  mov qword [local_8h], rax
|0x000006f0  mov rax, qword [local_8h]

</code></pre>
<p>The return value of <code>malloc</code> may differ between two emulations, so you have to set the hint for return value manually using <code>ahr</code> command, so run <code>tl</code> or <code>aat</code> command after setting up the return value hint.</p>
<pre><code>[0x000006da]&gt; ah?
| ahr val            set hint for the return value of a function
</code></pre>
<h3 id="structure-immediates"><a class="header" href="#structure-immediates">Structure Immediates</a></h3>
<p>There is one more important aspect of using types in rizin - using <code>aht</code> you
can change the immediate in the opcode to the structure offset.
Let's see a simple example of [R]SI-relative addressing</p>
<pre><code>[0x000052f0]&gt; pd 1
0x000052f0      mov rax, qword [rsi + 8]    ; [0x8:8]=0
</code></pre>
<p>Here <code>8</code> - is some offset in the memory, where <code>rsi</code> probably holds
some structure pointer. Imagine that we have the following structures</p>
<pre><code>
[0x000052f0]&gt; &quot;td struct ms { char b[8]; int member1; int member2; };&quot;
[0x000052f0]&gt; &quot;td struct ms1 { uint64_t a; int member1; };&quot;
[0x000052f0]&gt; &quot;td struct ms2 { uint16_t a; int64_t b; int member1; };&quot;
</code></pre>
<p>Now we need to set the proper structure member offset instead of <code>8</code> in this instruction.
At first, we need to list available types matching this offset:</p>
<pre><code>[0x000052f0]&gt; ahts 8
ms.member1
ms1.member1
</code></pre>
<p>Note, that <code>ms2</code> is not listed, because it has no members with offset <code>8</code>.
After listing available options we can link it to the chosen offset at
the current address:</p>
<pre><code>[0x000052f0]&gt; aht ms1.member1
[0x000052f0]&gt; pd 1
0x000052f0      488b4608       mov rax, qword [rsi + ms1.member1]    ; [0x8:8]=0
</code></pre>
<h3 id="managing-enums"><a class="header" href="#managing-enums">Managing enums</a></h3>
<ul>
<li>Printing all fields in enum using <code>te</code> command</li>
</ul>
<pre><code>[0x00000000]&gt; &quot;td enum Foo {COW=1,BAR=2};&quot;
[0x00000000]&gt; te Foo
COW = 0x1
BAR = 0x2
</code></pre>
<ul>
<li>Finding matching enum member for given bitfield and vice-versa</li>
</ul>
<pre><code>[0x00000000]&gt; te Foo 0x1
COW
[0x00000000]&gt; teb Foo COW
0x1
</code></pre>
<h2 id="internal-representation"><a class="header" href="#internal-representation">Internal representation</a></h2>
<p>To see the internal representation of the types you can use <code>tk</code> command:</p>
<pre><code>[0x000051c0]&gt; tk~S1
S1=struct
struct.S1=x,y,z
struct.S1.x=int32_t,0,3
struct.S1.x.meta=4
struct.S1.y=int32_t,12,4
struct.S1.y.meta=4
struct.S1.z=int32_t,28,0
struct.S1.z.meta=0
[0x000051c0]&gt;
</code></pre>
<p>Defining primitive types requires an understanding of basic <code>pf</code> formats,
you can find the whole list of format specifier in <code>pf??</code>:</p>
<pre><code>---------------------------------------------------
| format | explanation                            |
| ------ | -------------------------------------- |
| b      | byte (unsigned)                        |
| c      | char (signed byte)                     |
| d      | 0x%%08x hexadecimal value (4 bytes)    |
| f      | float value (4 bytes)                  |
| i      | %%i integer value (4 bytes)            |
| o      | 0x%%08o octal value (4 byte)           |
| p      | pointer reference (2, 4 or 8 bytes)    |
| q      | quadword (8 bytes)                     |
| s      | 32bit pointer to string (4 bytes)      |
| S      | 64bit pointer to string (8 bytes)      |
| t      | UNIX timestamp (4 bytes)               |
| T      | show Ten first bytes of buffer         |
| u      | uleb128 (variable length)              |
| w      | word (2 bytes unsigned short in hex)   |
| x      | 0x%%08x hex value and flag (fd @ addr) |
| X      | show formatted hexpairs                |
| z      | \0 terminated string                   |
| Z      | \0 terminated wide string              |
---------------------------------------------------

</code></pre>
<p>there are basically 3 mandatory keys for defining basic data types:
<code>X=type</code>
<code>type.X=format_specifier</code>
<code>type.X.size=size_in_bits</code>
For example, let's define <code>UNIT</code>, according to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx#UINT">Microsoft documentation</a>
<code>UINT</code> is just equivalent of standard C <code>unsigned int</code> (or <code>uint32_t</code> in terms of TCC engine).
It will be defined as:</p>
<pre><code>UINT=type
type.UINT=d
type.UINT.size=32
</code></pre>
<p>Now there is an optional entry:</p>
<p><code>X.type.pointto=Y</code></p>
<p>This one may only be used in case of pointer <code>type.X=p</code>, one good example is LPFILETIME definition,
it is a pointer to <code>_FILETIME</code> which happens to be a structure.
Assuming that we are targeting only 32-bit windows machine, it will be defined as the following:</p>
<pre><code>LPFILETIME=type
type.LPFILETIME=p
type.LPFILETIME.size=32
type.LPFILETIME.pointto=_FILETIME
</code></pre>
<p>This last field is not mandatory because sometimes the data structure
internals will be proprietary, and we will not have a clean representation for it.</p>
<p>There is also one more optional entry:</p>
<pre><code>type.UINT.meta=4
</code></pre>
<p>This entry is for integration with C parser and carries the type class information:
integer size, signed/unsigned, etc.</p>
<h3 id="structures"><a class="header" href="#structures">Structures</a></h3>
<p>Those are the basic keys for structs (with just two elements):</p>
<pre><code>X=struct
struct.X=a,b
struct.X.a=a_type,a_offset,a_number_of_elements
struct.X.b=b_type,b_offset,b_number_of_elements
</code></pre>
<p>The first line is used to define a structure called <code>X</code>, the second line
defines the elements of <code>X</code> as comma-separated values. After that, we just define each element info.</p>
<p>For example. we can have a struct like this one:</p>
<pre><code>struct _FILETIME {
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
}
</code></pre>
<p>assuming we have <code>DWORD</code> defined, the struct will look like this</p>
<pre><code> _FILETIME=struct
struct._FILETIME=dwLowDateTime,dwHighDateTime
struct._FILETIME.dwLowDateTime=DWORD,0,0
struct._FILETIME.dwHighDateTime=DWORD,4,0
</code></pre>
<p>Note that the number of elements field is used in the case of arrays only
to identify how many elements are in arrays, other than that it is zero by default.</p>
<h3 id="unions"><a class="header" href="#unions">Unions</a></h3>
<p>Unions are defined exactly like structs the only difference is that you will replace the word <code>struct</code> with the word <code>union</code>.</p>
<h3 id="function-prototypes"><a class="header" href="#function-prototypes">Function prototypes</a></h3>
<p>Function prototype representation is the most detail-oriented and the most important one of them all. This is the one used directly for type matching</p>
<pre><code>X=func
func.X.args=NumberOfArgs
func.x.arg0=Arg_type,arg_name
.
.
.
func.X.ret=Return_type
func.X.cc=calling_convention
</code></pre>
<p>It should be self-explanatory. Let's do strncasecmp as an example for x86 arch for Linux machines. According to man pages, strncasecmp is defined as the following:</p>
<pre><code>int strcasecmp(const char *s1, const char *s2, size_t n);
</code></pre>
<p>When converting it into its sdb representation it will look like the following:</p>
<pre><code>strcasecmp=func
func.strcasecmp.args=3
func.strcasecmp.arg0=char *,s1
func.strcasecmp.arg1=char *,s2
func.strcasecmp.arg2=size_t,n
func.strcasecmp.ret=int
func.strcasecmp.cc=cdecl
</code></pre>
<p>Note that the <code>.cc</code> part is optional and if it didn't exist the default calling-convention for your target architecture will be used instead.
There is one extra optional key</p>
<pre><code>func.x.noreturn=true/false
</code></pre>
<p>This key is used to mark functions that will not return once called, such as <code>exit</code> and <code>_exit</code>.</p>
<h1 id="calling-conventions"><a class="header" href="#calling-conventions">Calling Conventions</a></h1>
<p>Rizin uses calling conventions to help in identifying function formal arguments and return types.
It is used also as a guide for basic function prototype and type propagation.</p>
<pre><code>[0x00000000]&gt; afc?
Usage: afc[agl?]
| afc convention  Manually set calling convention for current function
| afc             Show Calling convention for the Current function
| afcr[j]         Show register usage for the current function
| afca            Analyse function for finding the current calling convention
| afcf[j] [name]  Prints return type function(arg1, arg2...), see afij
| afck            List SDB details of call loaded calling conventions
| afcl            List all available calling conventions
| afco path       Open Calling Convention sdb profile from the given path
| afcR            Register telescoping using the calling conventions order
[0x00000000]&gt;
</code></pre>
<p>To list all available calling conventions for current architecture using <code>afcl</code> command</p>
<pre><code>[0x00000000]&gt; afcl
swift
amd64
amd64syscall
ms
reg
</code></pre>
<p>The default calling convention for a particular architecture/binary is defined with
<code>analysis.cc</code> for user-mode calls and <code>analysis.syscc</code> for syscalls.</p>
<p>To display a function prototype of standard library functions you have the <code>afcf</code> command</p>
<pre><code>[0x00000000]&gt; afcf printf
int printf(const char *format)
[0x00000000]&gt; afcf fgets
char *fgets(char *s, int size, FILE *stream)
</code></pre>
<p>All this information is loaded via sdb under <code>/librz/analysis/d/cc-[arch]-[bits].sdb</code></p>
<pre><code>default.cc=amd64

ms=cc
cc.ms.name=ms
cc.ms.arg1=rcx
cc.ms.arg2=rdx
cc.ms.arg3=r8
cc.ms.arg3=r9
cc.ms.argn=stack
cc.ms.ret=rax
</code></pre>
<p><code>cc.x.argi=rax</code> is used to set the ith argument of this calling convention to register name <code>rax</code></p>
<p><code>cc.x.argn=stack</code> means that all the arguments (or the rest of them in case there was <code>argi</code> for any <code>i</code> as counting number) will be stored in the stack from left to right</p>
<p><code>cc.x.argn=stack_rev</code> same as <code>cc.x.argn=stack</code> except for it means argument are passed right to left</p>
<h1 id="virtual-tables"><a class="header" href="#virtual-tables">Virtual Tables</a></h1>
<p>There is basic support of virtual tables parsing (RTTI and others).
The most important thing before you start to perform such kind of analysis
is to check if the <code>analysis.cpp.abi</code> option is set correctly and change it if needed.</p>
<p>All commands to work with virtual tables are located in the <code>av</code> namespace.
Currently, the support is very basic, allowing you only to inspect
parsed tables.</p>
<pre><code>|Usage: av[?jr*] C++ vtables and RTTI
| av           search for vtables in data sections and show results
| avj          like av, but as json
| av*          like av, but as rizin commands
| avr[j@addr]  try to parse RTTI at vtable addr (see analysis.cpp.abi)
| avra[j]      search for vtables and try to parse RTTI at each of them
</code></pre>
<p>The main commands here are <code>av</code> and <code>avr</code>. <code>av</code> lists all virtual tables
found when rizin opened the file. If you are not happy with the result
you may want to try to parse a virtual table at a particular address with
<code>avr</code> command. <code>avra</code> performs the search and parsing of all virtual
tables in the binary, like rizin does during the file opening.</p>
<h1 id="syscalls"><a class="header" href="#syscalls">Syscalls</a></h1>
<p>Rizin allows manual search for assembly code looking like a syscall operation.
For example on the ARM platform, usually, these are represented by the <code>svc</code> instruction,
on the others, these can be different instructions, e.g. <code>syscall</code> on x86 PC.</p>
<pre><code>[0x0001ece0]&gt; /ad/ svc
...
0x000187c2   # 2: svc 0x76
0x000189ea   # 2: svc 0xa9
0x00018a0e   # 2: svc 0x82
...
</code></pre>
<p>Syscalls detection is driven by <code>asm.os</code>, <code>asm.bits</code>, and <code>asm.arch</code>. Be sure
to set those configuration options accordingly. You can use <code>asl</code> command
to check if syscalls' support is set up properly and as you expect.
The command lists syscalls supported for your platform.</p>
<pre><code>[0x0001ece0]&gt; asl
...
sd_softdevice_enable = 0x80.16
sd_softdevice_disable = 0x80.17
sd_softdevice_is_enabled = 0x80.18
...
</code></pre>
<p>If you setup ESIL stack with <code>aei</code> or <code>aeim</code>, you can use <code>/as</code> command to search
the addresses where particular syscalls were found and list them.</p>
<pre><code>[0x0001ece0]&gt; aei
[0x0001ece0]&gt; /as
0x000187c2 sd_ble_gap_disconnect
0x000189ea sd_ble_gatts_sys_attr_set
0x00018a0e sd_ble_gap_sec_info_reply
...
</code></pre>
<p>To reduce searching time it is possible to <a href="analysis/../search_bytes/configurating_the_search.html">restrict the
searching</a> range for
only executable segments or sections with <code>/as @e:search.in=io.maps.x</code></p>
<p>Using the <a href="analysis/emulation.html">ESIL emulation</a> rizin can print syscall arguments
in the disassembly output. To enable the linear (but very rough) emulation use
<code>asm.emu</code> configuration variable:</p>
<pre><code>[0x0001ece0]&gt; e asm.emu=true
[0x0001ece0]&gt; s 0x000187c2
[0x000187c2]&gt; pdf~svc
   0x000187c2   svc 0x76  ; 118 = sd_ble_gap_disconnect
[0x000187c2]&gt;
</code></pre>
<p>In case of executing <code>aae</code> (or <code>aaaa</code> which calls <code>aae</code>) command
rizin will push found syscalls to a special <code>syscall.</code> flagspace,
which can be useful for automation purpose:</p>
<pre><code>[0x000187c2]&gt; fs
0    0 * imports
1    0 * symbols
2 1523 * functions
3  420 * strings
4  183 * syscalls
[0x000187c2]&gt; f~syscall
...
0x000187c2 1 syscall.sd_ble_gap_disconnect.0
0x000189ea 1 syscall.sd_ble_gatts_sys_attr_set
0x00018a0e 1 syscall.sd_ble_gap_sec_info_reply
...
</code></pre>
<p>It also can be interactively navigated through within HUD mode (<code>V_</code>)</p>
<pre><code>0&gt; syscall.sd_ble_gap_disconnect
 - 0x000187b2  syscall.sd_ble_gap_disconnect
   0x000187c2  syscall.sd_ble_gap_disconnect.0
   0x00018a16  syscall.sd_ble_gap_disconnect.1
   0x00018b32  syscall.sd_ble_gap_disconnect.2
   0x0002ac36  syscall.sd_ble_gap_disconnect.3
</code></pre>
<p>When debugging in rizin, you can use <code>dcs</code> to continue execution until the next syscall. You can also run <code>dcs*</code> to trace all syscalls.</p>
<pre><code>[0xf7fb9120]&gt; dcs*
Running child until syscalls:-1 
child stopped with signal 133
--&gt; SN 0xf7fd3d5b syscall 45 brk (0xffffffda)
child stopped with signal 133
--&gt; SN 0xf7fd28f3 syscall 384 arch_prctl (0xffffffda 0x3001)
child stopped with signal 133
--&gt; SN 0xf7fc81b2 syscall 33 access (0xffffffda 0xf7fd8bf1)
child stopped with signal 133
</code></pre>
<p>rizin also has a syscall name to syscall number utility. You can return the syscall name of a given syscall number or vice versa, without leaving the shell.</p>
<pre><code>[0x08048436]&gt; asl 1
exit
[0x08048436]&gt; asl write
4
[0x08048436]&gt; ask write
0x80,4,3,iZi
</code></pre>
<p>See <code>as?</code> for more information about the utility.</p>
<h1 id="emulation"><a class="header" href="#emulation">Emulation</a></h1>
<p>One of the most important things to remember in reverse engineering is
the core difference between static analysis and dynamic analysis. As many already
know, static analysis suffers from the path explosion problem, which is impossible
to solve even in the most basic way without at least a partial emulation.</p>
<p>Thus many professional reverse engineering tools use code emulation while
performing an analysis of binary code, and rizin is no different here.</p>
<p>For partial emulation (or imprecise full emulation) rizin uses its own
<a href="analysis/../disassembling/esil.html">ESIL</a> intermediate language and virtual machine.</p>
<p>Rizin supports this kind of partial emulation for all platforms that
implement ESIL uplifting (x86/x86_64, ARM, arm64, MIPS, PowerPC, SPARC, AVR, 8051, Gameboy, ...).</p>
<p>One of the most common usages of such emulation is to calculate
indirect jumps and conditional jumps.</p>
<p>To see the ESIL representation of the program one can use the <code>ao</code> command or enable the <code>asm.esil</code> configuration
variable, to check if the program uplifted correctly, and to grasp how ESIL works:</p>
<pre><code>[0x00001660]&gt; pdf
. (fcn) fcn.00001660 40
│   fcn.00001660 ();
│     ; CALL XREF from 0x00001713 (entry2.fini)
│     0x00001660  lea rdi, obj.__progname      ; 0x207220
│     0x00001667  push rbp
│     0x00001668  lea rax, obj.__progname      ; 0x207220
│     0x0000166f  cmp rax, rdi
│     0x00001672  mov rbp, rsp
│ .─&lt; 0x00001675  je 0x1690
│ │   0x00001677  mov rax, qword [reloc._ITM_deregisterTMCloneTable] ; [0x206fd8:8]=0
│ │   0x0000167e  test rax, rax
│.──&lt; 0x00001681  je 0x1690
│││   0x00001683  pop rbp
│││   0x00001684  jmp rax
│``─&gt; 0x00001690  pop rbp
`     0x00001691  ret
[0x00001660]&gt; e asm.esil=true
[0x00001660]&gt; pdf
. (fcn) fcn.00001660 40
│   fcn.00001660 ();
│     ; CALL XREF from 0x00001713 (entry2.fini)
│     0x00001660  0x205bb9,rip,+,rdi,=
│     0x00001667  rbp,8,rsp,-=,rsp,=[8]
│     0x00001668  0x205bb1,rip,+,rax,=
│     0x0000166f  rdi,rax,==,$z,zf,=,$b64,cf,=,$p,pf,=,$s,sf,=,$o,of,=
│     0x00001672  rsp,rbp,=
│ .─&lt; 0x00001675  zf,?{,5776,rip,=,}
│ │   0x00001677  0x20595a,rip,+,[8],rax,=
│ │   0x0000167e  0,rax,rax,&amp;,==,$z,zf,=,$p,pf,=,$s,sf,=,$0,cf,=,$0,of,=
│.──&lt; 0x00001681  zf,?{,5776,rip,=,}
│││   0x00001683  rsp,[8],rbp,=,8,rsp,+=
│││   0x00001684  rax,rip,=
│``─&gt; 0x00001690  rsp,[8],rbp,=,8,rsp,+=
`     0x00001691  rsp,[8],rip,=,8,rsp,+=
</code></pre>
<p>To manually setup the ESIL imprecise emulation you need to run this command sequence:</p>
<ul>
<li><code>aei</code> to initialize ESIL VM</li>
<li><code>aeim</code> to initialize ESIL VM memory (stack)</li>
<li><code>aeip</code> to set the initial ESIL VM IP (instruction pointer)</li>
<li>a sequence of <code>aer</code> commands to set the initial register values.</li>
</ul>
<p>While performing emulation, please remember, that ESIL VM cannot emulate external calls
or system calls, along with SIMD instructions. Thus the most common scenario is to
emulate only a small chunk of the code, like encryption/decryption, unpacking or
calculating something.</p>
<p>After we successfully set up the ESIL VM we can interact with it like with a usual debugging mode.
The commands interface for ESIL VM is almost identical to the debugging one:</p>
<ul>
<li><code>aes</code> to step (or <code>s</code> key in visual mode)</li>
<li><code>aesi</code> to step over the function calls</li>
<li><code>aesu &lt;address&gt;</code> to step until some specified address</li>
<li><code>aesue &lt;ESIL expression&gt;</code> to step until some specified ESIL expression met</li>
<li><code>aec</code> to continue until break (Ctrl-C), this one is rarely used though, due to the omnipresence of external calls</li>
</ul>
<p>In visual mode, all of the debugging hotkeys will work also in ESIL emulation mode.</p>
<p>Along with usual emulation, there is a possibility to record and replay mode:</p>
<ul>
<li><code>aets</code> to list all current ESIL R&amp;R sessions</li>
<li><code>aets+</code> to create a new one</li>
<li><code>aesb</code> to step back in the current ESIL R&amp;R session</li>
</ul>
<p>More about this operation mode you can read in <a href="analysis/../debugger/revdebug.html">Reverse Debugging</a> chapter.</p>
<h2 id="emulation-in-analysis-loop"><a class="header" href="#emulation-in-analysis-loop">Emulation in analysis loop</a></h2>
<p>Apart from the manual emulation mode, it can be used automatically in the analysis loop.
For example, the <code>aaaa</code> command performs the ESIL emulation stage along with others.
To disable or enable its usage you can use <code>analysis.esil</code> configuration variable.
There is one more important option, though setting it might be quite dangerous,
especially in the case of malware - <code>emu.write</code> which allows ESIL VM to modify memory.
Sometimes it is required though, especially in the process of deobfuscating or unpacking code.</p>
<p>To show the process of emulation you can set <code>asm.emu</code> variable, which will show calculated
register and memory values in disassembly comments:</p>
<pre><code>[0x00001660]&gt; e asm.emu=true
[0x00001660]&gt; pdf
. (fcn) fcn.00001660 40
│   fcn.00001660 ();
│     ; CALL XREF from 0x00001713 (entry2.fini)
│     0x00001660  lea rdi, obj.__progname ; 0x207220 ; rdi=0x207220 -&gt; 0x464c457f
│     0x00001667  push rbp                ; rsp=0xfffffffffffffff8
│     0x00001668  lea rax, obj.__progname ; 0x207220 ; rax=0x207220 -&gt; 0x464c457f
│     0x0000166f  cmp rax, rdi            ; zf=0x1 -&gt; 0x2464c45 ; cf=0x0 ; pf=0x1 -&gt; 0x2464c45 ; sf=0x0 ; of=0x0
│     0x00001672  mov rbp, rsp            ; rbp=0xfffffffffffffff8
│ .─&lt; 0x00001675  je 0x1690               ; rip=0x1690 -&gt; 0x1f0fc35d ; likely
│ │   0x00001677  mov rax, qword [reloc._ITM_deregisterTMCloneTable] ; [0x206fd8:8]=0 ; rax=0x0
│ │   0x0000167e  test rax, rax           ; zf=0x1 -&gt; 0x2464c45 ; pf=0x1 -&gt; 0x2464c45 ; sf=0x0 ; cf=0x0 ; of=0x0
│.──&lt; 0x00001681  je 0x1690               ; rip=0x1690 -&gt; 0x1f0fc35d ; likely
│││   0x00001683  pop rbp                 ; rbp=0xffffffffffffffff -&gt; 0x4c457fff ; rsp=0x0
│││   0x00001684  jmp rax                 ; rip=0x0 ..
│``─&gt; 0x00001690  pop rbp                 ; rbp=0x10102464c457f ; rsp=0x8 -&gt; 0x464c457f
`     0x00001691  ret                     ; rip=0x0 ; rsp=0x10 -&gt; 0x3e0003
</code></pre>
<p>Note here <code>likely</code> comments, which indicates that ESIL emulation predicted for particular
conditional jump to happen.</p>
<p>Apart from the basic ESIL VM setup, you can change the behavior with other options located
in <code>emu.</code> and <code>esil.</code> configuration namespaces.</p>
<p>For manipulating ESIL working with memory and stack you can use the following options:</p>
<ul>
<li><code>esil.stack</code> to enable or disable temporary stack for <code>asm.emu</code> mode</li>
<li><code>esil.stack.addr</code> to set stack address in ESIL VM (like <code>aeim</code> command)</li>
<li><code>esil.stack.size</code> to set stack size in ESIL VM (like <code>aeim</code> command)</li>
<li><code>esil.stack.depth</code> limits the number of PUSH operations into the stack</li>
<li><code>esil.romem</code> specifies read-only access to the ESIL memory</li>
<li><code>esil.fillstack</code> and <code>esil.stack.pattern</code> allows you to use a various pattern for filling ESIL VM
stack upon initialization</li>
<li><code>esil.nonull</code> when set stops ESIL execution upon NULL pointer read or write.</li>
</ul>
<h1 id="symbols"><a class="header" href="#symbols">Symbols</a></h1>
<p>Rizin automatically parses available imports and exports sections in the binary,
moreover, it can load additional debugging information if present.
Two main formats are supported: DWARF and PDB (for Windows binaries).
Note that, unlike many tools rizin doesn't rely on Windows API to parse
PDB files, thus they can be loaded on any other supported platform - e.g.
Linux or OS X.</p>
<p>DWARF debug info loads automatically by default because usually it's stored
right in the executable file. PDB is a bit of a different beast - it is always
stored as a separate binary, thus the different logic of handling it.</p>
<p>At first, one of the common scenarios is to analyze the file from Windows distribution.
In this case, all PDB files are available on the Microsoft server, which is by default
is in options. See all pdb options in rizin:</p>
<pre><code>pdb.autoload = 0
pdb.extract = 1
pdb.server = https://msdl.microsoft.com/download/symbols
pdb.useragent = Microsoft-Symbol-Server/6.11.0001.402
</code></pre>
<p>Using the variable <code>pdb.server</code> you can change the address where rizin will try to
download the PDB file by the GUID stored in the executable header.
You can make use of multiple symbol servers by separating each URL with a semi-colon:</p>
<pre><code>e pdb.server=https://msdl.microsoft.com/download/symbols;https://symbols.mozilla.org/
</code></pre>
<p>On Windows,  you can also use local network share paths (UNC paths) as symbol servers.</p>
<p>Usually, there is no reason to change the default <code>pdb.useragent</code>, but who knows where
could it be handy?</p>
<p>Because those PDB files are stored as &quot;cab&quot; archives on the server, <code>pdb.extract=1</code>
says to automatically extract them.</p>
<p>Note that for the automatic downloading to work you need the &quot;cabextract&quot; tool, and wget/curl installed.</p>
<p>Sometimes you don't need to do that from the rizin itself, thus - two handy
rz-bin options:</p>
<pre><code> -P              show debug/pdb information
 -PP             download pdb file for binary
</code></pre>
<p>where <code>-PP</code> automatically downloads the pdb for the selected binary, using those
<code>pdb.*</code> config options. <code>-P</code> will dump the contents of the PDB file, which is useful
sometimes for a quick understanding of the symbols stored in it.</p>
<p>Apart from the basic scenario of just opening a file, PDB information can be additionally
manipulated by the <code>id</code> commands:</p>
<pre><code>[0x000051c0]&gt; id?
|Usage: id Debug information
| Output mode:
| '*'              Output in rizin commands
| id               Source lines
| idp [file.pdb]   Load pdb file information
| idpi [file.pdb]  Show pdb file information
| idpd             Download pdb file on remote server
</code></pre>
<p>Where <code>idpi</code> is basically the same as <code>rz-bin -P</code>.
Note that <code>idp</code> can be also used not only in the static analysis mode but also
in the debugging mode, even if connected via WinDbg.</p>
<p>For simplifying the loading PDBs, especially for the processes with many linked DLLs,
rizin can autoload all required PDBs automatically - you need just set the
<code>e pdb.autoload=true</code> option. Then if you load some file in debugging mode
in Windows, using <code>rizin -d file.exe</code> or <code>rizin -d 2345</code> (attach to pid 2345), all
related PDB files will be loaded automatically.</p>
<p>DWARF information loading, on the other hand, is completely automated. You don't
need to run any commands/change any options:</p>
<pre><code>rizin `which rz-bin`
[0x00002437 8% 300 /usr/local/bin/rz-bin]&gt; pd $r
0x00002437  jne 0x2468                  ;[1]
0x00002439  cmp qword reloc.__cxa_finalize_224, 0
0x00002441  push rbp
0x00002442  mov rbp, rsp
0x00002445  je 0x2453                   ;[2]
0x00002447  lea rdi, obj.__dso_handle   ; 0x207c40 ; &quot;@| &quot;
0x0000244e  call 0x2360                 ;[3]
0x00002453  call sym.deregister_tm_clones ;[4]
0x00002458  mov byte [obj.completed.6991], 1 ; obj.__TMC_END__ ; [0x2082f0:1]=0
0x0000245f  pop rbp
0x00002460  ret
0x00002461  nop dword [rax]
0x00002468  ret
0x0000246a  nop word [rax + rax]
;-- entry1.init:
;-- frame_dummy:
0x00002470  push rbp
0x00002471  mov rbp, rsp
0x00002474  pop rbp
0x00002475  jmp sym.register_tm_clones  ;[5]
;-- blob_version:
0x0000247a  push rbp                    ; ../blob/version.c:18
0x0000247b  mov rbp, rsp
0x0000247e  sub rsp, 0x10
0x00002482  mov qword [rbp - 8], rdi
0x00002486  mov eax, 0x32               ; ../blob/version.c:24 ; '2'
0x0000248b  test al, al                 ; ../blob/version.c:19
0x0000248d  je 0x2498                   ;[6]
0x0000248f  lea rax, str.2.0.1_182_gf1aa3aa4d ; 0x60b8 ; &quot;2.0.1-182-gf1aa3aa4d&quot;
0x00002496  jmp 0x249f                  ;[7]
0x00002498  lea rax, 0x000060cd
0x0000249f  mov rsi, qword [rbp - 8]
0x000024a3  mov r8, rax
0x000024a6  mov ecx, 0x40               ; section_end.ehdr
0x000024ab  mov edx, 0x40c0
0x000024b0  lea rdi, str._s_2.1.0_git__d___linux_x86__d_git._s_n ; 0x60d0 ; &quot;%s 2.1.0-git %d @ linux-x86-%d git.%s\n&quot;
0x000024b7  mov eax, 0
0x000024bc  call 0x2350                 ;[8]
0x000024c1  mov eax, 0x66               ; ../blob/version.c:25 ; 'f'
0x000024c6  test al, al
0x000024c8  je 0x24d6                   ;[9]
0x000024ca  lea rdi, str.commit:_f1aa3aa4d2599c1ad60e3ecbe5f4d8261b282385_build:_2017_11_06__12:18:39 ; ../blob/version.c:26 ; 0x60f8 ; &quot;commit: f1aa3aa4d2599c1ad60e3ecbe5f4d8261b282385 build: 2017-11-06__1
0x000024d1  call sym.imp.puts           ;[?]
0x000024d6  mov eax, 0                  ; ../blob/version.c:28
0x000024db  leave                       ; ../blob/version.c:29
0x000024dc  ret
;-- rabin_show_help:
0x000024dd  push rbp                    ; .//rz-bin.c:27
</code></pre>
<p>As you can see, it loads function names and source line information.</p>
<h1 id="signatures"><a class="header" href="#signatures">Signatures</a></h1>
<p>Rizin has its own format of the signatures, allowing to both load/apply and
create them on the fly. They are available under the <code>z</code> command namespace:</p>
<pre><code>[0x00000000]&gt; z?
Usage: z[*j-aof/cs] [args]   # Manage zignatures
| z            show zignatures
| z.           find matching zignatures in current offset
| zb[?][n=5]   search for best match
| z*           show zignatures in rizin format
| zq           show zignatures in quiet mode
| zj           show zignatures in json format
| zk           show zignatures in sdb format
| z-zignature  delete zignature
| z-*          delete all zignatures
| za[?]        add zignature
| zg           generate zignatures (alias for zaF)
| zo[?]        manage zignature files
| zf[?]        manage FLIRT signatures
| z/[?]        search zignatures
| zc[?]        compare current zignspace zignatures with another one
| zs[?]        manage zignspaces
| zi           show zignatures matching information
</code></pre>
<p>To load the created signature file you need to load it from SDB file using <code>zo</code> command or
from the compressed SDB file using <code>zoz</code> command.</p>
<p>To create signature you need to make function first, then you can create it from the function:</p>
<pre><code>rizin /bin/ls
[0x000051c0]&gt; aaa # this creates functions, including 'entry0'
[0x000051c0]&gt; zaf entry0 entry
[0x000051c0]&gt; z
entry:
  bytes: 31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4
  graph: cc=1 nbbs=1 edges=0 ebbs=1
  offset: 0x000051c0
[0x000051c0]&gt;
</code></pre>
<p>As you can see it made a new signature with a name <code>entry</code> from a function <code>entry0</code>.
You can show it in JSON format too, which can be useful for scripting:</p>
<pre><code>[0x000051c0]&gt; zj~{}
[
  {
    &quot;name&quot;: &quot;entry&quot;,
    &quot;bytes&quot;: &quot;31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4&quot;,
    &quot;graph&quot;: {
      &quot;cc&quot;: &quot;1&quot;,
      &quot;nbbs&quot;: &quot;1&quot;,
      &quot;edges&quot;: &quot;0&quot;,
      &quot;ebbs&quot;: &quot;1&quot;
    },
    &quot;offset&quot;: 20928,
    &quot;refs&quot;: [
    ]
  }
]
[0x000051c0]&gt;
</code></pre>
<p>To remove it just run <code>z-entry</code>.</p>
<p>If you want, instead, to save all created signatures, you need to save it into the SDB file using command <code>zos myentry</code>.</p>
<p>Then we can apply them. Lets open a file again:</p>
<pre><code>rizin /bin/ls
 -- Log On. Hack In. Go Anywhere. Get Everything.
[0x000051c0]&gt; zo myentry
[0x000051c0]&gt; z
entry:
  bytes: 31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4
  graph: cc=1 nbbs=1 edges=0 ebbs=1
  offset: 0x000051c0
[0x000051c0]&gt;
</code></pre>
<p>This means that the signatures were successfully loaded from the file <code>myentry</code> and now we can
search matching functions:</p>
<pre><code>[0x000051c0]&gt; z.
[+] searching 0x000051c0 - 0x000052c0
[+] searching function metrics
hits: 1
[0x000051c0]&gt;
</code></pre>
<p>Note that <code>z.</code> command just checks the signatures against the current address.
To search signatures across the all file we need to do a bit different thing.
There is an important moment though, if we just run it &quot;as is&quot; - it won't find anything:</p>
<pre><code>[0x000051c0]&gt; z/
[+] searching 0x0021dfd0 - 0x002203e8
[+] searching function metrics
hits: 0
[0x000051c0]&gt;
</code></pre>
<p>Note the searching address - this is because we need to <a href="signatures/../search_bytes/configurating_the_search.html">adjust the searching</a> range first:</p>
<pre><code>[0x000051c0]&gt; e search.in=io.section
[0x000051c0]&gt; z/
[+] searching 0x000038b0 - 0x00015898
[+] searching function metrics
hits: 1
[0x000051c0]&gt;
</code></pre>
<p>We are setting the search mode to <code>io.section</code> (it was <code>file</code> by default) to search in the current
section (assuming we are currently in the <code>.text</code> section of course).
Now we can check, what rizin found for us:</p>
<pre><code>[0x000051c0]&gt; pd 5
;-- entry0:
;-- sign.bytes.entry_0:
0x000051c0      31ed           xor ebp, ebp
0x000051c2      4989d1         mov r9, rdx
0x000051c5      5e             pop rsi
0x000051c6      4889e2         mov rdx, rsp
0x000051c9      4883e4f0       and rsp, 0xfffffffffffffff0
[0x000051c0]&gt;
</code></pre>
<p>Here we can see the comment of <code>entry0</code>, which is taken from the ELF parsing, but also the
<code>sign.bytes.entry_0</code>, which is exactly the result of matching signature.</p>
<p>Signatures configuration stored in the <code>zign.</code> config vars' namespace:</p>
<pre><code>[0x000051c0]&gt; el zign.
       zign.autoload: Autoload all zignatures located in ~/.local/share/rizin/zigns
   zign.diff.bthresh: Threshold for diffing zign bytes [0, 1] (see zc?)
   zign.diff.gthresh: Threshold for diffing zign graphs [0, 1] (see zc?)
    zign.match.bytes: Use bytes patterns for matching
    zign.match.graph: Use graph metrics for matching
     zign.match.hash: Use Hash for matching
   zign.match.offset: Use original offset for matching
     zign.match.refs: Use references for matching
    zign.match.types: Use types for matching
          zign.maxsz: Maximum zignature length
          zign.mincc: Minimum cyclomatic complexity for matching
          zign.minsz: Minimum zignature length for matching
         zign.prefix: Default prefix for zignatures matches
      zign.threshold: Minimum similarity required for inclusion in zb output
[0x000051c0]&gt;
</code></pre>
<h2 id="finding-best-matches-zb"><a class="header" href="#finding-best-matches-zb">Finding Best Matches <code>zb</code></a></h2>
<p>Often you know the signature should exist somewhere in a binary but <code>z/</code> and
<code>z.</code> still fail. This is often due to very minor differences between the
signature and the function. Maybe the compiler switched two instructions, or
your signature is not for the correct function version. In these situations the
<code>zb</code> commands can still help point you in the right direction by listing near
matches.</p>
<pre><code>[0x000040a0]&gt; zb?
Usage: zb[r?] [args]  # search for closest matching signatures
| zb [n]           find n closest matching zignatures to function at current offset
| zbr zigname [n]  search for n most similar functions to zigname
</code></pre>
<p>The <code>zb</code> (zign best) command will show the top 5 closest signatures to a
function. Each will contain a score between 1.0 and 0.0.</p>
<pre><code>[0x0041e390]&gt; s sym.fclose
[0x0040fc10]&gt; zb
0.96032  0.92400 B  0.99664 G   sym.fclose
0.65971  0.35600 B  0.96342 G   sym._nl_expand_alias
0.65770  0.37800 B  0.93740 G   sym.fdopen
0.65112  0.35000 B  0.95225 G   sym.__run_exit_handlers
0.62532  0.34800 B  0.90264 G   sym.__cxa_finalize
</code></pre>
<p>In the above example, <code>zb</code> correctly associated the <code>sym.fclose</code> signature to
the current function. The <code>z/</code> and <code>z.</code> command would have failed to match here
since both the <code>B</code>yte and <code>G</code>raph scores are less then 1.0. A 30% separation
between the first and second place results is also a good indication of a
correct match.</p>
<p>The <code>zbr</code> (zign best reverse) accepts a zignature name and attempts to find the
closet matching functions. Use an analysis command, like <code>aa</code> to find functions
first.</p>
<pre><code>[0x00401b20]&gt; aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x00401b20]&gt; zo ./libc.sdb
[0x00401b20]&gt; zbr sym.__libc_malloc 10
0.94873  0.89800 B  0.99946 G   sym.malloc
0.65245  0.40600 B  0.89891 G   sym._mid_memalign
0.59470  0.38600 B  0.80341 G   sym._IO_flush_all_lockp
0.59200  0.28200 B  0.90201 G   sym._IO_file_underflow
0.57802  0.30400 B  0.85204 G   sym.__libc_realloc
0.57094  0.35200 B  0.78988 G   sym.__calloc
0.56785  0.34000 B  0.79570 G   sym._IO_un_link.part.0
0.56358  0.36200 B  0.76516 G   sym._IO_cleanup
0.56064  0.26000 B  0.86127 G   sym.intel_check_word.constprop.0
0.55726  0.28400 B  0.83051 G   sym.linear_search_fdes
</code></pre>
<h1 id="graph-commands"><a class="header" href="#graph-commands">Graph commands</a></h1>
<p>When analyzing data it is usually handy to have different ways to represent it in order to get new perspectives to allow the analyst to understand how different parts of the program interact.</p>
<p>Representing basic block edges, function calls, string references as graphs show a very clear view of this information.</p>
<p>Rizin supports various types of graph available through commands starting with <code>ag</code>:</p>
<pre><code>[0x00005000]&gt; ag?
|Usage: ag&lt;graphtype&gt;&lt;format&gt; [addr]
| Graph commands:
| aga[format]             Data references graph
| agA[format]             Global data references graph
| agc[format]             Function callgraph
| agC[format]             Global callgraph
| agd[format] [fcn addr]  Diff graph
| agf[format]             Basic blocks function graph
| agi[format]             Imports graph
| agr[format]             References graph
| agR[format]             Global references graph
| agx[format]             Cross references graph
| agg[format]             Custom graph
| ag-                     Clear the custom graph
| agn[?] title body       Add a node to the custom graph
| age[?] title1 title2    Add an edge to the custom graph

Output formats:
| &lt;blank&gt;                 Ascii art
| *                       rizin commands
| d                       Graphviz dot
| g                       Graph Modelling Language (gml)
| j                       json ('J' for formatted disassembly)
| k                       SDB key-value
| t                       Tiny ascii art
| v                       Interactive ascii art
| w [path]                Write to path or display graph image (see graph.gv.format and graph.web)
</code></pre>
<p>The structure of the commands is as follows: <code>ag &lt;graph type&gt; &lt;output format&gt;</code>.</p>
<p>For example, <code>agid</code> displays the imports graph in dot format, while <code>aggj</code>
outputs the custom graph in JSON format.</p>
<p>Here's a short description for every output format available:</p>
<h3 id="ascii-art--eg-agf"><a class="header" href="#ascii-art--eg-agf">Ascii Art ** (e.g. <code>agf</code>)</a></h3>
<p>Displays the graph directly to stdout using ASCII art to represent blocks and edges.</p>
<p><em>Warning: displaying large graphs directly to stdout might prove to be computationally expensive and will make rizin not responsive for some time. In case of doubt, prefer using the interactive view (explained below).</em></p>
<h3 id="interactive-ascii-art-eg-agfv"><a class="header" href="#interactive-ascii-art-eg-agfv">Interactive Ascii Art (e.g. <code>agfv</code>)</a></h3>
<p>Displays the ASCII graph in an interactive view similar to <code>VV</code> which allows to move the screen, zoom in / zoom out, ...</p>
<h3 id="tiny-ascii-art-eg-agft"><a class="header" href="#tiny-ascii-art-eg-agft">Tiny Ascii Art (e.g. <code>agft</code>)</a></h3>
<p>Displays the ASCII graph directly to stdout in tiny mode (which is the same as reaching the maximum zoom out level in the interactive view).</p>
<h3 id="graphviz-dot-eg-agfd"><a class="header" href="#graphviz-dot-eg-agfd">Graphviz dot	(e.g. <code>agfd</code>)</a></h3>
<p>Prints the dot source code representing the graph, which can be interpreted by programs such as <a href="https://graphviz.gitlab.io/download/">graphviz</a> or online viewers like <a href="http://www.webgraphviz.com/">this</a></p>
<h3 id="json-eg-agfj"><a class="header" href="#json-eg-agfj">JSON	(e.g. <code>agfj</code>)</a></h3>
<p>Prints a JSON string representing the graph.</p>
<ul>
<li>
<p>In the case of the <code>f</code> format (basic blocks of function), it will have detailed information about the function and will also contain the disassembly of the function (use <code>J</code> format for the formatted disassembly.</p>
</li>
<li>
<p>In all other cases, it will only have basic information about the nodes of the graph (id, title, body, and edges).</p>
</li>
</ul>
<h3 id="graph-modelling-language-eg-agfg"><a class="header" href="#graph-modelling-language-eg-agfg">Graph Modelling Language (e.g. <code>agfg</code>)</a></h3>
<p>Prints the GML source code representing the graph, which can be interpreted by programs such as <a href="https://www.yworks.com/products/yed/download">yEd</a></p>
<h3 id="sdb-key-value-eg-agfk"><a class="header" href="#sdb-key-value-eg-agfk">SDB key-value (e.g. <code>agfk</code>)</a></h3>
<p>Prints key-value strings representing the graph that was stored by sdb (rizin's string database).</p>
<h3 id="r2-custom-graph-commands-eg-agf"><a class="header" href="#r2-custom-graph-commands-eg-agf">R2 custom graph commands (e.g. <code>agf*</code>)</a></h3>
<p>Prints rizin commands that would recreate the desired graph. The commands to construct the graph are <code>agn [title] [body]</code> to add a node and <code>age [title1] [title2]</code> to add an edge.
The <code>[body]</code> field can be expressed in base64 to include special formatting (such as newlines).</p>
<p>To easily execute the printed commands, it is possible to prepend a dot to the command (<code>.agf*</code>).</p>
<h3 id="web--image-eg-agfw"><a class="header" href="#web--image-eg-agfw">Web / image	(e.g. <code>agfw</code>)</a></h3>
<p>Rizin will convert the graph to dot format, use the <code>dot</code> program to convert it to a <code>.gif</code> image and then try to find an already installed viewer on your system (<code>xdg-open</code>, <code>open</code>, ...) and display the graph there.</p>
<p>The extension of the output image can be set with the <code>graph.extension</code> config variable. Available extensions are <code>png, jpg, gif, pdf, ps</code>.</p>
<p><em>Note: for particularly large graphs, the most recommended extension is <code>svg</code> as it will produce images of much smaller size</em></p>
<p>If <code>graph.web</code> config variable is enabled, rizin will try to display the graph using the browser (<em>this feature is experimental and unfinished, and
disabled by default.</em>)</p>
<h1 id="cpu-and-platform-profiles"><a class="header" href="#cpu-and-platform-profiles">CPU and platform profiles</a></h1>
<h2 id="the-motivation"><a class="header" href="#the-motivation">The motivation</a></h2>
<p>The computer ecosystem, especially in embedded systems is vast and growing and is thus 
diverse and is full of trivial differences. CPUs and development boards differ by minor and sometimes 
large differences in their design, ports, MMIO registers and other peripherals. Rizin handles these 
differences by storing the data regarding each CPUs and platforms in <a href="https://book.rizin.re/basic_commands/sdb.html?highlight=SDB#sdb">SDB</a> files in a standard format, instead of hardcoding them with each of the 
disassembler plugins. This information will be parsed and added as flags and comments during the analysis
loop and will show up in the disassembly and other places, making reverse engineering on those particular 
chips ets is much easier. This also helps in easy addition of a new port, in maintenance and in user-friendliness. </p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<h3 id="cpu-profiles"><a class="header" href="#cpu-profiles">CPU profiles</a></h3>
<p>All the specifics pertaining to a CPU is written down in a CPU profile. It is designed in a way that allows you 
to enter CPU specefic values like: size of the RAM (<code>RAM_SIZE</code>), size of the ROM (<code>ROM_SIZE</code>) and many more. 
CPU profiles can be selected using the configuration variable <code>asm.cpu</code>. Firstly, Rizin checks whether the
a CPU profile exists for the selected CPU and architecture. If it exists, Rizin generates the filepath of the
profile and gets to a stage where it's ready to be loaded up. During analysis (<code>aa</code>), it's loaded up and the values are 
parsed and handled. CPU profiles also allow you to add information regarding the IO and extended IO registers of a CPU. 
The information pertaining to the IO and extended IO registers are added as flags at their corresponding offsets. </p>
<p>The CPU profile of AVR's ATTiny88 CPU looks like this:</p>
<pre><code class="language-config">RAM_SIZE=512
ROM_SIZE=8192
INTERRUPT_VECTOR_SIZE=2

PINB=io
PINB.address=0x03
DDRB=io
DDRB.address=0x04
PORTB=io
</code></pre>
<p>Here, <code>PINB</code> is the name and <code>io</code> is the type of the port and this will be added as a 
flag at the offset <code>0x03</code>. The type can be <code>ext_io</code> if it's an extended IO register, as well. Both will be added 
as <a href="https://book.rizin.re/basic_commands/flags.html?highlight=flags#flags">flags</a> and the only difference between 
them is that they will be added in different <a href="https://book.rizin.re/refcard/intro.html?highlight=flagspa#flagspaces">flagspaces</a>.</p>
<p>CPU profiles also support mapping the ROM. According the <code>ROM_ADDRESS</code> and <code>ROM_SIZE</code>, a <a href="https://book.rizin.re/basic_commands/sections.html?highlight=section#sections">section</a> named <code>.rom</code> will be added during analysis.</p>
<h4 id="adding-cpu-profiles"><a class="header" href="#adding-cpu-profiles">Adding CPU profiles</a></h4>
<p>CPU profiles are stored in SDB files under the directory <code>lirbz/asm/cpus</code> and that's where you will have to put
your new profile. The files follow a naming convention like <code>arch-cpu</code>. You can see the complete list of things 
that are parsed at <code>librz/analysis/arch_profile.c</code> and if necessary, a new key can be easily added.</p>
<p>To add a new CPU profile, firstly make sure that you have the name of the CPU defined in the list of CPUs defined
by the variable <code>cpus</code> in the corresponding architecture's disassembler plugin (<code>RzAsmPlugin</code>). Then, simply add 
the SDB file in the directory, add the entry in the <code>meson.build</code> of the same directory and build again. Choose 
the right CPU and architecture and analyze again (<code>aa</code>) to load up the CPU profile.</p>
<p>For reference, you can see the previously added CPU profile of ATmega16 here: <a href="https://github.com/rizinorg/rizin/blob/dev/librz/asm/cpus/avr-ATmega16.sdb.txt">librz/asm/cpus/avr-ATmega16.sdb.txt</a>. </p>
<h3 id="platform-profiles"><a class="header" href="#platform-profiles">Platform profiles</a></h3>
<p>Platform profiles are designed with an idea to support adding information that is pertaining to a specific board
or a micro controller. For example, most of the Raspberry Pi-s use a specific Broadcom chip and its peripherals 
like registers and interrupts will be the same for all Raspberry Pi-s. These profiles can be selected using the 
configuration variable <code>asm.platforms</code> and is loaded during analysis (<code>aa</code>). If you run <code>e asm.platform=?</code>, you 
can see the supported platforms by the selected architecture and CPU.</p>
<p>Let's have a look at Broadcom 2835's platform profile:</p>
<pre><code class="language-config">AUX_IRQ=name
AUX_IRQ.address=0x7e215000
AUX_IRQ.comment=Auxiliary Interrupt status

AUX_MU_IO_REG=name
AUX_MU_IO_REG.address=0x7e215040
AUX_MU_IO_REG.comment=Mini UART I/O Data
</code></pre>
<p>Just like in CPU profiles, the <code>name</code> will be added as a flag and the <code>comment</code> as a <a href="https://book.rizin.re/disassembling/adding_metadata.html?highlight=Comment#adding-metadata-to-disassembly">comment</a> (<code>CCu</code>).</p>
<h4 id="adding-platform-profiles"><a class="header" href="#adding-platform-profiles">Adding platform profiles</a></h4>
<p>Platform profiles are stored in <code>librz/asm/platforms/</code> and that's where you will have to put your profile. They
follow a naming convention like <code>arch-cpu-platform</code>.</p>
<p>To add a new platform profile, we will have to define the name of the platform in the variable <code>platforms</code> in 
the <code>RzAsmPlugin</code> definition corresponding architecture's disassembler plugin. You will also need to add the 
CPU is it's not already added. Then, add the entry in the <code>meson.build</code> of the same directory and build again.
Choose the right CPU, architecture and platform and analyze again (<code>aa</code>).</p>
<p>You can also check out the platform profiles that were previously added at <a href="https://github.com/rizinorg/rizin/blob/dev/librz/asm/platforms/arm-arm1176-bcm2835.sdb.txt">librz/asm/platforms/arm-arm1176-bcm2835.sdb.txt</a>.</p>
<h2 id="scripting"><a class="header" href="#scripting">Scripting</a></h2>
<p>Rizin provides a wide set of a features to automate boring work.
It ranges from the simple sequencing of the commands to the calling
scripts/another programs via IPC (Inter-Process Communication), called rz-pipe.</p>
<p>As mentioned a few times before there is an ability to sequence commands
using <code>;</code> semicolon operator.</p>
<pre><code>[0x00404800]&gt; pd 1 ; ao 1
           0x00404800      b827e66100     mov eax, 0x61e627      ; &quot;tab&quot;
address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]&gt;
</code></pre>
<p>It simply runs the second command after finishing the first one, like in a shell.</p>
<p>The second important way to sequence the commands is with a simple pipe <code>|</code></p>
<pre><code>ao|grep address
</code></pre>
<p>Note, the <code>|</code> pipe only can pipe output of rizin commands to external (shell)
commands, like system programs or builtin shell commands.
There is a similar way to sequence rizin commands, using the backtick operator <code>`command`</code>. The quoted part will undergo command substitution and the output will be used as an argument of the command line.</p>
<p>For example, we want to see a few bytes of the memory at the address referred to
by the 'mov eax, addr' instruction. We can do that without jumping to it, using
a sequence of commands:</p>
<pre><code>[0x00404800]&gt; pd 1
              0x00404800      b827e66100     mov eax, 0x61e627      ; &quot;tab&quot;
[0x00404800]&gt; ao
address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]&gt; ao~ptr[1]
0x0061e627
0
[0x00404800]&gt; px 10 @ `ao~ptr[1]`
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x0061e627  7461 6200 2e69 6e74 6572                 tab..inter
[0x00404800]&gt;
</code></pre>
<p>And of course it's possible to redirect the output of an rizin command into a file, using the <code>&gt;</code> and <code>&gt;&gt;</code>
commands</p>
<pre><code>[0x00404800]&gt; px 10 @ `ao~ptr[1]` &gt; example.txt
[0x00404800]&gt; px 10 @ `ao~ptr[1]` &gt;&gt; example.txt
</code></pre>
<p>The <code>?$?</code> command describes several helpful variables you can use to do similar actions even more
easily, like the <code>$v</code> &quot;immediate value&quot; variable, or the <code>$m</code> opcode memory reference variable.</p>
<h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>One of the most common task in automation is looping through something,
there are multiple ways to do this in rizin. You can find all these loops
under <code>@@?</code>.</p>
<p>We can loop over flags:</p>
<pre><code>@@f:flagname-regex
</code></pre>
<p>For example, we want to see function information with <code>afi</code> command:</p>
<pre><code>[0x004047d6]&gt; afi
#
offset: 0x004047d0
name: entry0
size: 42
realsz: 42
stackframe: 0
call-convention: amd64
cyclomatic-complexity: 1
bits: 64
type: fcn [NEW]
num-bbs: 1
edges: 0
end-bbs: 1
call-refs: 0x00402450 C
data-refs: 0x004136c0 0x00413660 0x004027e0
code-xrefs:
data-xrefs:
locals:0
args: 0
diff: type: new
[0x004047d6]&gt;
</code></pre>
<p>Now let's say, for example, that we'd like see a particular field from this output for all functions found by analysis. We can do that with a loop over all function flags (whose names begin with <code>fcn.</code>):</p>
<pre><code>[0x004047d6]&gt; fs functions
[0x004047d6]&gt; afi @@f:fcn.* ~name
</code></pre>
<p>This command will extract the <code>name</code> field from the <code>afi</code> output of every flag with a name
matching the regexp <code>fcn.*</code>.
There are also other loops, for example one called <code>@@F</code> runs your command on every functions found by rizin:</p>
<pre><code>[0x004047d6]&gt; afi @@F ~name
</code></pre>
<p>We can also loop over a list of offsets, using the following syntax:</p>
<pre><code>@@=1 2 3 ... N
</code></pre>
<p>For example, say we want to see the opcode information for 2 offsets: the current one, and at current + 2:</p>
<pre><code>[0x004047d6]&gt; ao @@=$$ $$+2
address: 0x4047d6
opcode: mov rdx, rsp
prefix: 0
bytes: 4889e2
refptr: 0
size: 3
type: mov
esil: rsp,rdx,=
stack: null
family: cpu
address: 0x4047d8
opcode: loop 0x404822
prefix: 0
bytes: e248
refptr: 0
size: 2
type: cjmp
esil: 1,rcx,-=,rcx,?{,4212770,rip,=,}
jump: 0x00404822
fail: 0x004047da
stack: null
cond: al
family: cpu
[0x004047d6]&gt;
</code></pre>
<p>Note we're using the <code>$$</code> variable which evaluates to the current offset. Also note
that <code>$$+2</code> is evaluated before looping, so we can use the simple arithmetic expressions.</p>
<p>A third way to loop is by having the offsets be loaded from a file. This file should contain
one offset per line.</p>
<pre><code>[0x004047d0]&gt; ?v $$ &gt; offsets.txt
[0x004047d0]&gt; ?v $$+2 &gt;&gt; offsets.txt
[0x004047d0]&gt; !cat offsets.txt
4047d0
4047d2
[0x004047d0]&gt; pi 1 @@.offsets.txt
xor ebp, ebp
mov r9, rdx
</code></pre>
<p>If you want to iterate over all instructions of a basic block, you can do:</p>
<pre><code>[0x004047d0]&gt; pi 1 @@i
endbr64
push rbx
test rdi, rdi
je 0x14635
</code></pre>
<p>In this example the command <code>pi 1</code> runs over all the instructions in the current basic block.</p>
<p>If you want to iterate over all instructions of all basic blocks of the current function, you can do:</p>
<pre><code>[0x004047d0]&gt; pi 1 @@i @@b
endbr64     
push rbx            
test rdi, rdi
je 0x14635
mov esi, 0x2f    
mov rbx, rdi
[... cut for example ...]
mov rbx, r8                                                                                    
jmp 0x1461a         
mov rax, qword [reloc.stderr]
mov edx, 0x37     
mov esi, 1            
lea rdi, str.A_NULL_argv_0__was_passed_through_an_exec_system_call.                            
mov rcx, qword [rax]
call sym.imp.fwrite
call sym.imp.abort
</code></pre>
<p>Or if you want to make the split between basic blocks clearer:</p>
<pre><code>[0x004047d0]&gt; (_;pi 1 @@i; ?e)() @@b
endbr64     
push rbx            
test rdi, rdi
je 0x14635

mov esi, 0x2f    
mov rbx, rdi
[... cut for example ...]
mov rbx, r8                                                                                    
jmp 0x1461a         

mov rax, qword [reloc.stderr]
mov edx, 0x37     
mov esi, 1            
lea rdi, str.A_NULL_argv_0__was_passed_through_an_exec_system_call.                            
mov rcx, qword [rax]
call sym.imp.fwrite
call sym.imp.abort

</code></pre>
<h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Apart from simple sequencing and looping, rizin allows to write
simple macros, using this construction:</p>
<pre><code>[0x00404800]&gt; (qwe; pd 4; ao)
</code></pre>
<p>This will define a macro called 'qwe' which runs sequentially first 'pd 4' then 'ao'.
Calling the macro using syntax <code>.(macro)</code> is simple:</p>
<pre><code>[0x00404800]&gt; (qwe; pd 4; ao)
[0x00404800]&gt; .(qwe)
0x00404800  mov eax, 0x61e627      ; &quot;tab&quot;
0x00404805  push rbp
0x00404806  sub rax, section_end.LOAD1
0x0040480c  mov rbp, rsp

address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]&gt;
</code></pre>
<p>To list available macros simply call <code>(*</code>:</p>
<pre><code>[0x00404800]&gt; (*
(qwe ; pd 4; ao)
</code></pre>
<p>And if want to remove some macro, just add '-' before the name:</p>
<pre><code>[0x00404800]&gt; (-qwe)
Macro 'qwe' removed.
[0x00404800]&gt;
</code></pre>
<p>Moreover, it's possible to create a macro that takes arguments, which comes in handy in some
simple scripting situations. To create a macro that takes arguments you simply add them to macro definition.</p>
<pre><code>[0x00404800]
[0x004047d0]&gt; (foo x y; pd $0; sd +$1)
[0x004047d0]&gt; .(foo 5 6)
;-- entry0:
0x004047d0      xor ebp, ebp
0x004047d2      mov r9, rdx
0x004047d5      pop rsi
0x004047d6	mov rdx, rsp
0x004047d9	and rsp, 0xfffffffffffffff0
[0x004047d6]&gt;
</code></pre>
<p>As you can see, the arguments are named by index, starting from 0: $0, $1, ...</p>
<h1 id="aliases"><a class="header" href="#aliases">Aliases</a></h1>
<p>rizin also offers aliases which might help you save time by quickly executing your most used commands. They are under <code>$?</code></p>
<p>The general usage of the feature is: <code>$alias=cmd</code></p>
<pre><code>[0x00404800]&gt; $disas=pdf
</code></pre>
<p>The above command will create an alias <code>disas</code> for <code>pdf</code>. The following command prints the disassembly of the main function.</p>
<pre><code>[0x00404800]&gt; $disas @ main
</code></pre>
<p>Apart from commands, you can also alias a text to be printed, when called.</p>
<pre><code>[0x00404800]&gt; $my_alias=$test input
[0x00404800]&gt; $my_alias
test input
</code></pre>
<p>To undefine alias, use <code>$alias=</code>:</p>
<pre><code>[0x00404800]&gt; $pmore='b 300;px'
[0x00404800]&gt; $
$pmore
[0x00404800]&gt; $pmore=
[0x00404800]&gt; $

</code></pre>
<p>A single <code>$</code> in the above will list all defined aliases. It's also possible check the aliased command of an alias:</p>
<pre><code>[0x00404800]&gt; $pmore?
b 200; px
</code></pre>
<p>Can we create an alias contains alias ? The answer is yes:</p>
<pre><code>[0x00404800]&gt; $pStart='s 0x0;$pmore'
[0x00404800]&gt; $pStart
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x00000000  7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
0x00000010  0300 3e00 0100 0000 1014 0000 0000 0000  ..&gt;.............
0x00000020  4000 0000 0000 0000 5031 0000 0000 0000  @.......P1......
0x00000030  0000 0000 4000 3800 0d00 4000 1e00 1d00  ....@.8...@.....
0x00000040  0600 0000 0400 0000 4000 0000 0000 0000  ........@.......
0x00000050  4000 0000 0000 0000 4000 0000 0000 0000  @.......@.......
0x00000060  d802 0000 0000 0000 d802 0000 0000 0000  ................
0x00000070  0800 0000 0000 0000 0300 0000 0400 0000  ................
0x00000080  1803 0000 0000 0000 1803 0000 0000 0000  ................
0x00000090  1803 0000 0000 0000 1c00 0000 0000 0000  ................
0x000000a0  1c00 0000 0000 0000 0100 0000 0000 0000  ................
0x000000b0  0100 0000 0400 0000 0000 0000 0000 0000  ................
0x000000c0  0000 0000 0000 0000                      ........
[0x00000000]&gt; 
</code></pre>
<h1 id="rz-pipe"><a class="header" href="#rz-pipe">Rz-pipe</a></h1>
<p>The rz-pipe module permits interacting with rizin instances in different methods:</p>
<ul>
<li>spawn pipes (rizin -0)</li>
<li>http queries (cloud friendly)</li>
<li>tcp socket (rizin -c)</li>
</ul>
<pre><code>         pipe spawn async http tcp rap json
python    x     x     -    x    x    x   x
haskell   x     x     -    x    -    -   x
ocaml     x     x     -    x    -    -   x
rust      x     x     x    x    -    -   x
</code></pre>
<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<pre><code>$ pip install rz-pipe
</code></pre>
<pre><code class="language-python">import rzpipe

rz = rz-pipe.open(&quot;/bin/ls&quot;)
rz.cmd('aa')
print(rz.cmd(&quot;afl&quot;))
print(rz.cmdj(&quot;aflj&quot;))  # evaluates JSONs and returns an object
</code></pre>
<h2 id="haskell"><a class="header" href="#haskell">Haskell</a></h2>
<pre><code class="language-haskell">import RzPipe
import qualified Data.ByteString.Lazy as L

showMainFunction ctx = do
  cmd ctx &quot;s main&quot;
  L.putStr =&lt;&lt; cmd ctx &quot;pD `fl $$`&quot;

main = do
  -- Run rizin locally
  open &quot;/bin/ls&quot; &gt;&gt;= showMainFunction
  -- Connect to rizin via HTTP (e.g. if &quot;rizin -qc=h /bin/ls&quot; is running)
  open &quot;http://127.0.0.1:9090&quot; &gt;&gt;= showMainFunction
</code></pre>
<h2 id="ocaml"><a class="header" href="#ocaml">OCaml</a></h2>
<pre><code class="language-ocaml">let result = Rz.with_command ~cmd:&quot;/j chown&quot; &quot;/bin/ls&quot;
Printf.printf &quot;Rizin output is: %s&quot; result
</code></pre>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<pre><pre class="playground"><code class="language-rust"> #[macro_use]
 extern crate rzpipe;
 extern crate serde_json;
 use rzpipe::RzPipe;
 fn main() {
     let path = Some(&quot;/bin/ls&quot;.to_owned());
     let mut rzp = open_pipe!(path).unwrap();
     println!(&quot;{}&quot;, rzp.cmd(&quot;?e Hello World&quot;).unwrap());
     if let Ok(json) = rzp.cmdj(&quot;ij&quot;) {
         println!(&quot;{}&quot;, serde_json::to_string_pretty(&amp;json).unwrap());
         println!(&quot;ARCH {}&quot;, json[&quot;bin&quot;][&quot;arch&quot;]);
     }
     rzp.close();
 }
</code></pre></pre>
<h2 id="ruby"><a class="header" href="#ruby">Ruby</a></h2>
<pre><code class="language-ruby">require './rzpipe'

begin
  rzp = RzPipe.new
rescue Exception =&gt; e
  rzp = RzPipe.new '/bin/ls'
end
  puts rzp.cmd 'a'
  puts rzp.cmd 'pd 10 main'
  rzp.quit
</code></pre>
<h1 id="debugger"><a class="header" href="#debugger">Debugger</a></h1>
<p>Debuggers are implemented as IO plugins. Therefore, rizin can handle different URI types for spawning, attaching and controlling processes. The complete list of IO plugins can be viewed with <code>rizin -L</code>. Those that have &quot;d&quot; in the first column (&quot;rwd&quot;) support debugging. For example:</p>
<pre><code>r_d  debug       Debug a program or pid. dbg:///bin/ls, dbg://1388 (LGPL3)
rwd  gdb         Attach to gdbserver, 'qemu -s', gdb://localhost:1234 (LGPL3)
</code></pre>
<p>There are different backends for many target architectures and operating systems, e.g., GNU/Linux, Windows, MacOS X, (Net,Free,Open)BSD and Solaris.</p>
<p>Process memory is treated as a plain file. All mapped memory pages of a debugged program and its libraries can be read and interpreted as code or data structures.</p>
<p>Communication between rizin and the debugger IO layer is wrapped into <code>system()</code> calls, which accept a string as an argument, and executes it as a command. An answer is then buffered in the output console, its contents can be additionally processed by a script. Access to the IO system is achieved with <code>R!</code>. Most IO plugins provide help with <code>R!?</code> or <code>R!help</code>. For example:</p>
<pre><code>$ rizin -d /bin/ls
...
[0x7fc15afa3cc0]&gt; R!help
Usage: R!cmd args
 R!ptrace   - use ptrace io
 R!mem      - use /proc/pid/mem io if possible
 R!pid      - show targeted pid
 R!pid &lt;#&gt;  - select new pid
</code></pre>
<p>In general, debugger commands are portable between architectures and operating systems. Still, as rizin tries to support the same functionality for all target architectures and operating systems, certain things have to be handled separately. They include injecting shellcodes and handling exceptions. For example, in MIPS targets there is no hardware-supported single-stepping feature. In this case, rizin provides its own implementation for single-step by using a mix of code analysis and software breakpoints.</p>
<p>To get basic help for the debugger, type 'd?':</p>
<pre><code>Usage: d   # Debug commands
| db[?]                    Breakpoints commands
| dbt[?]                   Display backtrace based on dbg.btdepth and dbg.btalgo
| dc[?]                    Continue execution
| dd[?]                    File descriptors (!fd in r1)
| de[-sc] [perm] [rm] [e]  Debug with ESIL (see de?)
| dg &lt;file&gt;                Generate a core-file (WIP)
| dH [handler]             Transplant process to a new handler
| di[?]                    Show debugger backend information (See dh)
| dk[?]                    List, send, get, set, signal handlers of child
| dL[?]                    List or set debugger handler
| dm[?]                    Show memory maps
| do[?]                    Open process (reload, alias for 'oo')
| doo[args]                Reopen in debug mode with args (alias for 'ood')
| doof[file]               Reopen in debug mode from file (alias for 'oodf')
| doc                      Close debug session
| dp[?]                    List, attach to process or thread id
| dr[?]                    Cpu registers
| ds[?]                    Step, over, source line
| dt[?]                    Display instruction traces
| dw &lt;pid&gt;                 Block prompt until pid dies
| dx[?]                    Inject and run code on target process (See gs)
</code></pre>
<p>To restart your debugging session, you can type <code>oo</code> or <code>oo+</code>, depending on desired behavior.</p>
<pre><code>oo                 reopen current file (kill+fork in debugger)
oo+                reopen current file in read-write
</code></pre>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="small-session-in-rizin-debugger"><a class="header" href="#small-session-in-rizin-debugger">Small session in rizin debugger</a></h2>
<ul>
<li>
<p><code>rizin -d /bin/ls</code>: Opens rizin with file <code>/bin/ls</code> in debugger mode using the rizin native debugger, but does not run the program. You’ll see a prompt (rizin) - all examples are from this prompt.</p>
</li>
<li>
<p><code>db flag</code>: place a breakpoint at flag, where flag can be either an address or a function name</p>
</li>
<li>
<p><code>db - flag</code>: remove the breakpoint at flag, where flag can be either an address or a function name</p>
</li>
<li>
<p><code>db</code>: show list of breakpoint</p>
</li>
<li>
<p><code>dc</code>: run the program</p>
</li>
<li>
<p><code>dr</code>: Show registers state</p>
</li>
<li>
<p><code>drr</code>: Show registers references (telescoping) (like peda)</p>
</li>
<li>
<p><code>ds</code>: Step into instruction</p>
</li>
<li>
<p><code>dso</code>: Step over instruction</p>
</li>
<li>
<p><code>dbt</code>: Display backtrace</p>
</li>
<li>
<p><code>dm</code>: Show memory maps</p>
</li>
<li>
<p><code>dk &lt;signal&gt;</code>: Send KILL signal to child</p>
</li>
<li>
<p><code>ood</code>: reopen in debug mode</p>
</li>
<li>
<p><code>ood arg1 arg2</code>: reopen in debug mode with arg1 and arg2</p>
</li>
</ul>
<h1 id="migration-from-ida-gdb-or-windbg"><a class="header" href="#migration-from-ida-gdb-or-windbg">Migration from ida, GDB or WinDBG</a></h1>
<h2 id="how-to-run-the-program-using-the-debugger"><a class="header" href="#how-to-run-the-program-using-the-debugger">How to run the program using the debugger</a></h2>
<p><code>rizin -d /bin/ls</code> - start in debugger mode =&gt; [<a href="http://asciinema.org/a/12022">video</a>]</p>
<h2 id="how-do-i-attachdetach-to-running-process--gdb--p"><a class="header" href="#how-do-i-attachdetach-to-running-process--gdb--p">How do I attach/detach to running process ? (gdb -p)</a></h2>
<p><code>rizin -d &lt;pid&gt;</code> - attach to process</p>
<p><code>rizin ptrace://pid</code> - same as above, but only for io (not debugger backend hooked)</p>
<p><code>[0x7fff6ad90028]&gt; o-225</code> - close fd=225 (listed in <code>o~[1]:0</code>)</p>
<p><code>rizin -D gdb gdb://localhost:1234</code> - attach to gdbserver</p>
<h2 id="how-to-set-argsenvironment-variableload-a-specific-libraries-for-the-debugging-session-of-rizin"><a class="header" href="#how-to-set-argsenvironment-variableload-a-specific-libraries-for-the-debugging-session-of-rizin">How to set args/environment variable/load a specific libraries for the debugging session of rizin</a></h2>
<p>Use <code>rz-run</code> (<code>libpath=$PWD:/tmp/lib</code>, <code>arg2=hello</code>, <code>setenv=FOO=BAR</code> ...) see <code>rz-run -h</code> / <code>man rz-run</code></p>
<h2 id="how-to-script-rizin-"><a class="header" href="#how-to-script-rizin-">How to script rizin ?</a></h2>
<p><code>rizin -i &lt;scriptfile&gt; ...</code> - run a script <strong>after</strong> loading the file =&gt; [<a href="http://asciinema.org/a/12020">video</a>]</p>
<p><code>rizin -I &lt;scriptfile&gt; ...</code> - run a script <strong>before</strong> loading the file</p>
<p><code>rizin -c $@ | awk $@</code>  - run through awk to get asm from function =&gt; [<a href="http://sprunge.us/dEOK">link</a>]</p>
<p><code>[0x80480423]&gt; . scriptfile</code> - interpret this file =&gt; [<a href="http://asciinema.org/a/12017">video</a>]</p>
<p><code>[0x80480423]&gt; #!c</code> - enter C repl  (see <code>#!</code> to list all available RLang plugins)  =&gt; [<a href="http://asciinema.org/a/12019">video</a>], everything have to be done in a oneliner or a .c file must be passed as an argument.</p>
<p>To get <code>#!python</code> and much more, just build <a href="https://github.com/rizinorg/rizin-bindings">rizin-bindings</a></p>
<h2 id="how-to-list-source-code-as-in-gdb-list-"><a class="header" href="#how-to-list-source-code-as-in-gdb-list-">How to list Source code as in gdb list ?</a></h2>
<p><code>CL @ sym.main</code> - though the feature is highly experimental</p>
<h1 id="shortcuts"><a class="header" href="#shortcuts">shortcuts</a></h1>
<table><thead><tr><th>Command</th><th>IDA Pro</th><th>rizin</th><th>rizin (visual mode)</th><th>GDB</th><th>WinDbg</th></tr></thead><tbody>
<tr><td><strong>Analysis</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Analysis of everything</td><td><code>Automatically launched when opening a binary</code></td><td><code>aaa or -A (aaaa or -AA for even experimental analysis)</code></td><td><code>N/A</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td><strong>Navigation</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>xref to</td><td><code>x</code></td><td><code>axt</code></td><td><code>x</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>xref from</td><td><code>ctrl + j</code></td><td><code>axf</code></td><td><code>X</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>xref to graph</td><td>?</td><td><code>agt [offset]</code></td><td>?</td><td>N/A</td><td>N/A</td></tr>
<tr><td>xref from graph</td><td>?</td><td><code>agf [offset]</code></td><td>?</td><td>N/A</td><td>N/A</td></tr>
<tr><td>list functions</td><td><code>alt + 1</code></td><td><code>afl;is</code></td><td><code>t</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>listing</td><td><code>alt + 2</code></td><td><code>pdf</code></td><td><code>p</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>hex mode</td><td><code>alt + 3</code></td><td><code>pxa</code></td><td><code>P</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>imports</td><td><code>alt + 6</code></td><td><code>ii</code></td><td><code>:ii</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>exports</td><td><code>alt + 7</code></td><td><code>is~FUNC</code></td><td>?</td><td>N/A</td><td>N/A</td></tr>
<tr><td>follow jmp/call</td><td><code>enter</code></td><td><code>s offset</code></td><td><code>enter</code> or <code>0</code>-<code>9</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>undo seek</td><td><code>esc</code></td><td><code>shu</code></td><td><code>u</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>redo seek</td><td><code>ctrl+enter</code></td><td><code>shr</code></td><td><code>U</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>show graph</td><td><code>space</code></td><td><code>agv</code></td><td><code>V</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td><strong>Edit</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>rename</td><td><code>n</code></td><td><code>afn</code></td><td><code>dr</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>graph view</td><td><code>space</code></td><td><code>agv</code></td><td><code>V</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as data</td><td><code>d</code></td><td><code>Cd [size]</code></td><td><code>dd</code>,<code>db</code>,<code>dw</code>,<code>dW</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as code</td><td><code>c</code></td><td><code>C- [size]</code></td><td><code>d-</code> or <code>du</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as undefined</td><td><code>u</code></td><td><code>C- [size]</code></td><td><code>d-</code> or <code>du</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as string</td><td><code>A</code></td><td><code>Cs [size]</code></td><td><code>ds</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as struct</td><td><code>Alt+Q</code></td><td><code>Cf [size]</code></td><td><code>dF</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td><strong>Debugger</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Start Process/ Continue execution</td><td><code>F9</code></td><td><code>dc</code></td><td><code>F9</code></td><td><code>r</code> and <code>c</code></td><td><code>g</code></td></tr>
<tr><td>Terminate Process</td><td><code>Ctrl+F2</code></td><td><code>dk 9</code></td><td>?</td><td><code>kill</code></td><td><code>q</code></td></tr>
<tr><td>Detach</td><td><code>?</code></td><td><code>o-</code></td><td>?</td><td><code>detach</code></td><td></td></tr>
<tr><td>step into</td><td><code>F7</code></td><td><code>ds</code></td><td><code>s</code></td><td><code>n</code></td><td><code>t</code></td></tr>
<tr><td>step into 4 instructions</td><td>?</td><td><code>ds 4</code></td><td>F7</td><td><code>n 4</code></td><td><code>t 4</code></td></tr>
<tr><td>step over</td><td><code>F8</code></td><td><code>dso</code></td><td><code>S</code></td><td><code>s</code></td><td><code>p</code></td></tr>
<tr><td>step until a specific address</td><td>?</td><td><code>dsu &lt;addr&gt;</code></td><td>?</td><td><code>s</code></td><td><code>g &lt;addr&gt;</code></td></tr>
<tr><td>Run until return</td><td><code>Ctrl+F7</code></td><td><code>dcr</code></td><td>?</td><td><code>finish</code></td><td><code>gu</code></td></tr>
<tr><td>Run until cursor</td><td><code>F4</code></td><td><a href="https://github.com/rizinorg/rizin/issues/249">#249</a></td><td><a href="https://github.com/rizinorg/rizin/issues/249">#249</a></td><td>N/A</td><td>N/A</td></tr>
<tr><td>Show Backtrace</td><td><code>?</code></td><td><code>dbt</code></td><td>?</td><td><code>bt</code></td><td></td></tr>
<tr><td>display Register</td><td>On register Windows</td><td><code>dr all</code></td><td>Shown in Visual mode</td><td><code>info registers</code></td><td><code>r</code></td></tr>
<tr><td>display eax</td><td>On register Windows</td><td><code>dr?eax</code></td><td>Shown in Visual mode</td><td><code>info registers eax</code></td><td><code>r rax</code></td></tr>
<tr><td>display old state of all registers</td><td>?</td><td><code>dro</code></td><td>?</td><td>?</td><td>?</td></tr>
<tr><td>display function addr + N</td><td>?</td><td><code>afi $$</code> - display function information of current offset (<code>$$</code>)</td><td>?</td><td>?</td><td>?</td></tr>
<tr><td>display frame state</td><td>?</td><td><code>pxw rbp-rsp@rsp</code></td><td>?</td><td><code>i f</code></td><td>?</td></tr>
<tr><td>How to step until condition is true</td><td>?</td><td><code>dsi</code></td><td>?</td><td>?</td><td>?</td></tr>
<tr><td>Update a register value</td><td>?</td><td><code>dr rip=0x456</code></td><td>?</td><td><code>set $rip=0x456</code></td><td><code>r rip=456</code></td></tr>
<tr><td><strong>Disassembly</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>disassembly forward</td><td>N/A</td><td><code>pd</code></td><td><code>Vp</code></td><td><code>disas</code></td><td><code>uf</code>, <code>u</code></td></tr>
<tr><td>disassembly N instructions</td><td>N/A</td><td><code>pd X</code></td><td>Vp</td><td>x/<N>i</td><td><code>u &lt;addr&gt; LX</code></td></tr>
<tr><td>disassembly N (backward)</td><td>N/A</td><td><code>pd -X</code></td><td><code>Vp</code></td><td><code>disas &lt;a-o&gt; &lt;a&gt;</code></td><td><code>ub</code></td></tr>
<tr><td><strong>Information on the bin</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Sections/regions</td><td><code>Menu sections</code></td><td><code>iS</code> or <code>S</code> (append j for json)</td><td>N/A</td><td>maint info sections</td><td>!address</td></tr>
<tr><td><strong>Load symbol file</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Sections/regions</td><td><code>pdb menu</code></td><td><code>asm.dwarf.file</code>, <code>pdb.XX</code>)</td><td>N/A</td><td>add-symbol-file</td><td>r</td></tr>
<tr><td><strong>BackTrace</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Stack Trace</td><td>N/A</td><td><code>dbt</code></td><td>N/A</td><td><code>bt</code></td><td><code>k</code></td></tr>
<tr><td>Stack Trace in Json</td><td>N/A</td><td><code>dbtj</code></td><td>N/A</td><td></td><td></td></tr>
<tr><td>Partial Backtrace (innermost)</td><td>N/A</td><td><code>dbt</code> (<code>dbg.btdepth</code> <code>dbg.btalgo</code>)</td><td>N/A</td><td>bt <N></td><td>k <N></td></tr>
<tr><td>Partial Backtrace (outermost)</td><td>N/A</td><td><code>dbt</code> (<code>dbg.btdepth</code> <code>dbg.btalgo</code>)</td><td>N/A</td><td>bt -<N></td><td></td></tr>
<tr><td>Stacktrace for all threads</td><td>N/A</td><td><code>dbt@t</code></td><td>N/A</td><td><code>thread apply all bt</code></td><td><code>~* k</code></td></tr>
<tr><td><strong>Breakpoints</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Breakpoint list</td><td><code>Ctrl+Alt+B</code></td><td><code>db</code></td><td>?</td><td><code>info breakpoints</code></td><td><code>bl</code></td></tr>
<tr><td>add breakpoint</td><td><code>F2</code></td><td><code>db [offset]</code></td><td><code>F2</code></td><td><code>break</code></td><td><code>bp</code></td></tr>
<tr><td><strong>Threads</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Switch to thread</td><td><code>Thread menu</code></td><td><code>dp</code></td><td>N/A</td><td><code>thread &lt;N&gt;</code></td><td><code>~&lt;N&gt;s</code></td></tr>
<tr><td><strong>Frames</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Frame Numbers</td><td><code>N/A</code></td><td><code>?</code></td><td>N/A</td><td><code>any bt command</code></td><td><code>kn</code></td></tr>
<tr><td>Select Frame</td><td><code>N/A</code></td><td><code>?</code></td><td>N/A</td><td><code>frame</code></td><td><code>.frame</code></td></tr>
<tr><td><strong>Parameters/Locals</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Display parameters</td><td><code>N/A</code></td><td><code>afv</code></td><td>N/A</td><td><code>info args</code></td><td><code>dv /t /i /V</code></td></tr>
<tr><td>Display parameters</td><td><code>N/A</code></td><td><code>afv</code></td><td>N/A</td><td><code>info locals</code></td><td><code>dv /t /i /V</code></td></tr>
<tr><td>Display parameters/locals in json</td><td><code>N/A</code></td><td><code>afvj</code></td><td>N/A</td><td><code>info locals</code></td><td><code>dv /t /i /V</code></td></tr>
<tr><td>list addresses where vars are accessed(R/W)</td><td><code>N/A</code></td><td><code>afvR/afvW</code></td><td>N/A</td><td><code>?</code></td><td><code>?</code></td></tr>
<tr><td><strong>Project Related</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>open project</td><td></td><td><code>Po [file]</code></td><td></td><td>?</td><td></td></tr>
<tr><td>save project</td><td>automatic</td><td><code>Ps [file]</code></td><td></td><td>?</td><td></td></tr>
<tr><td>show project information</td><td></td><td><code>Pi [file]</code></td><td></td><td>?</td><td></td></tr>
<tr><td><strong>Miscellaneous</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Dump byte char array</td><td><code>N/A</code></td><td><code>pc?</code> (json, C, char, etc.)</td><td>Vpppp</td><td>x/<N>bc</td><td>db</td></tr>
<tr><td>options</td><td>option menu</td><td><code>e?</code></td><td><code>e</code></td><td></td><td></td></tr>
<tr><td>search</td><td>search menu</td><td><code>/?</code></td><td>Select the zone with the cursor <code>c</code> then <code>/</code></td><td></td><td><code>s</code></td></tr>
</tbody></table>
<h2 id="equivalent-of-set-follow-fork-mode-gdb-command"><a class="header" href="#equivalent-of-set-follow-fork-mode-gdb-command">Equivalent of &quot;set-follow-fork-mode&quot; gdb command</a></h2>
<p>This can be done in two ways:</p>
<ol>
<li>Use the configuration variable <code>dbg.follow.child</code> to choose the process (parent or child) you want to follow.</li>
<li>Use <code>dcf</code> to debug until a fork and then use <code>dp</code> to select what process you want to debug.</li>
</ol>
<h1 id="common-features"><a class="header" href="#common-features">Common features</a></h1>
<ul>
<li>rizin accepts FLIRT signatures</li>
<li>rizin can connect to GDB, LLVM and WinDbg</li>
<li>rizin can write/patch in place</li>
<li>rizin have fortunes and [s]easter eggs[/s]balls of steel</li>
<li>rizin can do basic loading of ELF core files from the box and MDMP (Windows minidumps)</li>
</ul>
<h1 id="registers"><a class="header" href="#registers">Registers</a></h1>
<p>The registers are part of a user area stored in the context structure used by the scheduler. This structure can be manipulated to get and set the values of those registers, and, for example, on Intel hosts, it is possible to directly manipulate DR0-DR7 hardware registers to set hardware breakpoints.</p>
<p>There are different commands to get values of registers. For the General Purpose ones use:</p>
<pre><code>[0x4A13B8C0]&gt; dr
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x00000000
oeax = 0x0000003b
rip = 0x7f20bf5df630
rsp = 0x7fff515923c0

[0x7f0f2dbae630]&gt; dr rip ; get value of 'rip'
0x7f0f2dbae630

[0x4A13B8C0]&gt; dr rip = esp   ; set 'rip' as esp
</code></pre>
<p>Interaction between a plugin and the core is done by commands returning rizin instructions. This is used, for example, to set flags in the core to set  values of registers.</p>
<pre><code>[0x7f0f2dbae630]&gt; dr*      ; Appending '*' will show rizin commands
f r15 1 0x0
f r14 1 0x0
f r13 1 0x0
f r12 1 0x0
f rbp 1 0x0
f rbx 1 0x0
f r11 1 0x0
f r10 1 0x0
f r9 1 0x0
f r8 1 0x0
f rax 1 0x0
f rcx 1 0x0
f rdx 1 0x0
f rsi 1 0x0
f rdi 1 0x0
f oeax 1 0x3b
f rip 1 0x7fff73557940
f rflags 1 0x200
f rsp 1 0x7fff73557940

[0x4A13B8C0]&gt; .dr*  ; include common register values in flags
</code></pre>
<p>An old copy of registers is stored all the time to keep track of the changes done during execution of a program being analyzed. This old copy can be accessed with <code>oregs</code>.</p>
<pre><code>[0x7f1fab84c630]&gt; dro
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x00000000
oeax = 0x0000003b
rip = 0x7f1fab84c630
rflags = 0x00000200
rsp = 0x7fff386b5080
</code></pre>
<p>Current state of registers</p>
<pre><code>[0x7f1fab84c630]&gt; dr
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x7fff386b5080
oeax = 0xffffffffffffffff
rip = 0x7f1fab84c633
rflags = 0x00000202
rsp = 0x7fff386b5080
</code></pre>
<p>Values stored in eax, oeax and eip have changed.</p>
<p>To store and restore register values you can just dump the output of 'dr*' command to disk and then re-interpret it again:</p>
<pre><code>[0x4A13B8C0]&gt; dr* &gt; regs.saved ; save registers
[0x4A13B8C0]&gt; drp regs.saved ; restore
</code></pre>
<p>EFLAGS can be similarly altered. E.g., setting selected flags:</p>
<pre><code>[0x4A13B8C0]&gt; dr eflags = pst
[0x4A13B8C0]&gt; dr eflags = azsti
</code></pre>
<p>You can get a string which represents latest changes of registers using <code>drd</code> command (diff registers):</p>
<pre><code>[0x4A13B8C0]&gt; drd
oeax = 0x0000003b was 0x00000000 delta 59
rip = 0x7f00e71282d0 was 0x00000000 delta -418217264
rflags = 0x00000200 was 0x00000000 delta 512
rsp = 0x7fffe85a09c0 was 0x00000000 delta -396752448
</code></pre>
<h1 id="memory-maps"><a class="header" href="#memory-maps">Memory Maps</a></h1>
<p>The ability to understand and manipulate the memory maps of a debugged program is important for many different Reverse Engineering tasks. rizin offers a rich set of commands to handle memory maps in the binary. This includes listing the memory maps of the currently debugged binary, removing memory maps, handling loaded libraries and more.</p>
<p>First, let's see the help message for <code>dm</code>, the command which is responsible for handling memory maps:</p>
<pre><code>[0x55f2104cf620]&gt; dm?
Usage: dm   # Memory maps commands
| dm                               List memory maps of target process
| dm address size                  Allocate &lt;size&gt; bytes at &lt;address&gt; (anywhere if address is -1) in child process
| dm=                              List memory maps of target process (ascii-art bars)
| dm.                              Show map name of current address
| dm*                              List memmaps in rizin commands
| dm- address                      Deallocate memory map of &lt;address&gt;
| dmd[a] [file]                    Dump current (all) debug map region to a file (from-to.dmp) (see Sd)
| dmh[?]                           Show map of heap
| dmi [addr|libname] [symname]     List symbols of target lib
| dmi* [addr|libname] [symname]    List symbols of target lib in rizin commands
| dmi.                             List closest symbol to the current address
| dmiv                             Show address of given symbol for given lib
| dmj                              List memmaps in JSON format
| dml &lt;file&gt;                       Load contents of file into the current map region
| dmm[?][j*]                       List modules (libraries, binaries loaded in memory)
| dmp[?] &lt;address&gt; &lt;size&gt; &lt;perms&gt;  Change page at &lt;address&gt; with &lt;size&gt;, protection &lt;perms&gt; (perm)
| dms[?] &lt;id&gt; &lt;mapaddr&gt;            Take memory snapshot
| dms- &lt;id&gt; &lt;mapaddr&gt;              Restore memory snapshot
| dmS [addr|libname] [sectname]    List sections of target lib
| dmS* [addr|libname] [sectname]   List sections of target lib in rizin commands
| dmL address size                 Allocate &lt;size&gt; bytes at &lt;address&gt; and promote to huge page
</code></pre>
<p>In this chapter, we'll go over some of the most useful subcommands of <code>dm</code> using simple examples. For the following examples, we'll use a simple <code>helloworld</code> program for Linux but it'll be the same for every binary.</p>
<p>First things first - open a program in debugging mode:</p>
<pre><code>$ rizin -d helloworld
Process with PID 20304 started...
= attach 20304 20304
bin.baddr 0x56136b475000
Using 0x56136b475000
asm.bits 64
[0x7f133f022fb0]&gt;
</code></pre>
<blockquote>
<p>Note that we passed &quot;helloworld&quot; to rizin without &quot;./&quot;. rizin will try to find this program in the current directory and then in $PATH, even if no &quot;./&quot; is passed. This is contradictory with UNIX systems, but makes the behaviour consistent for windows users</p>
</blockquote>
<p>Let's use <code>dm</code> to print the memory maps of the binary we've just opened:</p>
<pre><code>[0x7f133f022fb0]&gt; dm
0x0000563a0113a000 - usr   4K s r-x /tmp/helloworld /tmp/helloworld ; map.tmp_helloworld.r_x
0x0000563a0133a000 - usr   8K s rw- /tmp/helloworld /tmp/helloworld ; map.tmp_helloworld.rw
0x00007f133f022000 * usr 148K s r-x /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.r_x
0x00007f133f246000 - usr   8K s rw- /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.rw
0x00007f133f248000 - usr   4K s rw- unk0 unk0 ; map.unk0.rw
0x00007fffd25ce000 - usr 132K s rw- [stack] [stack] ; map.stack_.rw
0x00007fffd25f6000 - usr  12K s r-- [vvar] [vvar] ; map.vvar_.r
0x00007fffd25f9000 - usr   8K s r-x [vdso] [vdso] ; map.vdso_.r_x
0xffffffffff600000 - usr   4K s r-x [vsyscall] [vsyscall] ; map.vsyscall_.r_x
</code></pre>
<p>For those of you who prefer a more visual way, you can use <code>dm=</code> to see the memory maps using an ASCII-art bars. This will be handy when you want to see how these maps are located in the memory.</p>
<p>If you want to know the memory-map you are currently in, use <code>dm.</code>:</p>
<pre><code>[0x7f133f022fb0]&gt; dm.
0x00007f947eed9000 # 0x00007f947eefe000 * usr   148K s r-x /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.r_x
</code></pre>
<p>Using <code>dmm</code> we can &quot;List modules (libraries, binaries loaded in memory)&quot;, this is quite a handy command to see which modules were loaded.</p>
<pre><code>[0x7fa80a19dfb0]&gt; dmm
0x55ca23a4a000 /tmp/helloworld
0x7fa80a19d000 /usr/lib/ld-2.27.so
</code></pre>
<blockquote>
<p>Note that the output of <code>dm</code> subcommands, and <code>dmm</code> specifically, might be different in various systems and different binaries.</p>
</blockquote>
<p>We can see that along with our <code>helloworld</code> binary itself, another library was loaded which is <code>ld-2.27.so</code>. We don't see <code>libc</code> yet and this is because rizin breaks before <code>libc</code> is loaded to memory. Let's use <code>dcu</code> (<strong>d</strong>ebug <strong>c</strong>ontinue <strong>u</strong>ntil) to execute our program until the entry point of the program, which rizin flags as <code>entry0</code>.</p>
<pre><code>[0x7fa80a19dfb0]&gt; dcu entry0
Continue until 0x55ca23a4a520 using 1 bpsize
hit breakpoint at: 55ca23a4a518
[0x55ca23a4a520]&gt; dmm
0x55ca23a4a000 /tmp/helloworld
0x7fa809de1000 /usr/lib/libc-2.27.so
0x7fa80a19d000 /usr/lib/ld-2.27.so
</code></pre>
<p>Now we can see that <code>libc-2.27.so</code> was loaded as well, great!</p>
<p>Speaking of <code>libc</code>, a popular task for binary exploitation is to find the address of a specific symbol in a library. With this information in hand, you can build, for example, an exploit which uses ROP. This can be achieved using the <code>dmi</code> command. So if we want, for example, to find the address of <a href="http://man7.org/linux/man-pages/man3/system.3.html"><code>system()</code></a> in the loaded <code>libc</code>, we can simply execute the following command:</p>
<pre><code>[0x55ca23a4a520]&gt; dmi libc system
514 0x00000000 0x7fa809de1000  LOCAL  FILE    0 system.c
515 0x00043750 0x7fa809e24750  LOCAL  FUNC 1221 do_system
4468 0x001285a0 0x7fa809f095a0 LOCAL  FUNC  100 svcerr_systemerr
5841 0x001285a0 0x7fa809f095a0 LOCAL  FUNC  100 svcerr_systemerr
6427 0x00043d10 0x7fa809e24d10  WEAK  FUNC   45 system
7094 0x00043d10 0x7fa809e24d10 GLBAL  FUNC   45 system
7480 0x001285a0 0x7fa809f095a0 GLBAL  FUNC  100 svcerr_systemerr
</code></pre>
<p>Similar to the <code>dm.</code> command, with <code>dmi.</code> you can see the closest symbol to the current address.</p>
<p>Another useful command is to list the sections of a specific library. In the following example we'll list the sections of <code>ld-2.27.so</code>:</p>
<pre><code>[0x55a7ebf09520]&gt; dmS ld-2.27
[Sections]
00 0x00000000     0 0x00000000     0 ---- ld-2.27.so.
01 0x000001c8    36 0x4652d1c8    36 -r-- ld-2.27.so..note.gnu.build_id
02 0x000001f0   352 0x4652d1f0   352 -r-- ld-2.27.so..hash
03 0x00000350   412 0x4652d350   412 -r-- ld-2.27.so..gnu.hash
04 0x000004f0   816 0x4652d4f0   816 -r-- ld-2.27.so..dynsym
05 0x00000820   548 0x4652d820   548 -r-- ld-2.27.so..dynstr
06 0x00000a44    68 0x4652da44    68 -r-- ld-2.27.so..gnu.version
07 0x00000a88   164 0x4652da88   164 -r-- ld-2.27.so..gnu.version_d
08 0x00000b30  1152 0x4652db30  1152 -r-- ld-2.27.so..rela.dyn
09 0x00000fb0 11497 0x4652dfb0 11497 -r-x ld-2.27.so..text
10 0x0001d0e0 17760 0x4654a0e0 17760 -r-- ld-2.27.so..rodata
11 0x00021640  1716 0x4654e640  1716 -r-- ld-2.27.so..eh_frame_hdr
12 0x00021cf8  9876 0x4654ecf8  9876 -r-- ld-2.27.so..eh_frame
13 0x00024660  2020 0x46751660  2020 -rw- ld-2.27.so..data.rel.ro
14 0x00024e48   336 0x46751e48   336 -rw- ld-2.27.so..dynamic
15 0x00024f98    96 0x46751f98    96 -rw- ld-2.27.so..got
16 0x00025000  3960 0x46752000  3960 -rw- ld-2.27.so..data
17 0x00025f78     0 0x46752f80   376 -rw- ld-2.27.so..bss
18 0x00025f78    17 0x00000000    17 ---- ld-2.27.so..comment
19 0x00025fa0    63 0x00000000    63 ---- ld-2.27.so..gnu.warning.llseek
20 0x00025fe0 13272 0x00000000 13272 ---- ld-2.27.so..symtab
21 0x000293b8  7101 0x00000000  7101 ---- ld-2.27.so..strtab
22 0x0002af75   215 0x00000000   215 ---- ld-2.27.so..shstrtab
</code></pre>
<h1 id="heap"><a class="header" href="#heap">Heap</a></h1>
<p>rizin's <code>dm</code> subcommands can also display a map of the heap which is useful for those who are interested in inspecting the heap and its content. Simply execute <code>dmh</code> to show a map of the heap:</p>
<pre><code>[0x55c392ae1189]&gt; dmh
Arena @ 0x7f10940c1b80
Chunk(status=free,      addr=0x55c3934c9290, size=0x50, flags=PREV_INUSE)
Chunk(status=allocated, addr=0x55c3934c92e0, size=0x90, flags=PREV_INUSE)
Chunk(status=free,      addr=0x55c3934c9370, size=0x20c90, flags=PREV_INUSE)[top][brk_start: 0x55c3934c9000, brk_end: 0x55c3934ea000]]
</code></pre>
<p>You can also see a graph layout of the heap:</p>
<pre><code>[0x7fae46236ca6]&gt; dmhg
Arena @ 0x7f10940c1b80
Heap Layout
┌────────────────────────────────────┐
│    Malloc chunk @ 0x55c3934c9290   │
│ size: 0x50 status: free            │
└────────────────────────────────────┘
    v
    │
    │
┌────────────────────────────────────┐
│    Malloc chunk @ 0x55c3934c92e0   │
│ size: 0x90 status: allocated       │
└────────────────────────────────────┘
    v
    │
    └──┐
       │
   ┌───────────────────────────────┐
   │  Top chunk @ 0x55c3934c9370   │
   └───────────────────────────────┘
</code></pre>
<p>To get information about bins of the main arena use the <code>dmhd</code> command.</p>
<pre><code>[0x55c392ae1189]&gt; dmhd
Tcache bins in Main Arena @ 0x7f10940c1b80
Tcache_bin[03] Items: 1
 -&gt; Chunk(addr=0x55c3934c9290, size=0x50, flags=PREV_INUSE)

Fast bins in Arena @ 0x7f10940c1b80
Fast_bin[01] [size: 0x20] Empty bin
Fast_bin[02] [size: 0x30] Empty bin
Fast_bin[03] [size: 0x40] Empty bin
Fast_bin[04] [size: 0x50] Empty bin
Fast_bin[05] [size: 0x60] Empty bin
Fast_bin[06] [size: 0x70] Empty bin
Fast_bin[07] [size: 0x80] Empty bin

Unsorted bin in Arena @ 0x7f10940c1b80
Found 0 chunks in unsorted bin

Small bins in Arena @ 0x7f10940c1b80
Found 0 chunks in 0 small bins

Large bins in Arena @ 0x7f10940c1b80
Found 0 chunks in 0 large bins
</code></pre>
<p>Other heap commands can be found under <code>dmh</code>, check <code>dmh?</code> for the full list.</p>
<pre><code>[0x00000000]&gt; dmh?
Usage:  dmh   # Memory map heap
| dmh                                          List the chunks inside the heap segment
| dmh @[malloc_state]                          List heap chunks of a particular arena
| dmha                                         List all malloc_state instances in application
| dmhb @[malloc_state]                         Display all parsed Double linked list of main_arena's or a particular arena bins instance
| dmhb [bin_num|bin_num:malloc_state]          Display parsed double linked list of bins instance from a particular arena
| dmhbg [bin_num]                              Display double linked list graph of main_arena's bin [Under development]
| dmhc @[chunk_addr]                           Display malloc_chunk struct for a given malloc chunk
| dmhd [tcache|unsorted|fast|small|large]      Display description of bins in the main_arena
| dmhf @[malloc_state]                         Display all parsed fastbins of main_arena's or a particular arena fastbinY instance
| dmhf [fastbin_num|fastbin_num:malloc_state]  Display parsed single linked list in fastbinY instance from a particular arena
| dmhg                                         Display heap graph of heap segment
| dmhg [malloc_state]                          Display heap graph of a particular arena
| dmhi @[malloc_state]                         Display heap_info structure/structures for a given arena
| dmhj                                         List the chunks inside the heap segment in JSON format
| dmhm                                         List all elements of struct malloc_state of main thread (main_arena)
| dmhm @[malloc_state]                         List all malloc_state instance of a particular arena
| dmht                                         Display all parsed thread cache bins of all arena's tcache instance
| dmhv @[malloc_state]                         List heap chunks of a particular arena along with hexdump of first 0x10 bytes
| dmh?                                         Show map heap help
</code></pre>
<p>Rizin supports Glibc, Jemalloc &lt; 5.0 and Windows heap.</p>
<h1 id="files-1"><a class="header" href="#files-1">Files</a></h1>
<p>The rizin debugger allows the user to list and manipulate the file descriptors from the target process.</p>
<p>This is a useful feature, which is not found in other debuggers, the functionality is similar to the lsof command line tool, but have extra subcommands to change the seek, close or duplicate them.</p>
<p>So, at any time in the debugging session you can replace the stdio file descriptors to use network sockets created by rizin, or replace a network socket connection to hijack it.</p>
<p>This functionality is also available in r2frida by using the dd command prefixed with a backslash. In rizin you may want to see the output of dd? for proper details.</p>
<h1 id="reverse-debugging"><a class="header" href="#reverse-debugging">Reverse Debugging</a></h1>
<p>Rizin has reverse debugger, that can seek the program counter backward.
(e.g. reverse-next, reverse-continue in gdb)
Firstly you need to save program state at the point that you want to start recording.
The syntax for recording is:</p>
<pre><code>[0x004028a0]&gt; dts+
</code></pre>
<p>You can use <code>dts</code> commands for recording and managing program states.
After recording the states, you can seek pc back and forth to any points after saved address.
So after recording, you can try single step back:</p>
<pre><code>[0x004028a0]&gt; 2dso
[0x004028a0]&gt; dr rip
0x004028ae
[0x004028a0]&gt; dsb
continue until 0x004028a2
hit breakpoint at: 4028a2
[0x004028a0]&gt; dr rip
0x004028a2
</code></pre>
<p>When you run <code>dsb</code>, reverse debugger restore previous recorded state and execute program from it
until desired point.</p>
<p>Or you can also try continue back:</p>
<pre><code>[0x004028a0]&gt; db 0x004028a2
[0x004028a0]&gt; 10dso
[0x004028a0]&gt; dr rip
0x004028b9
[0x004028a0]&gt; dcb
[0x004028a0]&gt; dr rip
0x004028a2
</code></pre>
<p><code>dcb</code> seeks program counter until hit the latest breakpoint.
So once set a breakpoint, you can back to it any time.</p>
<p>You can see current recorded program states using <code>dts</code>:</p>
<pre><code>[0x004028a0]&gt; dts
session: 0   at:0x004028a0   &quot;&quot;
session: 1   at:0x004028c2   &quot;&quot;
</code></pre>
<p>NOTE: Program records can be saved at any moments. These are diff style format
that save only different memory area from previous. It saves memory space rather
than entire dump.</p>
<p>And also can add comment:</p>
<pre><code>[0x004028c2]&gt; dtsC 0 program start
[0x004028c2]&gt; dtsC 1 decryption start
[0x004028c2]&gt; dts
session: 0   at:0x004028a0   &quot;program start&quot;
session: 1   at:0x004028c2   &quot;decryption start&quot;
</code></pre>
<p>You can leave notes for each records to keep in your mind.
<code>dsb</code> and <code>dcb</code> commands restore the program state from latest record if there are
many records.</p>
<p>Program records can exported to file and of course import it.
Export/Import records to/from file:</p>
<pre><code>[0x004028c2]&gt; dtst records_for_test
Session saved in records_for_test.session and dump in records_for_test.dump
[0x004028c2]&gt; dtsf records_for_test
session: 0, 0x4028a0 diffs: 0
session: 1, 0x4028c2 diffs: 0
</code></pre>
<p>Moreover, you can do reverse debugging in ESIL mode.
In ESIL mode, program state can be managed by <code>aets</code> commands.</p>
<pre><code>[0x00404870]&gt; aets+
</code></pre>
<p>And step back by <code>aesb</code>:</p>
<pre><code>[0x00404870]&gt; aer rip
0x00404870
[0x00404870]&gt; 5aeso
[0x00404870]&gt; aer rip
0x0040487d
[0x00404870]&gt; aesb
[0x00404870]&gt; aer rip
0x00404879
</code></pre>
<p>In addition to the native reverse debugging capabilities in rizin, it's also possible to
use gdb's remote protocol to reverse debug a target gdbserver that supports it.
<code>R!dsb</code> and <code>R!dcb</code> are available as <code>dsb</code> and <code>dcb</code> replacements for this purpose,
see <a href="debugger/remote_gdb.html">remote gdb's documentation</a> for more information.</p>
<h1 id="windows-messages"><a class="header" href="#windows-messages">Windows Messages</a></h1>
<p>On Windows, you can use <code>dbW</code> while debugging to set a breakpoint for the message handler of a specific window.</p>
<p>Get a list of the current process windows with  <code>dW</code> :</p>
<pre><code>[0x7ffe885c1164]&gt; dW
.----------------------------------------------------.
| Handle      | PID   | TID    | Class Name          |
)----------------------------------------------------(
| 0x0023038e  | 9432  | 22432  | MSCTFIME UI         |
| 0x0029049e  | 9432  | 22432  | IME                 |
| 0x002c048a  | 9432  | 22432  | Edit                |
| 0x000d0474  | 9432  | 22432  | msctls_statusbar32  |
| 0x00070bd6  | 9432  | 22432  | Notepad             |
`----------------------------------------------------'
</code></pre>
<p>Set the breakpoint with a message type, together with either the window class name or its handle:</p>
<pre><code>[0x7ffe885c1164]&gt; dbW WM_KEYDOWN Edit
Breakpoint set.
</code></pre>
<p>Or</p>
<pre><code>[0x7ffe885c1164]&gt; dbW WM_KEYDOWN 0x002c048a
Breakpoint set.
</code></pre>
<p>If you aren't sure which window you should put a breakpoint on, use <code>dWi</code> to identify it with your mouse:</p>
<pre><code>[0x7ffe885c1164]&gt; dWi
Move cursor to the window to be identified. Ready? y
Try to get the child? y
.--------------------------------------------.
| Handle      | PID   | TID    | Class Name  |
)--------------------------------------------(
| 0x002c048a  | 9432  | 22432  | Edit        |
`--------------------------------------------'
</code></pre>
<h1 id="macosios"><a class="header" href="#macosios">macOS/iOS</a></h1>
<h2 id="sign-rizin-binary"><a class="header" href="#sign-rizin-binary">Sign rizin binary</a></h2>
<p>If you install the Rizin pkg file and try to use it to debug a binary, you
will very likely get an error message such as:</p>
<pre><code>Child killed
ptrace: Cannot attach: Invalid argument

Please ensure your rizin binary is signed and it has the right entitlements
to make debugger work. Be aware that binaries signed by Apple cannot be
debugged due to the Apple System Integrity Protection (SIP).

For more info look at: https://book.rizin.re/debugger/apple.html#sign-rizin-binary
</code></pre>
<p>This is because the Darwin kernel will refuse to allow rizin to debug another
process if you don't have special rights (or if you are not root).</p>
<p>To sign the binary and give it the special rights to allow debugging as a
regular user, download the Entitlements file
<a href="https://github.com/rizinorg/rizin/blob/dev/binrz/rizin/rizin_macos.xml">here</a>.
Then execute the following command:</p>
<pre><code class="language-sh">$ codesign --entitlements &lt;entitlements-file&gt; --force -s - $(which rizin)
</code></pre>
<p>However, be aware that even with a signed rizin binary you cannot debug
binaries signed by Apple. To bypass the problem you have a few options:</p>
<ul>
<li>Remove the certificate of the debuggee, by using
<code>codesign --remove-signature &lt;binary&gt;</code> or other alternatives like
<a href="https://github.com/steakknife/unsign">unsign</a>. WARNING: this cannot be
undone, so we suggest to make a copy of the original binary.</li>
<li>Disable SIP with <code>csrutil enable --without debug</code> in Recovery Mode.</li>
</ul>
<h2 id="debugging-on-macos-over-ssh"><a class="header" href="#debugging-on-macos-over-ssh">Debugging on MacOS over SSH</a></h2>
<p>If you are trying to debug a program over SSH, you may experience failures
like rizin getting stuck while opening the file. This is because the OS is
waiting for user authentication to allow debugging. However, since
you are over SSH, the OS has no way of showing the permission window.</p>
<p>To avoid this problem you can either run rizin with <code>sudo</code> or you may
instruct taskport to not authenticate the user by executing the following
commands. This will disable the debugging authentication prompt even after
you reboot.</p>
<pre><code class="language-sh">security authorizationdb read system.privilege.taskport &gt; taskport.plist
/usr/libexec/PlistBuddy -c 'Set :authenticate-user false' ./taskport.plist
sudo security authorizationdb write system.privilege.taskport &lt; taskport.plist
</code></pre>
<h1 id="remote-access-capabilities"><a class="header" href="#remote-access-capabilities">Remote Access Capabilities</a></h1>
<p>Rizin can be run locally, or it can be started as a server process which is controlled by a local
rizin process. This is possible because everything uses rizin's IO subsystem which abstracts access to system(), cmd() and all basic IO operations so to work over a network.</p>
<p>Help for commands useful for remote access to rizin:</p>
<pre><code>[0x00000000]&gt; R?
Usage: R[?]   # Connect with other instances of rizin
| R [[&lt;fd&gt;] &lt;cmd&gt;]        # List all open connections / Exec &lt;cmd&gt; at remote &lt;fd&gt;
| R&lt; [&lt;fd&gt; &lt;cmd&gt;]         # Send output of local &lt;cmd&gt; to remote &lt;fd&gt;
| R![&lt;cmd&gt;]               # Run &lt;cmd&gt; via rz_io_system
| R+ &lt;[proto://]host:port&gt; # Connect to remote host:port
| R- [&lt;fd&gt;]               # remove all hosts or host 'fd'
| R= &lt;fd&gt;                 # Open remote session with host 'fd', 'q' to quit
| R!= &lt;fd&gt;=0              # Enable remote cmd mode, sending commands to remote &lt;fd&gt; server
| R=!                     # Disable remote cmd mode
| Rr &lt;[host:]port&gt; [&lt;cmd&gt;] # Start the rap server (o rap://9999) / Execute &lt;cmd&gt; on rap server
| Rg[?]                   # Start the gdbserver
| Rh[?]                   # Start the http webserver
| RH[?]                   # Start the http webserver (and launch the web browser)
| Rt &lt;[host:]port&gt; [&lt;cmd&gt;] # Start the tcp server
| R&amp;r &lt;port&gt;              # Start rap server in background (same as '&amp;_=h')
</code></pre>
<p>You can learn rizin remote capabilities by displaying the list of supported IO plugins: <code>rizin -L</code>.</p>
<p>A little example should make this clearer. A typical remote session might look like this:</p>
<p>At the remote host1:</p>
<pre><code>$ rizin rap://:1234
</code></pre>
<p>At the remote host2:</p>
<pre><code>$ rizin rap://:1234
</code></pre>
<p>At localhost:</p>
<pre><code>$ rizin =
</code></pre>
<p>Add hosts</p>
<pre><code>[0x004048c5]&gt; R+ rap://&lt;host1&gt;:1234//bin/ls
Connected to: &lt;host1&gt; at port 1234
waiting... ok

[0x004048c5]&gt; R
0 - rap://&lt;host1&gt;:1234//bin/ls
</code></pre>
<p>You can open remote files in debug mode (or using any IO plugin) specifying URI when adding hosts:</p>
<pre><code>[0x004048c5]&gt; R+ R+ rap://&lt;host2&gt;:1234/dbg:///bin/ls
Connected to: &lt;host2&gt; at port 1234
waiting... ok
0 - rap://&lt;host1&gt;:1234//bin/ls
1 - rap://&lt;host2&gt;:1234/dbg:///bin/ls
</code></pre>
<p>To execute commands on host1:</p>
<pre><code>[0x004048c5]&gt; R 0 px
[0x004048c5]&gt; R s 0x666
</code></pre>
<p>To open a session with host2:</p>
<pre><code>[0x004048c5]&gt; R= 1
fd:6&gt; pi 1
...
fd:6&gt; q
</code></pre>
<p>To remove hosts (and close connections):</p>
<pre><code>[0x004048c5]&gt; R-
</code></pre>
<p>You can also redirect rizin output to a TCP or UDP server (such as <code>nc -l</code>). First, Add the server with 'R+ tcp://' or 'R+ udp://', then you can redirect the output of a command to be sent to the server:</p>
<pre><code>[0x004048c5]&gt; R+ tcp://&lt;host&gt;:&lt;port&gt;/
Connected to: &lt;host&gt; at port &lt;port&gt;
5 - tcp://&lt;host&gt;:&lt;port&gt;/
[0x004048c5]&gt; R&lt;5 cmd...
</code></pre>
<p>The <code>R&lt;</code> command will send the output from the execution of <code>cmd</code> to the remote connection number N (or the last one used if no id specified).</p>
<h1 id="debugging-with-gdbserver"><a class="header" href="#debugging-with-gdbserver">Debugging with gdbserver</a></h1>
<p>rizin allows remote debugging over the gdb remote protocol. So you can run a
gdbserver and connect to it with rizin for remote debugging. The syntax for
connecting is:</p>
<pre><code>$ rizin -d gdb://&lt;host&gt;:&lt;port&gt;
</code></pre>
<p>Note that the following command does the same, rizin will use the debug plugin specified by the uri if found.</p>
<pre><code>$ rizin -D gdb gdb://&lt;host&gt;:&lt;port&gt;
</code></pre>
<p>The debug plugin can be changed at runtime using the dL or Ld commands.</p>
<p>Or if the gdbserver is running in extended mode, you can attach to a process on
the host with:</p>
<pre><code>$ rizin -d gdb://&lt;host&gt;:&lt;port&gt;/&lt;pid&gt;
</code></pre>
<p>It is also possible to start debugging after analyzing a file using the <code>doof</code> command
which rebases the current session's data after opening gdb</p>
<pre><code>[0x00404870]&gt; doof gdb://&lt;host&gt;:&lt;port&gt;/&lt;pid&gt;
</code></pre>
<p>After connecting, you can use the standard rizin debug commands as normal.</p>
<p>rizin does not yet load symbols from gdbserver, so it needs the binary to
be locally present to load symbols from it. In case symbols are not loaded even
if the binary is present, you can try specifying the path with <code>e dbg.exe.path</code>:</p>
<pre><code>$ rizin -e dbg.exe.path=&lt;path&gt; -d gdb://&lt;host&gt;:&lt;port&gt;
</code></pre>
<p>If symbols are loaded at an incorrect base address, you can try specifying
the base address too with <code>e bin.baddr</code>:</p>
<pre><code>$ rizin -e bin.baddr=&lt;baddr&gt; -e dbg.exe.path=&lt;path&gt; -d gdb://&lt;host&gt;:&lt;port&gt;
</code></pre>
<p>Usually the gdbserver reports the maximum packet size it supports. Otherwise,
rizin resorts to sensible defaults. But you can specify the maximum packet
size with the environment variable <code>R2_GDB_PKTSZ</code>. You can also check and set
the max packet size during a session with the IO system, <code>R!</code>.</p>
<pre><code>$ export R2_GDB_PKTSZ=512
$ rizin -d gdb://&lt;host&gt;:&lt;port&gt;
= attach &lt;pid&gt; &lt;tid&gt;
Assuming filepath &lt;path/to/exe&gt;
[0x7ff659d9fcc0]&gt; R!pktsz
packet size: 512 bytes
[0x7ff659d9fcc0]&gt; R!pktsz 64
[0x7ff659d9fcc0]&gt; R!pktsz
packet size: 64 bytes
</code></pre>
<p>The gdb IO system provides useful commands which might not fit into any
standard rizin commands. You can get a list of these commands with
<code>R!?</code>. (Remember, <code>R!</code> accesses the underlying IO plugin's <code>system()</code>).</p>
<pre><code>[0x7ff659d9fcc0]&gt; R!?
Usage: R!cmd args
 R!pid             - show targeted pid
 R!pkt s           - send packet 's'
 R!monitor cmd     - hex-encode monitor command and pass to target interpreter
 R!rd              - show reverse debugging availability
 R!dsb             - step backwards
 R!dcb             - continue backwards
 R!detach [pid]    - detach from remote/detach specific pid
 R!inv.reg         - invalidate reg cache
 R!pktsz           - get max packet size used
 R!pktsz bytes     - set max. packet size as 'bytes' bytes
 R!exec_file [pid] - get file which was executed for current/specified pid
</code></pre>
<p>Note that <code>R!dsb</code> and <code>R!dcb</code> are only available in special gdbserver implementations such
as <a href="https://github.com/mozilla/rr">Mozilla's rr</a>, the default gdbserver doesn't include
remote reverse debugging support.
Use <code>R!rd</code> to print the currently available reverse debugging capabilities.</p>
<p>If you are interested in debugging rizin's interaction with gdbserver you can use
<code>R!monitor set remote-debug 1</code> to turn on logging of gdb's remote protocol packets in
gdbserver's console and <code>R!monitor set debug 1</code> to show general debug messages from
gdbserver in it's console.</p>
<p>rizin also provides its own gdbserver implementation:</p>
<pre><code>$ rizin =
[0x00000000]&gt; Rg?
|Usage:  =[g] [...] # gdb server
| gdbserver:
| Rg port file [args]   listen on 'port' debugging 'file' using gdbserver
| Rg! port file [args]  same as above, but debug protocol messages (like gdbserver --remote-debug)
</code></pre>
<p>So you can start it as:</p>
<pre><code>$ rizin =
[0x00000000]&gt; Rg 8000 /bin/rizin -
</code></pre>
<p>And then connect to it like you would to any gdbserver. For example, with rizin:</p>
<pre><code>$ rizin -d gdb://localhost:8000
</code></pre>
<h1 id="windbg-kernel-mode-debugging-kd"><a class="header" href="#windbg-kernel-mode-debugging-kd">WinDBG Kernel-mode Debugging (KD)</a></h1>
<p>The WinDBG KD interface support for rizin allows you to attach to VM running
Windows and debug its kernel over a serial port or network.</p>
<p>It is also possible to use the remote GDB interface to connect and
debug Windows kernels without depending on Windows capabilities.</p>
<p>Bear in mind that WinDBG KD support is still work-in-progress, and this is
just an initial implementation which will get better in time.</p>
<h2 id="setting-up-kd-on-windows"><a class="header" href="#setting-up-kd-on-windows">Setting Up KD on Windows</a></h2>
<blockquote>
<p>For a complete walkthrough, refer to Microsoft's <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd">documentation</a>.</p>
</blockquote>
<h3 id="serial-port"><a class="header" href="#serial-port">Serial Port</a></h3>
<p>Enable KD over a serial port on Windows Vista and higher like this:</p>
<pre><code>bcdedit /debug on
bcdedit /dbgsettings serial debugport:1 baudrate:115200
</code></pre>
<p>Or like this for Windows XP:
Open boot.ini and add /debug /debugport=COM1 /baudrate=115200:</p>
<pre><code>[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Debugging with Cable&quot; /fastdetect /debug /debugport=COM1 /baudrate=57600
</code></pre>
<p>In case of VMWare</p>
<pre><code>	Virtual Machine Settings -&gt; Add -&gt; Serial Port
	Device Status:
	[v] Connect at power on
	Connection:
	[v] Use socket (named pipe)
	[_/tmp/winkd.pipe________]
	From: Server To: Virtual Machine
</code></pre>
<p>Configure the VirtualBox Machine like this:</p>
<pre><code>    Preferences -&gt; Serial Ports -&gt; Port 1

    [v] Enable Serial Port
    Port Number: [_COM1_______[v]]
    Port Mode:   [_Host_Pipe__[v]]
                 [v] Create Pipe
    Port/File Path: [_/tmp/winkd.pipe____]
</code></pre>
<p>Or just spawn the VM with qemu like this:</p>
<pre><code>$ qemu-system-x86_64 -chardev socket,id=serial0,\
     path=/tmp/winkd.pipe,nowait,server \
     -serial chardev:serial0 -hda Windows7-VM.vdi
</code></pre>
<h3 id="network"><a class="header" href="#network">Network</a></h3>
<p>Enable KD over network (KDNet) on Windows 7 or later likes this:</p>
<pre><code>bcdedit /debug on
bcdedit /dbgsettings net hostip:w.x.y.z port:n
</code></pre>
<p>Starting from Windows 8 there is no way to enforce debugging
for every boot, but it is possible to always show the advanced boot options,
which allows to enable kernel debugging:</p>
<pre><code>bcedit /set {globalsettings} advancedoptions true
</code></pre>
<h2 id="connecting-to-kd-interface-on-rizin"><a class="header" href="#connecting-to-kd-interface-on-rizin">Connecting to KD interface on rizin</a></h2>
<h3 id="serial-port-1"><a class="header" href="#serial-port-1">Serial Port</a></h3>
<p>Rizin will use the <code>winkd</code> io plugin to connect to a socket file
created by virtualbox or qemu. Also, the <code>winkd</code> debugger plugin and
we should specify the x86-32 too. (32 and 64 bit debugging is supported)</p>
<pre><code>$ rizin -a x86 -b 32 -D winkd winkd:///tmp/winkd.pipe
</code></pre>
<p>On Windows you should run the following line:</p>
<pre><code>$ rizin -D winkd winkd://\\.\pipe\com_1
</code></pre>
<h3 id="network-1"><a class="header" href="#network-1">Network</a></h3>
<pre><code>$ rizin -a x86 -b 32 -d winkd://&lt;hostip&gt;:&lt;port&gt;:w.x.y.z
</code></pre>
<h2 id="using-kd"><a class="header" href="#using-kd">Using KD</a></h2>
<p>When connecting to a KD interface, rizin will send a breakin packet to interrupt
the target and we will get stuck here:</p>
<pre><code>[0x828997b8]&gt; pd 20
	;-- eip:
	0x828997b8    cc           int3
	0x828997b9    c20400       ret 4
	0x828997bc    cc           int3
	0x828997bd    90           nop
	0x828997be    c3           ret
    0x828997bf    90           nop
</code></pre>
<p>In order to skip that trap we will need to change eip and run 'dc' twice:</p>
<pre><code>dr eip=eip+1
dc
dr eip=eip+1
dc
</code></pre>
<p>Now the Windows VM will be interactive again. We will need to kill rizin and
attach again to get back to control the kernel.</p>
<p>In addition, the <code>dp</code> command can be used to list all processes, and
<code>dpa</code> or <code>dp=</code> to attach to the process. This will display the base
address of the process in the physical memory layout.</p>
<h1 id="windbg-backend-for-windows-dbgeng"><a class="header" href="#windbg-backend-for-windows-dbgeng">WinDBG Backend for Windows (DbgEng)</a></h1>
<p>On Windows, rizin can use <code>DbgEng.dll</code> as a debugging backend,
allowing it to make use of WinDBG's capabilities, supporting dump files,
local and remote user and kernel mode debugging.</p>
<p>You can use the debugging DLLs included on Windows or get the latest version from Microsoft's <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">download page</a> (recommended).</p>
<blockquote>
<p>You cannot use DLLs from the Microsoft Store's <code>WinDbg Preview</code> app folder directly as they are not marked as executable for normal users.</p>
</blockquote>
<blockquote>
<p>rizin will try to load <code>dbgeng.dll</code> from the <code>_NT_DEBUGGER_EXTENSION_PATH</code> environment variable before using Windows' default library search path.</p>
</blockquote>
<h2 id="using-the-plugin"><a class="header" href="#using-the-plugin">Using the plugin</a></h2>
<p>To use the <code>windbg</code> plugin, pass the same command-line options as you would for <code>WinDBG</code> or <code>kd</code> (see Microsoft's <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/windbg-command-line-options">documentation</a>), quoting/escaping when necessary:</p>
<pre><code>&gt; rizin -d &quot;windbg://-remote tcp:server=Server,port=Socket&quot;
</code></pre>
<pre><code>&gt; rizin -d &quot;windbg://MyProgram.exe \&quot;my arg\&quot;&quot;
</code></pre>
<pre><code>&gt; rizin -d &quot;windbg://-k net:port=&lt;n&gt;,key=&lt;MyKey&gt;&quot;
</code></pre>
<pre><code>&gt; rizin -d &quot;windbg://-z MyDumpFile.dmp&quot;
</code></pre>
<p>You can then debug normally (see <code>d?</code> command) or interact with the backend shell directly with the <code>R!</code> command:</p>
<pre><code>[0x7ffcac9fcea0]&gt; dcu 0x0007ffc98f42190
Continue until 0x7ffc98f42190 using 1 bpsize
ModLoad: 00007ffc`ab6b0000 00007ffc`ab6e0000   C:\WINDOWS\System32\IMM32.DLL
Breakpoint 1 hit
hit breakpoint at: 0x7ffc98f42190

[0x7fffcf232190]&gt; R!k4
Child-SP          RetAddr           Call Site
00000033`73b1f618 00007ff6`c67a861d r_main!r_main_rizin
00000033`73b1f620 00007ff6`c67d0019 rizin!main+0x8d
00000033`73b1f720 00007ff6`c67cfebe rizin!invoke_main+0x39
00000033`73b1f770 00007ff6`c67cfd7e rizin!__scrt_common_main_seh+0x12e
</code></pre>
<h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>Rizin is not just the only tool provided by the rizin project. The rest if chapters in this book are focused on explaining the use of the rizin tool, this chapter will focus on explaining all the other companion tools that are shipped inside the rizin project.</p>
<p>All the functionalities provided by the different APIs and plugins have also different tools to allow to use them from the commandline and integrate them with shellscripts easily.</p>
<p>Thanks to the orthogonal design of the framework it is possible to do all the things that rizin is able from different places:</p>
<ul>
<li>these companion tools</li>
<li>native library apis</li>
<li>scripting with rz-pipe</li>
<li>the rizin shell</li>
</ul>
<h1 id="rz-ax-1"><a class="header" href="#rz-ax-1">Rz-ax</a></h1>
<p>The <code>rz-ax</code> utility comes with the rizin framework and aims to be a minimalistic expression evaluator for the shell. It is useful for making base conversions between floating point values, hexadecimal representations, hexpair strings to ascii, octal to integer. It supports endianness and can be used as a shell if no arguments are given.</p>
<p>This is the help message of rz-ax, this tool can be used in the command-line or interactively (reading the values from stdin), so it can be used as a multi-base calculator.</p>
<p>Inside rizin, the functionality of rz-ax is available under the ? command. For example:</p>
<pre><code>[0x00000000]&gt; ? 3+4
</code></pre>
<p>As you can see, the numeric expressions can contain mathematical expressions like addition, subtraction, .. as well as group operations with parenthesis.</p>
<p>The syntax in which the numbers are represented define the base, for example:</p>
<ul>
<li>3 : decimal, base 10</li>
<li>0xface : hexadecimal, base 16</li>
<li>0472 : octal, base 8</li>
<li>2M : units, 2 megabytes</li>
<li>...</li>
</ul>
<p>This is the help message of rz-ax -h, which will show you a bunch more syntaxes</p>
<pre><code>$ rz-ax -h
Usage: rz-ax [options] [expr ...]
  =[base]                      ;  rz-ax =10 0x46 -&gt; output in base 10
  int     -&gt;  hex              ;  rz-ax 10
  hex     -&gt;  int              ;  rz-ax 0xa
  -int    -&gt;  hex              ;  rz-ax -77
  -hex    -&gt;  int              ;  rz-ax 0xffffffb3
  int     -&gt;  bin              ;  rz-ax b30
  int     -&gt;  ternary          ;  rz-ax t42
  bin     -&gt;  int              ;  rz-ax 1010d
  ternary -&gt;  int              ;  rz-ax 1010dt
  float   -&gt;  hex              ;  rz-ax 3.33f
  hex     -&gt;  float            ;  rz-ax Fx40551ed8
  oct     -&gt;  hex              ;  rz-ax 35o
  hex     -&gt;  oct              ;  rz-ax Ox12 (O is a letter)
  bin     -&gt;  hex              ;  rz-ax 1100011b
  hex     -&gt;  bin              ;  rz-ax Bx63
  ternary -&gt;  hex              ;  rz-ax 212t
  hex     -&gt;  ternary          ;  rz-ax Tx23
  raw     -&gt;  hex              ;  rz-ax -S &lt; /binfile
  hex     -&gt;  raw              ;  rz-ax -s 414141
  -l                           ;  append newline to output (for -E/-D/-r/..
  -a      show ascii table     ;  rz-ax -a
  -b      bin -&gt; str           ;  rz-ax -b 01000101 01110110
  -B      str -&gt; bin           ;  rz-ax -B hello
  -d      force integer        ;  rz-ax -d 3 -&gt; 3 instead of 0x3
  -e      swap endianness      ;  rz-ax -e 0x33
  -D      base64 decode        ;
  -E      base64 encode        ;
  -f      floating point       ;  rz-ax -f 6.3+2.1
  -F      stdin slurp code hex ;  rz-ax -F &lt; shellcode.[c/py/js]
  -h      help                 ;  rz-ax -h
  -i      dump as C byte array ;  rz-ax -i &lt; bytes
  -k      keep base            ;  rz-ax -k 33+3 -&gt; 36
  -K      randomart            ;  rz-ax -K 0x34 1020304050
  -L      bin -&gt; hex(bignum)   ;  rz-ax -L 111111111 # 0x1ff
  -n      binary number        ;  rz-ax -n 0x1234 # 34120000
  -N      binary number        ;  rz-ax -N 0x1234 # \x34\x12\x00\x00
  -r      rizin style output      ;  rz-ax -r 0x1234
  -s      hexstr -&gt; raw        ;  rz-ax -s 43 4a 50
  -S      raw -&gt; hexstr        ;  rz-ax -S &lt; /bin/ls &gt; ls.hex
  -t      tstamp -&gt; str        ;  rz-ax -t 1234567890
  -x      hash string          ;  rz-ax -x linux osx
  -u      units                ;  rz-ax -u 389289238 # 317.0M
  -w      signed word          ;  rz-ax -w 16 0xffff
  -v      version              ;  rz-ax -v
</code></pre>
<p>Some examples:</p>
<pre><code>$ rz-ax 3+0x80
0x83
</code></pre>
<pre><code>$ rz-ax 0x80+3
131
</code></pre>
<pre><code>$ echo 0x80+3 | rz-ax
131
</code></pre>
<pre><code>$ rz-ax -s 4142
AB
</code></pre>
<pre><code>$ rz-ax -S AB
4142
</code></pre>
<pre><code>$ rz-ax -S &lt; bin.foo
...
</code></pre>
<pre><code>$ rz-ax -e 33
0x21000000
</code></pre>
<pre><code>$ rz-ax -e 0x21000000
33
</code></pre>
<pre><code>$ rz-ax -K 90203010
+--[0x10302090]---+
|Eo. .            |
| . . . .         |
|      o          |
|       .         |
|        S        |
|                 |
|                 |
|                 |
|                 |
+-----------------+
</code></pre>
<h1 id="rz-find-1"><a class="header" href="#rz-find-1">Rz-find</a></h1>
<p><code>rz-find</code> is the command line frontend of the <code>rz_search</code> library. Which allows you to search for strings, sequences of bytes with binary masks, etc</p>
<pre><code>$ rz-find -h
Usage: rz-find [-mXnzZhqv] [-a align] [-b sz] [-f/t from/to] [-[e|s|S] str] [-x hex] -|file|dir ..
 -a [align] only accept aligned hits
 -b [size]  set block size
 -e [regex] search for regex matches (can be used multiple times)
 -f [from]  start searching from address 'from'
 -h         show this help
 -i         identify filetype (rizin -nqcpm file)
 -j         output in JSON
 -m         magic search, file-type carver
 -M [str]   set a binary mask to be applied on keywords
 -n         do not stop on read errors
 -r         print using rizin commands
 -s [str]   search for a specific string (can be used multiple times)
 -S [str]   search for a specific wide string (can be used multiple times). Assumes str is UTF-8.
 -t [to]    stop search at address 'to'
 -q         quiet - do not show headings (filenames) above matching contents (default for searching a single file)
 -v         print version and exit
 -x [hex]   search for hexpair string (909090) (can be used multiple times)
 -X         show hexdump of search results
 -z         search for zero-terminated strings
 -Z         show string found on each search hit
</code></pre>
<p>That's how to use it, first we'll search for &quot;lib&quot; inside the <code>/bin/ls</code> binary.</p>
<pre><code>$ rz-find -s lib /bin/ls
0x5f9
0x675
0x679
...
$
</code></pre>
<p>Note that the output is pretty minimal, and shows the offsets where the string <code>lib</code> is found. We can then use this output to feed other tools.</p>
<p>Counting results:</p>
<pre><code>$ rz-find -s lib /bin/ls | wc -l
</code></pre>
<p>Displaying results with context:</p>
<pre><code>$ export F=/bin/ls
$ for a in `rz-find -s lib $F` ; do \
    rizin -ns $a -qc'x 32' $F ; done
0x000005f9  6c69 622f 6479 6c64 .. lib/dyld........
0x00000675  6c69 622f 6c69 6275 .. lib/libutil.dyli
0x00000679  6c69 6275 7469 6c2e .. libutil.dylib...
0x00000683  6c69 6200 000c 0000 .. lib......8......
0x000006a5  6c69 622f 6c69 626e .. lib/libncurses.5
0x000006a9  6c69 626e 6375 7273 .. libncurses.5.4.d
0x000006ba  6c69 6200 0000 0c00 .. lib.......8.....
0x000006dd  6c69 622f 6c69 6253 .. lib/libSystem.B.
0x000006e1  6c69 6253 7973 7465 .. libSystem.B.dyli
0x000006ef  6c69 6200 0000 0000 .. lib......&amp;......
</code></pre>
<p>rz-find can also be used as a replacement of <code>file</code> to identify the mimetype of a file using the internal magic database of rizin.</p>
<pre><code>$ rz-find -i /bin/ls
0x00000000 1 Mach-O
</code></pre>
<p>Also works as a <code>strings</code> replacement, similar to what you do with rz-bin -z, but without caring about parsing headers and obeying binary sections.</p>
<pre><code>$ rz-find -z /bin/ls| grep http
0x000076e5 %http://www.apple.com/appleca/root.crl0\r
0x00007ae6 https://www.apple.com/appleca/0
0x00007fa9 )http://www.apple.com/certificateauthority0
0x000080ab $http://crl.apple.com/codesigning.crl0
</code></pre>
<h1 id="rz-run-1"><a class="header" href="#rz-run-1">Rz-run</a></h1>
<p>rz-run is a tool allowing to setup a specified execution environment - redefine stdin/stdout, pipes,
change the environment variables and other settings useful to craft the boundary conditions you need to run
a binary for debugging.</p>
<pre><code>$ rz-run -h
Usage: rz-run -v|-t|script.rrz [directive ..]
</code></pre>
<p>It takes the text file in key=value format to specify the execution environment.
Rz-run can be used as both separate tool or as a part of rizin.
To load the rz-run profile in rizin you need to use either <code>-r</code> to load
the profile from file or <code>-R</code> to specify the directive from string.</p>
<p>The format of the profile is very simple. Note the most important keys - <code>program</code> and <code>arg*</code></p>
<p>One of the most common usage cases - redirect the output of debugged program in rizin.
For this you need to use <code>stdio</code>, <code>stdout</code>, <code>stdin</code>, <code>input</code>, and a couple similar keys.</p>
<p>Here is the basic profile example:</p>
<pre><code>program=/bin/ls
arg1=/bin
# arg2=hello
# arg3=&quot;hello\nworld&quot;
# arg4=:048490184058104849
# arg5=:!ragg2 -p n50 -d 10:0x8048123
# arg6=@arg.txt
# arg7=@300@ABCD # 300 chars filled with ABCD pattern
# system=rizin =
# aslr=no
setenv=FOO=BAR
# unsetenv=FOO
# clearenv=true
# envfile=environ.txt
timeout=3
# timeoutsig=SIGTERM # or 15
# connect=localhost:8080
# listen=8080
# pty=false
# fork=true
# bits=32
# pid=0
# pidfile=/tmp/foo.pid
# #sleep=0
# #maxfd=0
# #execve=false
# #maxproc=0
# #maxstack=0
# #core=false
# #stdio=blah.txt
# #stderr=foo.txt
# stdout=foo.txt
# stdin=input.txt # or !program to redirect input from another program
# input=input.txt
# chdir=/
# chroot=/mnt/chroot
# libpath=$PWD:/tmp/lib
# rzpreload=yes
# preload=/lib/libfoo.so
# setuid=2000
# seteuid=2000
# setgid=2001
# setegid=2001
# nice=5
</code></pre>
<h1 id="rz-bin--show-properties-of-a-binary"><a class="header" href="#rz-bin--show-properties-of-a-binary">Rz-bin — Show Properties of a Binary</a></h1>
<p>Rz-bin is a powerful tool to handle binaries, to get information on imports, sections, headers and other data. It can present this information in several formats accepted by other tools, including rizin itself.
rz-bin understands many file formats: Java CLASS, ELF, PE, Mach-O or any format supported by plugins, and it is able to obtain symbol import/exports, library dependencies, strings of data sections, xrefs,  entrypoint address, sections, architecture type.</p>
<pre><code>$ rz-bin -h
Usage: rz-bin [-AcdeEghHiIjlLMqrRsSvVxzZ] [-@ at] [-a arch] [-b bits] [-B addr]
              [-C F:C:D] [-f str] [-m addr] [-n str] [-N m:M] [-P[-P] pdb]
              [-o str] [-O str] [-k query] [-D lang symname] | file
 -@ [addr]       show section, symbol or import at addr
 -A              list sub-binaries and their arch-bits pairs
 -a [arch]       set arch (x86, arm, .. or &lt;arch&gt;_&lt;bits&gt;)
 -b [bits]       set bits (32, 64 ...)
 -B [addr]       override base address (pie bins)
 -c              list classes
 -C [fmt:C:D]    create [elf,mach0,pe] with Code and Data hexpairs (see -a)
 -d              show debug/dwarf information
 -D lang name    demangle symbol name (-D all for bin.demangle=true)
 -e              entrypoint
 -E              globally exportable symbols
 -f [str]        select sub-bin named str
 -F [binfmt]     force to use that bin plugin (ignore header check)
 -g              same as -SMZIHVResizcld (show all info)
 -G [addr]       load address . offset to header
 -h              this help message
 -H              header fields
 -i              imports (symbols imported from libraries)
 -I              binary info
 -j              output in json
 -k [sdb-query]  run sdb query. for example: '*'
 -K [algo]       calculate checksums (md5, sha1, ..)
 -l              linked libraries
 -L [plugin]     list supported bin plugins or plugin details
 -m [addr]       show source line at addr
 -M              main (show address of main symbol)
 -n [str]        show section, symbol or import named str
 -N [min:max]    force min:max number of chars per string (see -z and -zz)
 -o [str]        output file/folder for write operations (out by default)
 -O [str]        write/extract operations (-O help)
 -p              show physical addresses
 -P              show debug/pdb information
 -PP             download pdb file for binary
 -q              be quiet, just show fewer data
 -qq             show less info (no offset/size for -z for ex.)
 -Q              show load address used by dlopen (non-aslr libs)
 -r              rizin output
 -R              relocations
 -s              symbols
 -S              sections
 -u              unfiltered (no rename duplicated symbols/sections)
 -v              display version and quit
 -V              Show binary version information
 -x              extract bins contained in file
 -X [fmt] [f] .. package in fat or zip the given files and bins contained in file
 -z              strings (from data section)
 -zz             strings (from raw bins [e bin.rawstr=1])
 -zzz            dump raw strings to stdout (for huge files)
 -Z              guess size of binary program
......
</code></pre>
<h2 id="file-properties-identification"><a class="header" href="#file-properties-identification">File Properties Identification</a></h2>
<p>File type identification is done using <code>-I</code>. With this option, rz-bin prints information on a binary type, like its encoding, endianness, class, operating system:</p>
<pre><code>$ rz-bin -I /bin/ls
arch     x86
binsz    128456
bintype  elf
bits     64
canary   true
class    ELF64
crypto   false
endian   little
havecode true
intrp    /lib64/ld-linux-x86-64.so.2
lang     c
linenum  false
lsyms    false
machine  AMD x86-64 architecture
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      true
relocs   false
relro    partial
rpath    NONE
static   false
stripped true
subsys   linux
va       true
</code></pre>
<p>To make rz-bin output information in format that the main program, rizin, can understand, pass <code>-Ir</code> option to it:</p>
<pre><code>$ rz-bin -Ir /bin/ls
e cfg.bigendian=false
e asm.bits=64
e asm.dwarf=true
e bin.lang=c
e file.type=elf
e asm.os=linux
e asm.arch=x86
e asm.pcalign=0
</code></pre>
<h2 id="code-entrypoints"><a class="header" href="#code-entrypoints">Code Entrypoints</a></h2>
<p>The <code>-e</code> option passed to rz-bin will show entrypoints for given binary. Two examples:</p>
<pre><code>$ rz-bin -e /bin/ls
[Entrypoints]
vaddr=0x00005310 paddr=0x00005310 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 type=program

1 entrypoints

$ rz-bin -er /bin/ls
fs symbols
f entry0 1 @ 0x00005310
f entry0_haddr 1 @ 0x00000018
s entry0
</code></pre>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>rz-bin is able to find imported objects by an executable, as well as their offsets in its PLT. This information is useful, for example, to understand what external function is invoked by <code>call</code> instruction. Pass <code>-i</code> flag to rz-bin to get a list of imports. An example:</p>
<pre><code>$ rz-bin -i /bin/ls
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
   1 0x000032e0  GLOBAL    FUNC __ctype_toupper_loc
   2 0x000032f0  GLOBAL    FUNC getenv
   3 0x00003300  GLOBAL    FUNC sigprocmask
   4 0x00003310  GLOBAL    FUNC __snprintf_chk
   5 0x00003320  GLOBAL    FUNC raise
   6 0x00000000  GLOBAL    FUNC free
   7 0x00003330  GLOBAL    FUNC abort
   8 0x00003340  GLOBAL    FUNC __errno_location
   9 0x00003350  GLOBAL    FUNC strncmp
  10 0x00000000    WEAK  NOTYPE _ITM_deregisterTMCloneTable
  11 0x00003360  GLOBAL    FUNC localtime_r
  12 0x00003370  GLOBAL    FUNC _exit
  13 0x00003380  GLOBAL    FUNC strcpy
  14 0x00003390  GLOBAL    FUNC __fpending
  15 0x000033a0  GLOBAL    FUNC isatty
  16 0x000033b0  GLOBAL    FUNC sigaction
  17 0x000033c0  GLOBAL    FUNC iswcntrl
  18 0x000033d0  GLOBAL    FUNC wcswidth
  19 0x000033e0  GLOBAL    FUNC localeconv
  20 0x000033f0  GLOBAL    FUNC mbstowcs
  21 0x00003400  GLOBAL    FUNC readlink
...

</code></pre>
<h2 id="exports"><a class="header" href="#exports">Exports</a></h2>
<p>rz-bin is able to find exports. For example:</p>
<pre><code>$ rz-bin -E /usr/lib/librz_bin.so | head
[Exports]

nth  paddr       vaddr      bind   type size lib name
―――――――――――――――――――――――――――――――――――――――――――――――――――――
210 0x000ae1f0 0x000ae1f0 GLOBAL   FUNC  200 r_bin_java_print_exceptions_attr_summary
211 0x000afc90 0x000afc90 GLOBAL   FUNC  135 r_bin_java_get_args
212 0x000b18e0 0x000b18e0 GLOBAL   FUNC   35 r_bin_java_get_item_desc_from_bin_cp_list
213 0x00022d90 0x00022d90 GLOBAL   FUNC  204 r_bin_class_add_method
214 0x000ae600 0x000ae600 GLOBAL   FUNC  175 r_bin_java_print_fieldref_cp_summary
215 0x000ad880 0x000ad880 GLOBAL   FUNC  144 r_bin_java_print_constant_value_attr_summary
216 0x000b7330 0x000b7330 GLOBAL   FUNC  679 r_bin_java_print_element_value_summary
217 0x000af170 0x000af170 GLOBAL   FUNC   65 r_bin_java_create_method_fq_str
218 0x00079b00 0x00079b00 GLOBAL   FUNC   15 LZ4_createStreamDecode
</code></pre>
<h2 id="symbols-exports"><a class="header" href="#symbols-exports">Symbols (Exports)</a></h2>
<p>With rz-bin, the generated symbols list format is similar to the imports list. Use the <code>-s</code> option to get it:</p>
<pre><code>rz-bin -s /bin/ls | head
[Symbols]

nth paddr       vaddr      bind   type   size lib name
――――――――――――――――――――――――――――――――――――――――――――――――――――――
110 0x000150a0 0x000150a0 GLOBAL FUNC 56 _obstack_allocated_p
111 0x0001f600 0x0021f600 GLOBAL  OBJ  8 program_name
112 0x0001f620 0x0021f620 GLOBAL  OBJ  8 stderr
113 0x00014f90 0x00014f90 GLOBAL FUNC 21 _obstack_begin_1
114 0x0001f600 0x0021f600   WEAK  OBJ  8 program_invocation_name
115 0x0001f5c0 0x0021f5c0 GLOBAL  OBJ  8 alloc_failed_handler
116 0x0001f5f8 0x0021f5f8 GLOBAL  OBJ  8 optarg
117 0x0001f5e8 0x0021f5e8 GLOBAL  OBJ  8 stdout
118 0x0001f5e0 0x0021f5e0 GLOBAL  OBJ  8 program_short_name
</code></pre>
<p>With the <code>-sr</code> option rz-bin produces a rizin script instead. It can later be passed to the core to automatically flag all symbols and to define corresponding byte ranges as functions and data blocks.</p>
<pre><code>$ rz-bin -sr /bin/ls | head
fs symbols
f sym.obstack_allocated_p 56 0x000150a0
f sym.program_invocation_name 8 0x0021f600
f sym.stderr 8 0x0021f620
f sym.obstack_begin_1 21 0x00014f90
f sym.program_invocation_name 8 0x0021f600
f sym.obstack_alloc_failed_handler 8 0x0021f5c0
f sym.optarg 8 0x0021f5f8
f sym.stdout 8 0x0021f5e8
f sym.program_invocation_short_name 8 0x0021f5e0
</code></pre>
<h2 id="list-libraries"><a class="header" href="#list-libraries">List Libraries</a></h2>
<p>rz-bin can list libraries used by a binary with the <code>-l</code> option:</p>
<pre><code>$ rz-bin -l `which rizin`
[Linked libraries]
librz_core.so
librz_parse.so
librz_search.so
librz_cons.so
librz_config.so
librz_bin.so
librz_debug.so
librz_analysis.so
librz_reg.so
librz_bp.so
librz_io.so
librz_fs.so
librz_asm.so
librz_syscall.so
librz_hash.so
librz_magic.so
librz_flag.so
librz_egg.so
librz_crypto.so
librz_util.so
libpthread.so.0
libc.so.6

22 libraries
</code></pre>
<p>Lets check the output with <code>ldd</code> command:</p>
<pre><code>$ ldd `which rizin`
linux-vdso.so.1 (0x00007fffba38e000)
librz_core.so =&gt; /usr/lib64/librz_core.so (0x00007f94b4678000)
librz_parse.so =&gt; /usr/lib64/librz_parse.so (0x00007f94b4425000)
librz_search.so =&gt; /usr/lib64/librz_search.so (0x00007f94b421f000)
librz_cons.so =&gt; /usr/lib64/librz_cons.so (0x00007f94b4000000)
librz_config.so =&gt; /usr/lib64/librz_config.so (0x00007f94b3dfa000)
librz_bin.so =&gt; /usr/lib64/librz_bin.so (0x00007f94b3afd000)
librz_debug.so =&gt; /usr/lib64/librz_debug.so (0x00007f94b38d2000)
librz_analysis.so =&gt; /usr/lib64/librz_analysis.so (0x00007f94b2fbd000)
librz_reg.so =&gt; /usr/lib64/librz_reg.so (0x00007f94b2db4000)
librz_bp.so =&gt; /usr/lib64/librz_bp.so (0x00007f94b2baf000)
librz_io.so =&gt; /usr/lib64/librz_io.so (0x00007f94b2944000)
librz_fs.so =&gt; /usr/lib64/librz_fs.so (0x00007f94b270e000)
librz_asm.so =&gt; /usr/lib64/librz_asm.so (0x00007f94b1c69000)
librz_syscall.so =&gt; /usr/lib64/librz_syscall.so (0x00007f94b1a63000)
librz_hash.so =&gt; /usr/lib64/librz_hash.so (0x00007f94b185a000)
librz_magic.so =&gt; /usr/lib64/librz_magic.so (0x00007f94b164d000)
librz_flag.so =&gt; /usr/lib64/librz_flag.so (0x00007f94b1446000)
librz_egg.so =&gt; /usr/lib64/librz_egg.so (0x00007f94b1236000)
librz_crypto.so =&gt; /usr/lib64/librz_crypto.so (0x00007f94b1016000)
librz_util.so =&gt; /usr/lib64/librz_util.so (0x00007f94b0d35000)
libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f94b0b15000)
libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f94b074d000)
librz_lang.so =&gt; /usr/lib64/librz_lang.so (0x00007f94b0546000)
librz_socket.so =&gt; /usr/lib64/librz_socket.so (0x00007f94b0339000)
libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f94affaf000)
libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f94afdab000)
/lib64/ld-linux-x86-64.so.2 (0x00007f94b4c79000)
libssl.so.1.0.0 =&gt; /usr/lib64/libssl.so.1.0.0 (0x00007f94afb3c000)
libcrypto.so.1.0.0 =&gt; /usr/lib64/libcrypto.so.1.0.0 (0x00007f94af702000)
libutil.so.1 =&gt; /lib64/libutil.so.1 (0x00007f94af4ff000)
libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f94af2e8000)
</code></pre>
<p>If you compare the outputs of <code>rz-bin -l</code> and <code>ldd</code>, you will notice that rz-bin lists fewer libraries than <code>ldd</code>. The reason is that rz-bin does not follow and does not show dependencies of libraries. Only direct binary dependencies are shown.</p>
<h2 id="strings-1"><a class="header" href="#strings-1">Strings</a></h2>
<p>The <code>-z</code> option is used to list readable strings found in the .rodata section of ELF binaries, or the .text section of PE files. Example:</p>
<pre><code>$ rz-bin -z /bin/ls | head
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
000 0x000160f8 0x000160f8  11  12 (.rodata) ascii dev_ino_pop
001 0x00016188 0x00016188  10  11 (.rodata) ascii sort_files
002 0x00016193 0x00016193   6   7 (.rodata) ascii posix-
003 0x0001619a 0x0001619a   4   5 (.rodata) ascii main
004 0x00016250 0x00016250  10  11 (.rodata) ascii ?pcdb-lswd
005 0x00016260 0x00016260  65  66 (.rodata) ascii # Configuration file for dircolors, a utility to help you set the
006 0x000162a2 0x000162a2  72  73 (.rodata) ascii # LS_COLORS environment variable used by GNU ls with the --color option.
007 0x000162eb 0x000162eb  56  57 (.rodata) ascii # Copyright (C) 1996-2018 Free Software Foundation, Inc.
008 0x00016324 0x00016324  70  71 (.rodata) ascii # Copying and distribution of this file, with or without modification,
009 0x0001636b 0x0001636b  76  77 (.rodata) ascii # are permitted provided the copyright notice and this notice are preserved.
</code></pre>
<p>With the <code>-zr</code> option, this information is represented as a rizin commands list. It can be used in a rizin session to automatically create a flag space called &quot;strings&quot; pre-populated with flags for all strings found by rz-bin.
Furthermore, this script will mark corresponding byte ranges as strings instead of code.</p>
<pre><code>$ rz-bin -zr /bin/ls | head
fs stringsf str.dev_ino_pop 12 @ 0x000160f8
Cs 12 @ 0x000160f8
f str.sort_files 11 @ 0x00016188
Cs 11 @ 0x00016188
f str.posix 7 @ 0x00016193
Cs 7 @ 0x00016193
f str.main 5 @ 0x0001619a
Cs 5 @ 0x0001619a
f str.pcdb_lswd 11 @ 0x00016250
Cs 11 @ 0x00016250
</code></pre>
<h2 id="program-sections"><a class="header" href="#program-sections">Program Sections</a></h2>
<p>rz-bin called with the <code>-S</code> option gives complete information about the sections of an executable. For each section the index, offset, size, alignment, type and permissions, are shown. The next example demonstrates this:</p>
<pre><code>$ rz-bin -S /bin/ls
[Sections]

nth paddr          size vaddr         vsize perm name
―――――――――――――――――――――――――――――――――――――――――――――――――――――
00 0x00000000     0 0x00000000     0 ----
01 0x00000238    28 0x00000238    28 -r-- .interp
02 0x00000254    32 0x00000254    32 -r-- .note.ABI_tag
03 0x00000278   176 0x00000278   176 -r-- .gnu.hash
04 0x00000328  3000 0x00000328  3000 -r-- .dynsym
05 0x00000ee0  1412 0x00000ee0  1412 -r-- .dynstr
06 0x00001464   250 0x00001464   250 -r-- .gnu.version
07 0x00001560   112 0x00001560   112 -r-- .gnu.version_r
08 0x000015d0  4944 0x000015d0  4944 -r-- .rela.dyn
09 0x00002920  2448 0x00002920  2448 -r-- .rela.plt
10 0x000032b0    23 0x000032b0    23 -r-x .init
11 0x000032d0  1648 0x000032d0  1648 -r-x .plt
12 0x00003940    24 0x00003940    24 -r-x .plt.got
13 0x00003960 73931 0x00003960 73931 -r-x .text
14 0x00015a2c     9 0x00015a2c     9 -r-x .fini
15 0x00015a40 20201 0x00015a40 20201 -r-- .rodata
16 0x0001a92c  2164 0x0001a92c  2164 -r-- .eh_frame_hdr
17 0x0001b1a0 11384 0x0001b1a0 11384 -r-- .eh_frame
18 0x0001e390     8 0x0021e390     8 -rw- .init_array
19 0x0001e398     8 0x0021e398     8 -rw- .fini_array
20 0x0001e3a0  2616 0x0021e3a0  2616 -rw- .data.rel.ro
21 0x0001edd8   480 0x0021edd8   480 -rw- .dynamic
22 0x0001efb8    56 0x0021efb8    56 -rw- .got
23 0x0001f000   840 0x0021f000   840 -rw- .got.plt
24 0x0001f360   616 0x0021f360   616 -rw- .data
25 0x0001f5c8     0 0x0021f5e0  4824 -rw- .bss
26 0x0001f5c8   232 0x00000000   232 ---- .shstrtab
</code></pre>
<p>With the <code>-Sr</code> option, rz-bin will flag the start/end of every section, and will pass the rest of information as a comment.</p>
<pre><code>$ rz-bin -Sr /bin/ls | head
fs sections
&quot;f section. 1 0x00000000&quot;
&quot;f section..interp 1 0x000002a8&quot;
&quot;f section..note.gnu.build_id 1 0x000002c4&quot;
&quot;f section..note.ABI_tag 1 0x000002e8&quot;
&quot;f section..gnu.hash 1 0x00000308&quot;
&quot;f section..dynsym 1 0x000003b8&quot;
&quot;f section..dynstr 1 0x00000fb8&quot;
&quot;f section..gnu.version 1 0x00001574&quot;
&quot;f section..gnu.version_r 1 0x00001678&quot;
</code></pre>
<h1 id="rz-diff-1"><a class="header" href="#rz-diff-1">Rz-diff</a></h1>
<p><code>rz-diff</code> is a tool designed to compare binary files, similar to how regular <code>diff</code> compares text files.</p>
<pre><code>$ rz-diff -h
Usage: rz-diff [options] &lt;file0&gt; &lt;file1&gt;
  -a [arch] specify architecture plugin to use (x86, arm, ..)
  -b [bits] specify register size for arch (16 (thumb), 32, 64, ..)
  -d [algo] compute edit distance based on the choosen algorithm:
              myers | Eugene W. Myers' O(ND) algorithm (no substitution)
              leven | Levenshtein O(N^2) algorithm (with substitution)
  -H        hexadecimal visual mode
  -h        this help message
  -j        json output
  -q        quite output
  -v        show version information
  -A        compare virtual and physical addresses
  -C        disable colors
  -T        show timestamp information
  -S [WxH]  sets the width and height of the terminal for visual mode
  -0 [cmd]  input for file0 when option -t 'commands' is given.
            the same value will be set for file1, if -1 is not set.
  -1 [cmd]  input for file1 when option -t 'commands' is given.
  -t [type] compute the difference between two files based on its type:
              bytes      | compares raw bytes in the files (only for small files)
              lines      | compares text files
              functions  | compares functions found in the files
              classes    | compares classes found in the files
              command    | compares command output returned when executed in both files
                         | requires -0 &lt;cmd&gt; and -1 &lt;cmd&gt; is optional
              entries    | compares entries found in the files
              fields     | compares fields found in the files
              graphs     | compares 2 functions and outputs in graphviz/dot format
                         | requires -0 &lt;fcn name|offset&gt; and -1 &lt;fcn name|offset&gt; is optional
              imports    | compares imports found in the files
              libraries  | compares libraries found in the files
              sections   | compares sections found in the files
              strings    | compares strings found in the files
              symbols    | compares symbols found in the files
  palette colors can be changed by adding the following lines
          inside the $HOME/.rizinrc file
  ec diff.unknown blue   | offset color
  ec diff.match   green  | match color
  ec diff.unmatch red    | mismatch color
</code></pre>
<h1 id="rz-diff-binary-and-text-diffing-utility"><a class="header" href="#rz-diff-binary-and-text-diffing-utility">Rz-Diff (binary and text diffing utility)</a></h1>
<h2 id="distance"><a class="header" href="#distance">Distance</a></h2>
<p>For bulk processing, you may want to have a higher-level overview of differences.</p>
<p>The <code>-d</code> option serves to calculate the distance between the two binaries using either myers algorithm or the levenshtein algorithm.</p>
<pre><code> -d --------&gt; myers (myers algorithm)
       |----&gt; leven (levenshtein algorithm)
</code></pre>
<h3 id="myers-algorithm"><a class="header" href="#myers-algorithm">Myers algorithm:</a></h3>
<p>In the <a href="https://epubs.siam.org/doi/10.1137/S0097539794264810">Myers</a> algorithm for edit distance, the cost of an insertion or deletion is 1 and the cost of a replacement is 2. 
The theorem leads directly to an O(k) algorithm for incrementally computing a new solution from an old one, as contrasts the O(k2 ) time required to compute a solution from scratch.
Thus the algorithm performs well when the two strings are similar. </p>
<p><code>rz-diff -d myers /bin/true /bin/false</code></p>
<p>output:</p>
<pre><code>similarity: 0.974
distance: 2046
</code></pre>
<h3 id="levenshtein-distance"><a class="header" href="#levenshtein-distance">Levenshtein distance:</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein</a> distance is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other.</p>
<p><code>rz-diff -d leven /bin/true /bin/false</code></p>
<p>output:</p>
<pre><code>similarity: 0.974
distance: 2046
</code></pre>
<h2 id="hexadecimal-diffing"><a class="header" href="#hexadecimal-diffing">Hexadecimal Diffing:</a></h2>
<p><code>-H</code> The hexadecimal displays the hexdump of file0 vs file1 in a side-by-side window. Navigational keys allows easily parsing through the hexdump of the files individually.</p>
<ul>
<li><code>1</code> and <code>2</code> : to move to the next or previous page.</li>
<li><code>Z</code> and <code>A</code> : allows parsing forward and backward through file0, byte by byte. </li>
<li><code>C</code> and <code>D</code> : allows parsing forward and backward through file1, byte by byte.</li>
<li><code>G</code> and <code>B</code> : seeks the end and beginning of the files.</li>
<li><code>N</code> and <code>M</code> : takes you to the Next and the Previous differing byte in the files respectively.</li>
<li><code>/\</code> and <code>\/</code> : parsing both binaries simultaneously, 16 bytes a time.</li>
<li><code>&lt;</code> and <code>&gt;</code> : parsing both binaries simultaneously, by 1 byte.</li>
<li><code>: &lt;seek address in hex/decimal&gt;</code> : seeks the address provided and bring the window to start dump from the seeked address.</li>
<li><code>?</code> : shows the help screen in the visual mode which can be exited with 'q'/esc keys.</li>
</ul>
<p>The bytes that differ are: <code>rz-diff -H /bin/true /bin/false</code></p>
<pre><code>.---------- [   0 | 9958]( true )-------------------------------------------------------------------- [   0 | 9958]( false )---------------------------------------------------------.
|                      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F                                             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F                     |
|0x0000000000000000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............ | 0x0000000000000000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............ |
|0x0000000000000010 | 03 00 3e 00 01 00 00 00 10 26 00 00 00 00 00 00  | ..&gt;......&amp;...... | 0x0000000000000010 | 03 00 3e 00 01 00 00 00 20 26 00 00 00 00 00 00  | ..&gt;..... &amp;...... |
|0x0000000000000020 | 40 00 00 00 00 00 00 00 d8 91 00 00 00 00 00 00  | @............... | 0x0000000000000020 | 40 00 00 00 00 00 00 00 d8 91 00 00 00 00 00 00  | @............... |
|0x0000000000000030 | 00 00 00 00 40 00 38 00 0d 00 40 00 1e 00 1d 00  | ....@.8...@..... | 0x0000000000000030 | 00 00 00 00 40 00 38 00 0d 00 40 00 1e 00 1d 00  | ....@.8...@..... |
|0x0000000000000040 | 06 00 00 00 04 00 00 00 40 00 00 00 00 00 00 00  | ........@....... | 0x0000000000000040 | 06 00 00 00 04 00 00 00 40 00 00 00 00 00 00 00  | ........@....... |
|0x0000000000000050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@....... | 0x0000000000000050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@....... |
|0x0000000000000060 | d8 02 00 00 00 00 00 00 d8 02 00 00 00 00 00 00  | ................ | 0x0000000000000060 | d8 02 00 00 00 00 00 00 d8 02 00 00 00 00 00 00  | ................ |
|0x0000000000000070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................ | 0x0000000000000070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................ |
|0x0000000000000080 | 18 03 00 00 00 00 00 00 18 03 00 00 00 00 00 00  | ................ | 0x0000000000000080 | 18 03 00 00 00 00 00 00 18 03 00 00 00 00 00 00  | ................ |
|0x0000000000000090 | 18 03 00 00 00 00 00 00 1c 00 00 00 00 00 00 00  | ................ | 0x0000000000000090 | 18 03 00 00 00 00 00 00 1c 00 00 00 00 00 00 00  | ................ |

...
|0x00000000000002f0 | 30 9c 00 00 00 00 00 00 30 9c 00 00 00 00 00 00  | 0.......0....... | 0x00000000000002f0 | 30 9c 00 00 00 00 00 00 30 9c 00 00 00 00 00 00  | 0.......0....... |
|0x0000000000000300 | d0 03 00 00 00 00 00 00 d0 03 00 00 00 00 00 00  | ................ | 0x0000000000000300 | d0 03 00 00 00 00 00 00 d0 03 00 00 00 00 00 00  | ................ |
`------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'
 1 2 -/+0x320 | Z A file0 +/-1 | C D file1 +/-1 | G B end/begin | N M next/prev | \//\ +/-16 | &lt; &gt;  +/-1 | : seek

</code></pre>
<p><code>-S</code> mode allows you to adjust the window size of the hexadecimal view to your preference.
Minimmum: <code>W = 120 H = 20</code></p>
<p>Example : <code>rz-diff -HS 120x20 /bin/true /bin/false</code></p>
<h3 id="file-type-based-diffing"><a class="header" href="#file-type-based-diffing">File Type Based Diffing</a></h3>
<p><code>t</code> option computes the difference between two files based on its type.</p>
<pre><code> -t --------&gt; bytes (raw bytes in the files)
       |----&gt; lines (compares text files)
       |----&gt; functions (compares functions found in the files)
       |----&gt; classes (compares classes found in the files)
       |----&gt; command (compares command output returned when executed)
       |----&gt; entries (compares entries found in the files)
       |----&gt; fields (compares fields found in the files)
       |----&gt; graphs (compares 2 functions and outputs in graphviz/dot      format)
       |----&gt; format (compares text files)
       |----&gt; imports (compares imports found in the files)
       |----&gt; libraries (compares libraries found in the files)
       |----&gt; sections (compares sections found in the files)
       |----&gt; strings (compares sections found in the files)
       |----&gt; symbols (compares symbols found in the files)

</code></pre>
<h3 id="diffing-ascii-text-files"><a class="header" href="#diffing-ascii-text-files">Diffing ASCII-text files:</a></h3>
<p><code> $ rz-diff -t lines genuine cracked</code></p>
<pre><code>--- genuine
+++ cracked
@@ -1,1 +1,1 @@
-hello1234567890
+1234567890hello
</code></pre>
<h3 id="diffing-functions-in-binaries"><a class="header" href="#diffing-functions-in-binaries">Diffing functions in binaries:</a></h3>
<p>It this mode, it will give you three columns for all functions: &quot;First file offset&quot;, &quot;Percentage of matching&quot; and &quot;Second file offset&quot;.</p>
<p><code> $ rz-diff -t functions /bin/true /bin/false</code></p>
<pre><code>         sym.imp.__fprintf_chk   11 0x00000000000024e0 | MATCH   (1.000000) | 0x00000000000024e0    11 sym.imp.__fprintf_chk
               sym.imp.mbsinit   11 0x00000000000024f0 | MATCH   (1.000000) | 0x00000000000024f0    11 sym.imp.mbsinit
              sym.imp.iswprint   11 0x0000000000002500 | MATCH   (1.000000) | 0x0000000000002500    11 sym.imp.iswprint
         sym.imp.__ctype_b_loc   11 0x0000000000002510 | MATCH   (1.000000) | 0x0000000000002510    11 sym.imp.__ctype_b_loc
                  fcn.00002640   34 0x0000000000002640 | UNMATCH (0.058824) | 0x0000000000002650    34 fcn.00002650
                  fcn.00002700  840 0x0000000000002700 | UNMATCH (0.221163) | 0x0000000000002710   840 fcn.00002710
                  fcn.00002b30  176 0x0000000000002b30 | UNMATCH (0.173077) | 0x0000000000002b40   176 fcn.00002b40
                  fcn.00002bf0  208 0x0000000000002bf0 | SIMILAR (0.961538) | 0x0000000000002c00   208 fcn.00002c00
                  fcn.00002cd0 4627 0x0000000000002cd0 | SIMILAR (0.993949) | 0x0000000000002ce0  4627 fcn.00002ce0
</code></pre>
<h3 id="diffing-classes-in-binaries"><a class="header" href="#diffing-classes-in-binaries">Diffing classes in binaries:</a></h3>
<p><code>rz-diff -t functions /bin/true /bin/false</code></p>
<pre><code>--- /bin/true
+++ /bin/false
</code></pre>
<h3 id="commands-1"><a class="header" href="#commands-1">Commands</a></h3>
<h3 id="diffing-entries-in-binaries"><a class="header" href="#diffing-entries-in-binaries">Diffing entries in binaries</a></h3>
<p><code>rz-diff -t entries /bin/true /bin/false</code></p>
<pre><code>--- /bin/true
+++ /bin/false
@@ -1,3 +1,3 @@
-virt: 0x00000000000026f0 phys: 0x00000000000026f0 entry init
-virt: 0x00000000000026b0 phys: 0x00000000000026b0 entry fini
-virt: 0x0000000000002610 phys: 0x0000000000002610 entry program
+virt: 0x0000000000002700 phys: 0x0000000000002700 entry init
+virt: 0x00000000000026c0 phys: 0x00000000000026c0 entry fini
+virt: 0x0000000000002620 phys: 0x0000000000002620 entry program

</code></pre>
<h3 id="diffing-fields-in-binaries"><a class="header" href="#diffing-fields-in-binaries">Diffing fields in binaries:</a></h3>
<p><code>rz-diff -t fields /bin/true /bin/false </code></p>
<pre><code>--- /bin/true
+++ /bin/false
</code></pre>
<h3 id="diffing-sections-in-binaries"><a class="header" href="#diffing-sections-in-binaries">Diffing sections in binaries:</a></h3>
<p><code>rz-diff -t sections /bin/true /bin/false</code></p>
<pre><code>
--- /bin/true
+++ /bin/false
</code></pre>
<h3 id="diffing-strings-in-binaries"><a class="header" href="#diffing-strings-in-binaries">Diffing strings in binaries:</a></h3>
<p><code>rz-diff -t strings /bin/true /bin/false</code></p>
<pre><code>--- /bin/true
+++ /bin/false
@@ -11,7 +11,7 @@
 Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n
 Copyright %s %d Free Software Foundation, Inc.
       --help     display this help and exit\n
-Exit with a status code indicating success.
+Exit with a status code indicating failure.
 Written by %s, %s, %s,\n%s, %s, %s, and %s.\n
 Written by %s, %s, %s,\n%s, %s, and %s.\n
 https://www.gnu.org/software/coreutils/
@@ -51,7 +51,7 @@
 --help
 ASCII
 POSIX
+false
 shell
 %s\n\n
 8.30
-true

</code></pre>
<h3 id="diffing-symbols-in-binaries"><a class="header" href="#diffing-symbols-in-binaries">Diffing symbols in binaries:</a></h3>
<p><code>rz-diff -t symbols /bin/true /bin/false</code></p>
<pre><code>--- /bin/true
+++ /bin/false
</code></pre>
<h1 id="rz-asm-1"><a class="header" href="#rz-asm-1">Rz-asm</a></h1>
<p><code>rz-asm</code> is an inline assembler/disassembler. Its main function is to get bytes corresponding to given machine instruction opcode.</p>
<pre><code>$ rz-asm -h
Usage: rz-asm [-ACdDehLBvw] [-a arch] [-b bits] [-o addr] [-s syntax]
             [-f file] [-F fil:ter] [-i skip] [-l len] 'code'|hex|-
 -a [arch]    Set architecture to assemble/disassemble (see -L)
 -A           Show Analysis information from given hexpairs
 -b [bits]    Set cpu register size (8, 16, 32, 64) (RASM2_BITS)
 -B           Binary input/output (-l is mandatory for binary input)
 -c [cpu]     Select specific CPU (depends on arch)
 -C           Output in C format
 -d, -D       Disassemble from hexpair bytes (-D show hexpairs)
 -e           Use big endian instead of little endian
 -E           Display ESIL expression (same input as in -d)
 -f [file]    Read data from file
 -F [in:out]  Specify input and/or output filters (att2intel, x86.pseudo, ...)
 -h, -hh      Show this help, -hh for long
 -i [len]     ignore/skip N bytes of the input buffer
 -j           output in json format
 -k [kernel]  Select operating system (linux, windows, darwin, ..)
 -l [len]     Input/Output length
 -L           List Asm plugins: (a=asm, d=disasm, A=analyze, e=ESIL)
 -o [offset]  Set start address for code (default 0)
 -O [file]    Output file name (rz-asm -Bf a.asm -O a)
 -p           Run SPP over input for assembly
 -q           quiet mode
 -r           output in rizin commands
 -s [syntax]  Select syntax (intel, att)
 -v           Show version information
 -w           What's this instruction for? describe opcode
 If '-l' value is greater than output length, output is padded with nops
 If the last argument is '-' reads from stdin
Environment:
 RASM2_NOPLUGINS  do not load shared plugins (speedup loading)
 RASM2_ARCH       same as rz-asm -a
 RASM2_BITS       same as rz-asm -b
 R_DEBUG          if defined, show error messages and crash signal

</code></pre>
<p>Plugins for supported target architectures can be listed with the <code>-L</code> option. Knowing a plugin name, you can use it by specifying its name to the <code>-a</code> option</p>
<pre><code>$ rz-asm -L
_dAe  8 16       6502        LGPL3   6502/NES/C64/Tamagotchi/T-1000 CPU
_dAe  8          8051        PD      8051 Intel CPU
_dA_  16 32      arc         GPL3    Argonaut RISC Core
a___  16 32 64   arm.as      LGPL3   as ARM Assembler (use ARM_AS environment)
adAe  16 32 64   arm         BSD     Capstone ARM disassembler
_dA_  16 32 64   arm.gnu     GPL3    Acorn RISC Machine CPU
_d__  16 32      arm.winedbg LGPL2   WineDBG's ARM disassembler
adAe  8 16       avr         GPL     AVR Atmel
adAe  16 32 64   bf          LGPL3   Brainfuck (by pancake, nibble) v4.0.0
_dA_  32         chip8       LGPL3   Chip8 disassembler
_dA_  16         cr16        LGPL3   cr16 disassembly plugin
_dA_  32         cris        GPL3    Axis Communications 32-bit embedded processor
adA_  32 64      dalvik      LGPL3   AndroidVM Dalvik
ad__  16         dcpu16      PD      Mojang's DCPU-16
_dA_  32 64      ebc         LGPL3   EFI Bytecode
adAe  16         gb          LGPL3   GameBoy(TM) (z80-like)
_dAe  16         h8300       LGPL3   H8/300 disassembly plugin
_dAe  32         hexagon     LGPL3   Qualcomm Hexagon (QDSP6) V6
_d__  32         hppa        GPL3    HP PA-RISC
_dAe             i4004       LGPL3   Intel 4004 microprocessor
_dA_  8          i8080       BSD     Intel 8080 CPU
adA_  32         java        Apache  Java bytecode
_d__  32         lanai       GPL3    LANAI
_d__  8          lh5801      LGPL3   SHARP LH5801 disassembler
_d__  32         lm32        BSD     disassembly plugin for Lattice Micro 32 ISA
_dA_  16 32      m68k        BSD     Capstone M68K disassembler
_dA_  32         malbolge    LGPL3   Malbolge Ternary VM
_d__  16         mcs96       LGPL3   condrets car
adAe  16 32 64   mips        BSD     Capstone MIPS disassembler
adAe  32 64      mips.gnu    GPL3    MIPS CPU
_dA_  16         msp430      LGPL3   msp430 disassembly plugin
_dA_  32         nios2       GPL3    NIOS II Embedded Processor
_dAe  8          pic         LGPL3   PIC disassembler
_dAe  32 64      ppc         BSD     Capstone PowerPC disassembler
_dA_  32 64      ppc.gnu     GPL3    PowerPC
_d__  32         propeller   LGPL3   propeller disassembly plugin
_dA_  32 64      riscv       GPL     RISC-V
_dAe  32         rsp         LGPL3   Reality Signal Processor
_dAe  32         sh          GPL3    SuperH-4 CPU
_dA_  8 16       snes        LGPL3   SuperNES CPU
_dAe  32 64      sparc       BSD     Capstone SPARC disassembler
_dA_  32 64      sparc.gnu   GPL3    Scalable Processor Architecture
_d__  16         spc700      LGPL3   spc700, snes' sound-chip
_d__  32         sysz        BSD     SystemZ CPU disassembler
_dA_  32         tms320      LGPLv3  TMS320 DSP family (c54x,c55x,c55x+,c64x)
_d__  32         tricore     GPL3    Siemens TriCore CPU
_dAe  32         v810        LGPL3   v810 disassembly plugin
_dAe  32         v850        LGPL3   v850 disassembly plugin
_dAe  8 32       vax         GPL     VAX
adA_  32         wasm        MIT     WebAssembly (by cgvwzq) v0.1.0
_dA_  32         ws          LGPL3   Whitespace esotheric VM
a___  16 32 64   x86.as      LGPL3   Intel X86 GNU Assembler
_dAe  16 32 64   x86         BSD     Capstone X86 disassembler
a___  16 32 64   x86.nasm    LGPL3   X86 nasm assembler
a___  16 32 64   x86.nz      LGPL3   x86 handmade assembler
_dA_  16         xap         PD      XAP4 RISC (CSR)
_dA_  32         xcore       BSD     Capstone XCore disassembler
_dAe  32         xtensa      GPL3    XTensa CPU
adA_  8          z80         GPL     Zilog Z80
</code></pre>
<blockquote>
<p>Note that &quot;ad&quot; in the first column means both assembler and disassembler are offered by a corresponding  plugin. &quot;<em>d&quot; indicates disassembler, &quot;a</em>&quot; means only assembler is available.</p>
</blockquote>
<h2 id="assembler"><a class="header" href="#assembler">Assembler</a></h2>
<p>Assembling is the action to take a computer instruction in human readable form (using mnemonics) and convert that into a bunch of bytes that can be executed by a machine.</p>
<p>In rizin, the assembler and disassembler logic is implemented in the rz_asm_* API, and can be used with the pa and pad commands from the commandline as well as using <code>rz-asm</code>.</p>
<p>Rz-asm can be used to quickly copy-paste hexpairs that represent a given machine instruction. The following line is assembling this mov instruction for x86/32.</p>
<pre><code>$ rz-asm -a x86 -b 32 'mov eax, 33'
b821000000
</code></pre>
<p>Apart from the specifying the input as an argument, you can also pipe it to rz-asm:</p>
<pre><code>$ echo 'push eax;nop;nop' | rz-asm -f -
5090
</code></pre>
<p>As you have seen, rz-asm can assemble one or many instructions. In line by separating them with a semicolon <code>;</code>, but can also read that from a file, using generic nasm/gas/.. syntax and directives. You can check the rz-asm manpage for more details on this.</p>
<p>The <code>pa</code> and <code>pad</code> are a subcommands of print, what means they will only print assembly or disassembly. In case you want to actually write the instruction it is required to use <code>wa</code> or <code>wx</code> commands with the assembly string or bytes appended.</p>
<p>The assembler understands the following input languages and their flavors: <code>x86</code> (Intel and AT&amp;T variants), <code>olly</code> (OllyDBG syntax), <code>powerpc</code> (PowerPC), <code>arm</code> and <code>java</code>. For Intel syntax, rz-asm tries to mimic NASM or GAS.</p>
<p>There are several examples in the rz-asm source code directory. Consult them to understand how you can assemble a raw binary file from a rz-asm description.</p>
<p>Lets create an assembly file called <code>selfstop.rzasm</code>:</p>
<pre><code class="language-asm">;
; Self-Stop shellcode written in rz-asm for x86
;
; --pancake
;

.arch x86
.equ base 0x8048000
.org 0x8048000  ; the offset where we inject the 5 byte jmp

selfstop:
  push 0x8048000
  pusha
  mov eax, 20
  int 0x80

  mov ebx, eax
  mov ecx, 19
  mov eax, 37
  int 0x80
  popa
  ret
;
; The call injection
;

  ret
</code></pre>
<p>Now we can assemble it in place:</p>
<pre><code>[0x00000000]&gt; e asm.bits=32
[0x00000000]&gt; wx `!rz-asm -f a.rzasm`
[0x00000000]&gt; pd 20
	   0x00000000    6800800408   push 0x8048000 ;  0x08048000
	   0x00000005    60           pushad
	   0x00000006    b814000000   mov eax, 0x14 ;  0x00000014
	   0x0000000b    cd80         int 0x80
		  syscall[0x80][0]=?
	   0x0000000d    89c3         mov ebx, eax
	   0x0000000f    b913000000   mov ecx, 0x13 ;  0x00000013
	   0x00000014    b825000000   mov eax, 0x25 ;  0x00000025
	   0x00000019    cd80         int 0x80
		  syscall[0x80][0]=?
	   0x0000001b    61           popad
	   0x0000001c    c3           ret
	   0x0000001d    c3           ret
</code></pre>
<h3 id="visual-mode-1"><a class="header" href="#visual-mode-1">Visual mode</a></h3>
<p>Assembling also is accessible in rizin visual mode through pressing <code>A</code> key to insert the assembly in the current offset.</p>
<p>The cool thing of writing assembly using the visual assembler interface that the changes are done in memory until you press enter.</p>
<p>So you can check the size of the code and which instructions is overlapping before committing the changes.</p>
<h2 id="disassembler"><a class="header" href="#disassembler">Disassembler</a></h2>
<p>Disassembling is the inverse action of assembling. Rasm2 takes hexpair as an input (but can also take a file in binary form) and show the human readable form.</p>
<p>To do this we can use the <code>-d</code> option of rz-asm like this:</p>
<pre><code>$ rz-asm -a x86 -b 32 -d '90'
nop
</code></pre>
<p>Rasm2 also have the <code>-D</code> flag to show the disassembly like <code>-d</code> does, but includes offset and bytes.</p>
<p>In rizin there are many commands to perform a disassembly from a specific place in memory.</p>
<p>You might be interested in trying if you want different outputs for later parsing with your scripts, or just grep to find what you are looking for:</p>
<h3 id="pd-n"><a class="header" href="#pd-n">pd N</a></h3>
<p>Disassemble N instructions</p>
<h3 id="pd-n-1"><a class="header" href="#pd-n-1">pD N</a></h3>
<p>Disassemble N bytes</p>
<h3 id="pda"><a class="header" href="#pda">pda</a></h3>
<p>Disassemble all instructions (seeking 1 byte, or the minimum alignment instruction size), which can be useful for ROP</p>
<h2 id="pi-pi"><a class="header" href="#pi-pi">pi, pI</a></h2>
<p>Same as <code>pd</code> and <code>pD</code>, but using a simpler output.</p>
<h2 id="disassembler-configuration"><a class="header" href="#disassembler-configuration">Disassembler Configuration</a></h2>
<p>The assembler and disassembler have many small switches to tweak the output.</p>
<p>Those configurations are available through the <code>e</code> command. Here there are the most common ones:</p>
<ul>
<li>asm.bytes - show/hide bytes</li>
<li>asm.offset - show/hide offset</li>
<li>asm.lines - show/hide lines</li>
<li>asm.ucase - show disasm in uppercase</li>
<li>...</li>
</ul>
<p>Use the <code>el asm.</code> for more details.</p>
<h1 id="rz-gg"><a class="header" href="#rz-gg">Rz-gg</a></h1>
<p>rz-gg stands for <code>rizin egg</code>, this is the basic block to construct relocatable
snippets of code to be used for injection in target processes when doing exploiting.</p>
<p>rz-gg compiles programs written in a simple high-level language into tiny binaries
for x86, x86-64, and ARM.</p>
<p>You can also access all the rz-gg commands from the rizin shell. They are present
under <code>g</code>. See <code>g?</code> for more information about how to use them.</p>
<p>By default it will compile it's own <code>rz-gg</code> language, but you can also compile C
code using GCC or Clang shellcodes depending on the file extension. Lets create
C file called <code>helloworld.c</code>:</p>
<pre><code class="language-c">int main() {
	write(1, &quot;Hello World\n&quot;, 13);
	return 0;
}
</code></pre>
<pre><code>$ rz-gg -a x86 -b32 helloworld.c
e900000000488d3516000000bf01000000b80400000248c7c20d0000000f0531c0c348656c6c6f20576f726c640a00

$ rz-asm -a x86 -b 32 -D e900000000488d3516000000bf01000000b80400000248c7c20d0000000f0531c0c348656c6c6f20576f726c640a00
0x00000000   5               e900000000  jmp 5
0x00000005   1                       48  dec eax
0x00000006   6             8d3516000000  lea esi, [0x16]
0x0000000c   5               bf01000000  mov edi, 1
0x00000011   5               b804000002  mov eax, 0x2000004
0x00000016   1                       48  dec eax
0x00000017   6             c7c20d000000  mov edx, 0xd
0x0000001d   2                     0f05  syscall
0x0000001f   2                     31c0  xor eax, eax
0x00000021   1                       c3  ret
0x00000022   1                       48  dec eax
0x00000023   2                     656c  insb byte es:[edi], dx
0x00000025   1                       6c  insb byte es:[edi], dx
0x00000026   1                       6f  outsd dx, dword [esi]
0x00000027   3                   20576f  and byte [edi + 0x6f], dl
0x0000002a   2                     726c  jb 0x98
0x0000002c   3                   640a00  or al, byte fs:[eax]
</code></pre>
<h2 id="compiling-rz-gg-example"><a class="header" href="#compiling-rz-gg-example">Compiling rz-gg example</a></h2>
<pre><code>$ cat hello.r
exit@syscall(1);

main@global() {
	exit(2);
}

$ rz-gg -a x86 -b 64 hello.r
48c7c00200000050488b3c2448c7c0010000000f054883c408c3
0x00000000   1                       48  dec eax
0x00000001   6             c7c002000000  mov eax, 2
0x00000007   1                       50  push eax
0x00000008   1                       48  dec eax
0x00000009   3                   8b3c24  mov edi, dword [esp]
0x0000000c   1                       48  dec eax
0x0000000d   6             c7c001000000  mov eax, 1
0x00000013   2                     0f05  syscall
0x00000015   1                       48  dec eax
0x00000016   3                   83c408  add esp, 8
0x00000019   1                       c3  ret

$ rz-asm -a x86 -b 64 -D 48c7c00200000050488b3c2448c7c0010000000f054883c408c3
0x00000000   7           48c7c002000000  mov rax, 2
0x00000007   1                       50  push rax
0x00000008   4                 488b3c24  mov rdi, qword [rsp]
0x0000000c   7           48c7c001000000  mov rax, 1
0x00000013   2                     0f05  syscall
0x00000015   4                 4883c408  add rsp, 8
0x00000019   1                       c3  ret
</code></pre>
<p>You can also compile for ARM. For that, specify the architecture as <code>arm</code>:</p>
<pre><code>$ rz-gg -a arm -b 32 hello.r
00482de90200a0e30c008de508109de50170a0e3000000ef0088bde8

$ rz-asm -a arm -b 32 -D 00482de90200a0e30c008de508109de50170a0e3000000ef0088bde8
0x00000000   4                 00482de9  push {fp, lr}
0x00000004   4                 0200a0e3  mov r0, 2
0x00000008   4                 0c008de5  str r0, [sp, 0xc]
0x0000000c   4                 08109de5  ldr r1, [sp, 8]
0x00000010   4                 0170a0e3  mov r7, 1
0x00000014   4                 000000ef  svc 0
0x00000018   4                 0088bde8  pop {fp, pc}
</code></pre>
<h2 id="tiny-binaries"><a class="header" href="#tiny-binaries">Tiny binaries</a></h2>
<p>You can create tiny binaries for your code using the <code>-F</code> flag in rz-gg,
or the <code>-C</code> in rz-bin.</p>
<pre><code class="language-c">$ cat helloworld.r
int main() {
	write(1, &quot;Hello World\n&quot;, 13);
	return 0;
}

$ rz-gg -O -F helloworld.c

$ ./helloworld
Hello World

$ wc -c &lt; helloworld
259
</code></pre>
<p>We can see that the size of the binary is just 259 bytes.</p>
<h2 id="output-format"><a class="header" href="#output-format">Output format</a></h2>
<p>You can change the output format using the <code>-f</code> flag. Here's an example of
changing it to python:</p>
<pre><code>$ rz-gg -O -F -f python helloworld.r

$ xxd helloworld | head -n 3
00000000: 696d 706f 7274 2073 7472 7563 740a 6275  import struct.bu
00000010: 6620 3d20 7374 7275 6374 2e70 6163 6b20  f = struct.pack
00000020: 2822 3133 3942 222c 202a 5b0a 3078 3535  (&quot;139B&quot;, *[.0x55
</code></pre>
<p>You can set the output format to C, PE, ELF, Mach-O, raw, python or javascript.</p>
<h1 id="syntax-of-the-language"><a class="header" href="#syntax-of-the-language">Syntax of the language</a></h1>
<p>The code of rz_egg is compiled as in a flow. It is a one-pass compiler;</p>
<p>this means that you have to define the proper stackframe size at the</p>
<p>beginning of the function, and you have to define the functions in</p>
<p>order to avoid getting compilation errors.</p>
<p>The compiler generates assembly code for x86-{32,64} and arm. But it aims</p>
<p>to support more platforms. This code is the compiled with rz_asm and</p>
<p>injected into a tiny binary with rz_bin.</p>
<p>You may like to use rz_egg to create standalone binaries, position-</p>
<p>independent raw eggs to be injected on running processes or to patch</p>
<p>on-disk binaries.</p>
<p>The generated code is not yet optimized, but it's safe to be executed</p>
<p>at any place in the code.</p>
<h2 id="preprocessor"><a class="header" href="#preprocessor">Preprocessor</a></h2>
<h3 id="aliases-1"><a class="header" href="#aliases-1">Aliases</a></h3>
<p>Sometimes you just need to replace at compile time a single entity on</p>
<p>multiple places. Aliases are translated into 'equ' statements in assembly</p>
<p>language. This is just an assembler-level keyword redefinition.</p>
<p><code> AF_INET@alias(2);</code></p>
<p><code> printf@alias(0x8053940);</code></p>
<h3 id="includes"><a class="header" href="#includes">Includes</a></h3>
<p>Use <code>cat(1)</code> or the preprocessor to concatenate multiple files to be compiled.</p>
<p><code> INCDIR@alias(&quot;/usr/include/rz-gg&quot;);</code></p>
<p><code> sys-osx.r@include(INCDIR);</code></p>
<h3 id="hashbang"><a class="header" href="#hashbang">Hashbang</a></h3>
<p>eggs can use a hashbang to make them executable.</p>
<p><code>$ head -n1 hello.r</code></p>
<p><code> #!/usr/bin/rz-gg -X</code></p>
<p><code> $ ./hello.r</code></p>
<p><code> Hello World!</code></p>
<h3 id="main"><a class="header" href="#main">Main</a></h3>
<p>The execution of the code is done as in a flow. The first function to be</p>
<p>defined will be the first one to be executed. If you want to run main()</p>
<p>just do like this:</p>
<p><code> #!/usr/bin/rz-gg -X</code></p>
<p><code> main();</code></p>
<p><code> ...</code></p>
<p><code> main@global(128,64) {</code></p>
<p><code> ...</code></p>
<h3 id="function-definition"><a class="header" href="#function-definition">Function definition</a></h3>
<p>You may like to split up your code into several code blocks. Those blocks</p>
<p>are bound to a label followed by root brackets '{ ... }'</p>
<h3 id="function-signatures"><a class="header" href="#function-signatures">Function signatures</a></h3>
<p><code>name@type(stackframesize,staticframesize) { body }</code></p>
<p><code>name</code> : name of the function to define</p>
<p><code>type</code> : see function types below</p>
<p><code>stackframesize</code> : get space from stack to store local variables</p>
<p><code>staticframesize</code> : get space from stack to store static variables (strings)</p>
<p><code>body</code> : code of the function</p>
<h3 id="function-types"><a class="header" href="#function-types">Function types</a></h3>
<p><code>alias</code>   Used to create aliases</p>
<p><code>data</code> ; the body of the block is defined in .data</p>
<p><code>inline</code> ; the function body is inlined when called</p>
<p><code>global</code> ; make the symbol global</p>
<p><code>fastcall</code> ; function that is called using the fast calling convention</p>
<p><code>syscall</code>  ; define syscall calling convention signature</p>
<h3 id="syscalls-1"><a class="header" href="#syscalls-1">Syscalls</a></h3>
<p>r_egg offers a syntax sugar for defining syscalls. The syntax is like this:</p>
<p><code> exit@syscall(1);</code></p>
<p><code> @syscall() {</code></p>
<p>`` : mov eax, `.arg```</p>
<p><code> : int 0x80</code></p>
<p><code> }</code></p>
<p><code> main@global() {</code></p>
<p><code> exit (0);</code></p>
<p><code> }</code></p>
<h3 id="libraries"><a class="header" href="#libraries">Libraries</a></h3>
<p>At the moment there is no support for linking r_egg programs to system</p>
<p>libraries. but if you inject the code into a program (disk/memory) you</p>
<p>can define the address of each function using the @alias syntax.</p>
<h3 id="core-library"><a class="header" href="#core-library">Core library</a></h3>
<p>There's a work-in-progress libc-like library written completely in r_egg</p>
<h3 id="variables-1"><a class="header" href="#variables-1">Variables</a></h3>
<p><code>.arg</code></p>
<p><code>.arg0</code></p>
<p><code>.arg1</code></p>
<p><code>.arg2</code></p>
<p><code>.var0</code></p>
<p><code>.var2</code></p>
<p><code>.fix</code></p>
<p><code>.ret ; eax for x86, r0 for arm</code></p>
<p><code>.bp</code></p>
<p><code>.pc</code></p>
<p><code>.sp</code></p>
<p><strong>Attention:</strong> All the numbers after <code>.var</code> and <code>.arg</code> mean the offset with the</p>
<p>top of stack, not variable symbols.</p>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Supported as raw pointers. TODO: enhance this feature</p>
<h3 id="tracing"><a class="header" href="#tracing">Tracing</a></h3>
<p>Sometimes r_egg programs will break or just not work as expected. Use the</p>
<p>'trace' architecture to get a arch-backend call trace:</p>
<p><code> $ rz-gg -a trace -s yourprogram.r</code></p>
<h3 id="pointers"><a class="header" href="#pointers">Pointers</a></h3>
<p>TODO: Theoretically '*' is used to get contents of a memory pointer.</p>
<h3 id="virtual-registers"><a class="header" href="#virtual-registers">Virtual registers</a></h3>
<p>TODO: a0, a1, a2, a3, sp, fp, bp, pc</p>
<h3 id="math-operations"><a class="header" href="#math-operations">Math operations</a></h3>
<p>rz-gg supports local variables assignment by math operating, including</p>
<p>the following operators:</p>
<p><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>&amp;</code> <code>|</code> <code>^</code></p>
<h3 id="return-values"><a class="header" href="#return-values">Return values</a></h3>
<p>The return value is stored in the a0 register, this register is set when</p>
<p>calling a function or when typing a variable name without assignment.</p>
<pre><code>$ cat test.r
add@global(4) {
	.var0 = .arg0 + .arg1;
	.var0;
}

main@global() {
	add (3,4);
}

$ rz-gg -F -o test test.r
$ ./test
$ echo $?
7
</code></pre>
<h3 id="traps"><a class="header" href="#traps">Traps</a></h3>
<p>Each architecture have a different instruction to break the execution of</p>
<p>the program. RzEgg language captures calls to 'break()' to run the emit_trap</p>
<p>callback of the selected arch. The</p>
<p><code> break()</code>; --&gt; compiles into 'int3' on x86</p>
<p><code> break;</code> --&gt; compiles into 'int3' on x86</p>
<h3 id="inline-assembly"><a class="header" href="#inline-assembly">Inline assembly</a></h3>
<p>Lines prefixed with ':' char are just inlined in the output assembly.</p>
<p><code> : jmp 0x8048400</code></p>
<p><code> : .byte 33,44</code></p>
<h3 id="labels"><a class="header" href="#labels">Labels</a></h3>
<p>You can define labels using the <code>:</code> keyword like this:</p>
<p><code> :label_name:</code></p>
<p><code> /* loop forever */</code></p>
<p><code> goto(label_name</code>)</p>
<h3 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h3>
<p><code> goto (addr)</code> -- branch execution</p>
<p><code> while (cond)</code></p>
<p><code> if (cond)</code></p>
<p><code> if (cond) { body } else { body }</code></p>
<p><code> break ()</code> -- executes a trap instruction</p>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>Supported syntax for comments are:</p>
<p><code> /* multiline comment */'</code></p>
<p><code> // single line comment</code></p>
<p><code> # single line comment</code></p>
<h1 id="rz-hash-1"><a class="header" href="#rz-hash-1">Rz-hash</a></h1>
<p>The <code>rz-hash</code> tool can be used to compute checksums of files, disk devices or strings. By block or entirely using many different hash algorithms.</p>
<p>This tool is also capable of doing some encoding/decoding operations like base64 and xor encoding.</p>
<p>This is an example usage:</p>
<pre><code>$ rz-hash -a md5 -s &quot;hello world&quot;
</code></pre>
<p>Note that rz-hash also permits to read from files in a stream, so you don't need 4GB of ram to compute the hash of a 4GB file.</p>
<h2 id="hashing-by-blocks"><a class="header" href="#hashing-by-blocks">Hashing by blocks</a></h2>
<p>When doing forensics, it is useful to compute partial checksums. The reason for that is because you may want to split a huge file into small portions that are easier to identify by contents or regions in the disk.</p>
<p>This will spot the same hash for blocks containing the same contents. For example, if is filled with zeros.</p>
<p>It can also be used to find which blocks have changed between more than one sample dump.</p>
<p>This can be useful when analyzing ram dumps from a virtual machine for example. Use this command for this:</p>
<pre><code>$ rz-hash -b 1M -B -a sha256 /bin/ls
</code></pre>
<h2 id="hashing-with-rz-bin"><a class="header" href="#hashing-with-rz-bin">Hashing with rz-bin</a></h2>
<p>The rz-bin tool parses the binary headers of the files, but it also have the ability to use the rhash plugins to compute checksum of sections in the binary.</p>
<pre><code>$ rz-bin -K md5 -S /bin/ls
</code></pre>
<h2 id="obtaining-hashes-within-rizin-session"><a class="header" href="#obtaining-hashes-within-rizin-session">Obtaining hashes within rizin session</a></h2>
<p>To calculate a checksum of current block when running rizin, use the <code>ph</code> command. Pass an algorithm name to it as a parameter. An example session:</p>
<pre><code>$ rizin /bin/ls
[0x08049790]&gt; bf entry0
[0x08049790]&gt; ph md5
d2994c75adaa58392f953a448de5fba7
</code></pre>
<p>You can use all hashing algorithms supported by <code>rz-hash</code>:</p>
<pre><code>[0x00000000]&gt; ph?
algorithm      license    author
md4            LGPL3      deroad
md5            RSA-MD     RSA Data Security, Inc.
sha1           LGPL3      deroad
sha256         BSD-3      Aaron D. Gifford
sha384         BSD-3      Aaron D. Gifford
sha512         BSD-3      Aaron D. Gifford
fletcher8      LGPL3      deroad
fletcher16     LGPL3      deroad
fletcher32     LGPL3      deroad
fletcher64     LGPL3      deroad
adler32        LGPL3      deroad
crc8smbus      LGPL3      deroad
crc8cdma2000   LGPL3      deroad
crc8darc       LGPL3      deroad
crc8dvbs2      LGPL3      deroad
crc8ebu        LGPL3      deroad
crc8icode      LGPL3      deroad
crc8itu        LGPL3      deroad
crc8maxim      LGPL3      deroad
crc8rohc       LGPL3      deroad
crc8wcdma      LGPL3      deroad
crc15can       LGPL3      deroad
crc16          LGPL3      deroad
crc16citt      LGPL3      deroad
crc16usb       LGPL3      deroad
crc16hdlc      LGPL3      deroad
crc16augccitt  LGPL3      deroad
crc16buypass   LGPL3      deroad
crc16cdma2000  LGPL3      deroad
crc16dds110    LGPL3      deroad
crc16dectr     LGPL3      deroad
crc16dectx     LGPL3      deroad
crc16dnp       LGPL3      deroad
crc16en13757   LGPL3      deroad
crc16genibus   LGPL3      deroad
crc16maxim     LGPL3      deroad
crc16mcrf4xx   LGPL3      deroad
crc16riello    LGPL3      deroad
crc16t10dif    LGPL3      deroad
crc16teledisk  LGPL3      deroad
crc16tms37157  LGPL3      deroad
crca           LGPL3      deroad
crc16kermit    LGPL3      deroad
crc16modbus    LGPL3      deroad
crc16x25       LGPL3      deroad
crc16xmodem    LGPL3      deroad
crc24          LGPL3      deroad
crc32          LGPL3      deroad
crc32ecma267   LGPL3      deroad
crc32c         LGPL3      deroad
crc32bzip2     LGPL3      deroad
crc32d         LGPL3      deroad
crc32mpeg2     LGPL3      deroad
crc32posix     LGPL3      deroad
crc32q         LGPL3      deroad
crc32jamcrc    LGPL3      deroad
crc32xfer      LGPL3      deroad
crc64          LGPL3      deroad
crc64ecma182   LGPL3      deroad
crc64we        LGPL3      deroad
crc64xz        LGPL3      deroad
crc64iso       LGPL3      deroad
xor8           LGPL3      deroad
xor16          LGPL3      deroad
xxhash32       LGPL3      deroad
parity         LGPL3      deroad
entropy        LGPL3      deroad
entropy_fract  LGPL3      deroad
</code></pre>
<p>The <code>ph</code> command accepts an optional numeric argument to specify length of byte range to be hashed, instead of default block size. For example:</p>
<pre><code>[0x08049A80]&gt; ph md5 32
9b9012b00ef7a94b5824105b7aaad83b
[0x08049A80]&gt; ph md5 64
a71b087d8166c99869c9781e2edcf183
[0x08049A80]&gt; ph md5 1024
a933cc94cd705f09a41ecc80c0041def
</code></pre>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<p>The rz-hash tool can be used to calculate checksums and has functions of byte streams, files, text strings.</p>
<pre><code>$ rz-hash -h
Usage: rz-hash [-vhBkjLq] [-b S] [-a A] [-c H] [-E A] [-D A] [-s S] [-x S] [-f O] [-t O] [files|-] ...
 -v          Shows version
 -h          Shows this help page
 -           Input read from stdin instead from a file
 -a algo     Hash algorithm to use and you can specify multiple ones by
             appending a comma (example: sha1,md4,md5,sha256)
 -B          Outputs the calculated value for each block
 -b size     Sets the block size
 -c value    Compare calculated value with a given one (hexadecimal)
 -e endian   Sets the endianness (default: 'big' accepted: 'big' or 'little')
 -D algo     Decrypt the given input; use -S to set key and -I to set IV (if needed)
 -E algo     Encrypt the given input; use -S to set key and -I to set IV (if needed)
 -f from     Starts the calculation at given offset
 -t to       Stops the calculation at given offset
 -I iv       Sets the initialization vector (IV)
 -i times    Repeat the calculation N times
 -j          Outputs the result as a JSON structure
 -k          Outputs the calculated value using openssh's randomkey algorithm
 -L          List all algorithms
 -q          Sets quiet mode (use -qq to get only the calculated value)
 -S seed     Sets the seed for -a, use '^' to append it before the input, use '@'
             prefix to load it from a file and '-' from read it
 -K key      Sets the hmac key for -a and the key for -E/-D, use '@' prefix to
             load it from a file and '-' from read it
             from stdin (you can combine them)
 -s string   Input read from a zero-terminated string instead from a file
 -x hex      Input read from a hexadecimal value instead from a file

             All the inputs (besides -s/-x/-c) can be hexadecimal or strings
             if 's:' prefix is specified
</code></pre>
<p>To obtain an MD5 hash value of a text string, use the <code>-s</code> option:</p>
<pre><code>$ rz-hash -q -a md5 -s 'hello world'
string: md5: 5eb63bbbe01eeed093cb22bb8f5acdc3
</code></pre>
<p>It is possible to calculate hash values for contents of files. But do not attempt to do it for very large files because rz-hash buffers the whole input in memory before computing the hash.</p>
<p>To apply all algorithms known to rz-hash, use <code>all</code> as an algorithm name:</p>
<pre><code>$ rz-hash -a all /bin/ls
/bin/ls: 0x00000000-0x00022a70 md4: 4f34e90ff19613695bfe8ecbddc1ae6d
/bin/ls: 0x00000000-0x00022a70 md5: 27ac5e2f7573020dbff16b3b9c03e678
/bin/ls: 0x00000000-0x00022a70 sha1: 0ca5dcdf79d00cbc893a5cca29695f2afddc193d
/bin/ls: 0x00000000-0x00022a70 sha256: f8b09fba9fda9ffebae86611261cf628bd71022fb4348d876974f7c48ddcc6d5
/bin/ls: 0x00000000-0x00022a70 sha384: ae8404125de3ae798fe85635533dc93744136d812fe279eaa92d1f31896ba4bf9fa0e240ab1b3f234b870f243c5754da
/bin/ls: 0x00000000-0x00022a70 sha512: 4ec188a733c402e277f60d59240aba3279b2fdc261ac479188a28aab899b81be4281283988ccbf78f7ca214eb3fbfb49811743ccdb62a459a52414075e9eae8f
/bin/ls: 0x00000000-0x00022a70 fletcher8: 8d
/bin/ls: 0x00000000-0x00022a70 fletcher16: 8d78
/bin/ls: 0x00000000-0x00022a70 fletcher32: a5e716ad
/bin/ls: 0x00000000-0x00022a70 fletcher64: ae7b1b422fd65611
/bin/ls: 0x00000000-0x00022a70 adler32: e1028925
/bin/ls: 0x00000000-0x00022a70 crc8smbus: 9e
/bin/ls: 0x00000000-0x00022a70 crc8cdma2000: 73
/bin/ls: 0x00000000-0x00022a70 crc8darc: ac
/bin/ls: 0x00000000-0x00022a70 crc8dvbs2: f7
/bin/ls: 0x00000000-0x00022a70 crc8ebu: 6d
/bin/ls: 0x00000000-0x00022a70 crc8icode: 85
/bin/ls: 0x00000000-0x00022a70 crc8itu: cb
/bin/ls: 0x00000000-0x00022a70 crc8maxim: 38
/bin/ls: 0x00000000-0x00022a70 crc8rohc: ef
/bin/ls: 0x00000000-0x00022a70 crc8wcdma: 52
/bin/ls: 0x00000000-0x00022a70 crc15can: 65ec
/bin/ls: 0x00000000-0x00022a70 crc16: f97a
/bin/ls: 0x00000000-0x00022a70 crc16citt: e73b
/bin/ls: 0x00000000-0x00022a70 crc16usb: 2ed9
/bin/ls: 0x00000000-0x00022a70 crc16hdlc: d7cd
/bin/ls: 0x00000000-0x00022a70 crc16augccitt: 2366
/bin/ls: 0x00000000-0x00022a70 crc16buypass: 9eac
/bin/ls: 0x00000000-0x00022a70 crc16cdma2000: d62b
/bin/ls: 0x00000000-0x00022a70 crc16dds110: 02d4
/bin/ls: 0x00000000-0x00022a70 crc16dectr: 9262
/bin/ls: 0x00000000-0x00022a70 crc16dectx: 9263
/bin/ls: 0x00000000-0x00022a70 crc16dnp: d64b
/bin/ls: 0x00000000-0x00022a70 crc16en13757: 9227
/bin/ls: 0x00000000-0x00022a70 crc16genibus: 18c4
/bin/ls: 0x00000000-0x00022a70 crc16maxim: 0685
/bin/ls: 0x00000000-0x00022a70 crc16mcrf4xx: 2832
/bin/ls: 0x00000000-0x00022a70 crc16riello: 0e39
/bin/ls: 0x00000000-0x00022a70 crc16t10dif: dbb5
/bin/ls: 0x00000000-0x00022a70 crc16teledisk: 4fee
/bin/ls: 0x00000000-0x00022a70 crc16tms37157: ba7d
/bin/ls: 0x00000000-0x00022a70 crca: a525
/bin/ls: 0x00000000-0x00022a70 crc16kermit: b131
/bin/ls: 0x00000000-0x00022a70 crc16modbus: d126
/bin/ls: 0x00000000-0x00022a70 crc16x25: d7cd
/bin/ls: 0x00000000-0x00022a70 crc16xmodem: 27a2
/bin/ls: 0x00000000-0x00022a70 crc24: 007476f5
/bin/ls: 0x00000000-0x00022a70 crc32: 09ad52f8
/bin/ls: 0x00000000-0x00022a70 crc32ecma267: 4da033c1
/bin/ls: 0x00000000-0x00022a70 crc32c: ad8aa54c
/bin/ls: 0x00000000-0x00022a70 crc32bzip2: 2db14275
/bin/ls: 0x00000000-0x00022a70 crc32d: 1a82c6fe
/bin/ls: 0x00000000-0x00022a70 crc32mpeg2: d24ebd8a
/bin/ls: 0x00000000-0x00022a70 crc32posix: 58bb93aa
/bin/ls: 0x00000000-0x00022a70 crc32q: fa075365
/bin/ls: 0x00000000-0x00022a70 crc32jamcrc: f652ad07
/bin/ls: 0x00000000-0x00022a70 crc32xfer: bd66a285
/bin/ls: 0x00000000-0x00022a70 crc64: 02bfeb9d3cc5ba89
/bin/ls: 0x00000000-0x00022a70 crc64ecma182: 02bfeb9d3cc5ba89
/bin/ls: 0x00000000-0x00022a70 crc64we: 45f4fd1aca1b6d00
/bin/ls: 0x00000000-0x00022a70 crc64xz: 7ad92fbc2cb7bbaa
/bin/ls: 0x00000000-0x00022a70 crc64iso: 69770b2efe4f8aae
/bin/ls: 0x00000000-0x00022a70 xor8: 92
/bin/ls: 0x00000000-0x00022a70 xor16: 594c
/bin/ls: 0x00000000-0x00022a70 xxhash32: 95374b80
/bin/ls: 0x00000000-0x00022a70 parity: 01000000
/bin/ls: 0x00000000-0x00022a70 entropy: 5.84008688
/bin/ls: 0x00000000-0x00022a70 entropy_fract: 0.73001086
</code></pre>
<h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>rizin is implemented on top of a bunch of libraries, almost every of those
libraries support plugins to extend the capabilities of the library or add
support for different targets.</p>
<p>This section aims to explain what are the plugins, how to write them and use them</p>
<h2 id="types-of-plugins"><a class="header" href="#types-of-plugins">Types of plugins</a></h2>
<pre><code>$ ls librz/*/p | grep : | awk -F / '{ print $2 }'
analysis  # analysis plugins
asm       # assembler/disassembler plugins
bin       # binary format parsing plugins
bp        # breakpoint plugins
core      # core plugins (implement new commands)
crypto    # encrypt/decrypt/hash/...
debug     # debugger backends
egg       # shellcode encoders, etc
io        # io plugins
lang      # embedded scripting languages
parse     # disassembler parsing plugins
reg       # arch register logic
</code></pre>
<h2 id="listing-plugins"><a class="header" href="#listing-plugins">Listing plugins</a></h2>
<p>Some rizin tools have the <code>-L</code> flag to list all the plugins associated to the
functionality.</p>
<pre><code>rz-asm -L   # list asm plugins
rizin -L    # list io plugins
rz-bin -L   # list bin plugins
rz-hash -L  # list hash/crypto/encoding plugins
</code></pre>
<p>There are more plugins in rizin ecosystem, we can list them from inside rizin, and this is
done by using the <code>L</code> suffix.</p>
<p>Those are some of the commands:</p>
<pre><code>L          # list core plugins
iL         # list bin plugins
dL         # list debug plugins
ph         # print support hash algorithms
woD?/woE?  # print support crypto/encoding algorithms
</code></pre>
<p>You can use the <code>?</code> as value to get the possible values in the associated eval vars.</p>
<pre><code>e asm.arch=?   # list assembler/disassembler plugins
e analysis.arch=?  # list analysis plugins
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>Note there are some inconsistencies that most likely will be fixed in the future rizin versions.</p>
<h1 id="io-plugins"><a class="header" href="#io-plugins">IO plugins</a></h1>
<p>All access to files, network, debugger and all input/output in general is wrapped by an IO abstraction layer that allows rizin to treat all data as if it were just a file.</p>
<p>IO plugins are the ones used to wrap the open, read, write and 'system' on virtual file systems. You can make rizin understand anything as a plain file. E.g. a socket connection, a remote rizin session, a file, a process, a device, a gdb session.</p>
<p>So, when rizin reads a block of bytes, it is the task of an IO plugin to get these bytes from any place and put them into internal buffer. An IO plugin is chosen by a file's URI to be opened. Some examples:</p>
<ul>
<li>Debugging URIs</li>
</ul>
<pre><code>$ rizin dbg:///bin/ls&lt;br /&gt;
$ rizin pid://1927
</code></pre>
<ul>
<li>Remote sessions</li>
</ul>
<pre><code>$ rizin rap://:1234&lt;br /&gt;
$ rizin rap://&lt;host&gt;:1234//bin/ls
</code></pre>
<ul>
<li>Virtual buffers</li>
</ul>
<pre><code>$ rizin malloc://512&lt;br /&gt;
shortcut for
$ rizin =
</code></pre>
<p>You can get a list of the rizin IO plugins by typing <code>rizin -L</code>:</p>
<pre><code>$ rizin -L
rw_  ar       Open ar/lib files [ar|lib]://[file//path] (LGPL3)
rw_  bfdbg    BrainFuck Debugger (bfdbg://path/to/file) (LGPL3)
rwd  bochs    Attach to a BOCHS debugger (LGPL3)
r_d  debug    Native debugger (dbg:///bin/ls dbg://1388 pidof:// waitfor://) (LGPL3) v0.2.0 pancake
rw_  default  open local files using def_mmap:// (LGPL3)
rwd  gdb      Attach to gdbserver, 'qemu -s', gdb://localhost:1234 (LGPL3)
rw_  gprobe   open gprobe connection using gprobe:// (LGPL3)
rw_  gzip     read/write gzipped files (LGPL3)
rw_  http     http get (http://rada.re/) (LGPL3)
rw_  ihex     Intel HEX file (ihex://eeproms.hex) (LGPL)
r__  mach     mach debug io (unsupported in this platform) (LGPL)
rw_  malloc   memory allocation (malloc://1024 hex://cd8090) (LGPL3)
rw_  mmap     open file using mmap:// (LGPL3)
rw_  null     null-plugin (null://23) (LGPL3)
rw_  procpid  /proc/pid/mem io (LGPL3)
rwd  ptrace   ptrace and /proc/pid/mem (if available) io (LGPL3)
rwd  qnx      Attach to QNX pdebug instance, qnx://host:1234 (LGPL3)
rw_  rzk      kernel access API io (rzk://) (LGPL3)
rw_  rz-pipe   rz-pipe io plugin (MIT)
rw_  rzweb    rzweb io client (rzweb://cloud.rada.re/cmd/) (LGPL3)
rw_  rap      rizin network protocol (rap://:port rap://host:port/file) (LGPL3)
rw_  rbuf     RBuffer IO plugin: rbuf:// (LGPL)
rw_  self     read memory from myself using 'self://' (LGPL3)
rw_  shm      shared memory resources (shm://key) (LGPL3)
rw_  sparse   sparse buffer allocation (sparse://1024 sparse://) (LGPL3)
rw_  tcp      load files via TCP (listen or connect) (LGPL3)
rwd  windbg   Attach to a KD debugger (windbg://socket) (LGPL3)
rwd  winedbg  Wine-dbg io and debug.io plugin for rizin (MIT)
rw_  zip      Open zip files [apk|ipa|zip|zipall]://[file//path] (BSD)
</code></pre>
<h2 id="implementing-a-new-disassembly-plugin"><a class="header" href="#implementing-a-new-disassembly-plugin">Implementing a new disassembly plugin</a></h2>
<p>Rizin has modular architecture, thus adding support for a new architecture is very easy, if you
are fluent in C. For various reasons it might be easier to implement it out of the tree. For this we
will need to create single C file, called <code>asm_mycpu.c</code> and makefile for it.</p>
<p>The key thing of RzAsm plugin is a structure</p>
<pre><code class="language-c">RzAsmPlugin rz_asm_plugin_mycpu = {
	.name = &quot;mycpu&quot;,
	.license = &quot;LGPL3&quot;,
	.desc = &quot;MYCPU disassembly plugin&quot;,
	.arch = &quot;mycpu&quot;,
	.bits = 32,
	.endian = RZ_SYS_ENDIAN_LITTLE,
	.disassemble = &amp;disassemble
};
</code></pre>
<p>where <code>.disassemble</code> is a pointer to disassembly function, which accepts the bytes buffer
and length:</p>
<pre><code class="language-c">static int disassemble(RzAsm *a, RzAsmOp *op, const ut8 *buf, int len)
</code></pre>
<p><strong>Makefile</strong></p>
<pre><code class="language-makefile">NAME=asm_snes
RZ_PLUGIN_PATH=$(shell rizin -H RZ_USER_PLUGINS)
LIBEXT=$(shell rizin -H LIBEXT)
CFLAGS=-g -fPIC $(shell pkg-config --cflags rz_analyss)
LDFLAGS=-shared $(shell pkg-config --libs rz_analysis)
OBJS=$(NAME).o
LIB=$(NAME).$(LIBEXT)

all: $(LIB)

clean:
	rm -f $(LIB) $(OBJS)

$(LIB): $(OBJS)
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(LIB)

install:
	cp -f asm_mycpu.$(SO_EXT) $(RZ_PLUGIN_PATH)

uninstall:
	rm -f $(RZ_PLUGIN_PATH)/asm_mycpu.$(SO_EXT)
</code></pre>
<p><strong>asm_mycpu.c</strong></p>
<pre><code class="language-c">/* rizin - LGPL - Copyright 2018 - user */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;rz_types.h&gt;
#include &lt;rz_lib.h&gt;
#include &lt;rz_asm.h&gt;

static int disassemble(RzAsm *a, RzAsmOp *op, const ut8 *buf, int len) {
	struct op_cmd cmd = {
		.instr = &quot;&quot;,
		.operands = &quot;&quot;
	};
	if (len &lt; 2) return -1;
	int ret = decode_opcode (buf, len, &amp;cmd);
	if (ret &gt; 0) {
		snprintf (op-&gt;buf_asm, rz_asm_BUFSIZE, &quot;%s %s&quot;,
			  cmd.instr, cmd.operands);
	}
	return op-&gt;size = ret;
}

RzAsmPlugin rz_asm_plugin_mycpu = {
	.name = &quot;mycpu&quot;,
	.license = &quot;LGPL3&quot;,
	.desc = &quot;MYCPU disassembly plugin&quot;,
	.arch = &quot;mycpu&quot;,
	.bits = 32,
	.endian = RZ_SYS_ENDIAN_LITTLE,
	.disassemble = &amp;disassemble
};

#ifndef RZ_PLUGIN_INCORE
RZ_API RzLibStruct rizin_plugin = {
	.type = RZ_LIB_TYPE_ASM,
	.data = &amp;rz_asm_plugin_mycpu,
	.version = RZ_VERSION
};
#endif
</code></pre>
<p>After compiling rizin will list this plugin in the output:</p>
<pre><code>_d__  _8_32      mycpu        LGPL3   MYCPU
</code></pre>
<h3 id="moving-plugin-into-the-tree"><a class="header" href="#moving-plugin-into-the-tree">Moving plugin into the tree</a></h3>
<p>Pushing a new architecture into the main branch of rizin requires to modify several files in order to make it fit into the way the rest of plugins are built.</p>
<p>List of affected files:</p>
<ul>
<li><code>plugins.def.cfg</code> : add the <code>asm.mycpu</code> plugin name string in there</li>
<li><code>librz/asm/p/mycpu.mk</code> : build instructions</li>
<li><code>librz/asm/p/asm_mycpu.c</code> : implementation</li>
<li><code>librz/include/rz_asm.h</code> : add the struct definition in there</li>
</ul>
<p>Check out how the NIOS II CPU disassembly plugin was implemented by reading those commits:</p>
<p>Implement RzAsm plugin:
https://github.com/rizinorg/rizin/commit/933dc0ef6ddfe44c88bbb261165bf8f8b531476b</p>
<p>Implement RzAnalysis plugin:
https://github.com/rizinorg/rizin/commit/ad430f0d52fbe933e0830c49ee607e9b0e4ac8f2</p>
<h2 id="implementing-a-new-analysis-plugin"><a class="header" href="#implementing-a-new-analysis-plugin">Implementing a new analysis plugin</a></h2>
<p>After implementing disassembly plugin, you might have noticed that output
is far from being good - no proper highlighting, no reference lines
and so on. This is because rizin requires every architecture plugin
to provide also analysis information about every opcode. At the moment
the implementation of disassembly and opcodes analysis is separated between
two modules - RzAsm and RzAnalysis. Thus we need to write an analysis plugin too.
The principle is very similar - you just need to create a C file and
corresponding Makefile.</p>
<p>They structure of RzAnalysis plugin looks like</p>
<pre><code class="language-c">RzAnalysisPlugin rz_analysis_plugin_v810 = {
	.name = &quot;mycpu&quot;,
	.desc = &quot;MYCPU code analysis plugin&quot;,
	.license = &quot;LGPL3&quot;,
	.arch = &quot;mycpu&quot;,
	.bits = 32,
	.op = mycpu_op,
	.esil = true,
	.set_reg_profile = set_reg_profile,
};
</code></pre>
<p>Like with disassembly plugin there is a key function - <code>mycpu_op</code> which scans the opcode and builds
RzAnalysisOp structure. On the other hand, in this example analysis plugins also performs uplifting to
ESIL, which is enabled in <code>.esil = true</code> statement. Thus, <code>mycpu_op</code> obliged to fill the
corresponding RzAnalysisOp ESIL field for the opcodes. Second important thing for ESIL uplifting and
emulation - register profile, like in debugger, which is set within <code>set_reg_profile</code> function.</p>
<p><strong>Makefile</strong></p>
<pre><code class="language-makefile">NAME=analysis_snes
RZ_PLUGIN_PATH=$(shell rizin -H RZ_USER_PLUGINS)
LIBEXT=$(shell rizin -H LIBEXT)
CFLAGS=-g -fPIC $(shell pkg-config --cflags rz_analysis)
LDFLAGS=-shared $(shell pkg-config --libs rz_analysis)
OBJS=$(NAME).o
LIB=$(NAME).$(LIBEXT)

all: $(LIB)

clean:
	rm -f $(LIB) $(OBJS)

$(LIB): $(OBJS)
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(LIB)

install:
	cp -f analysis_snes.$(SO_EXT) $(RZ_PLUGIN_PATH)

uninstall:
	rm -f $(RZ_PLUGIN_PATH)/analysis_snes.$(SO_EXT)
</code></pre>
<p><strong>analysis_snes.c:</strong></p>
<pre><code class="language-c">/* rizin - LGPL - Copyright 2015 - condret */

#include &lt;string.h&gt;
#include &lt;rz_types.h&gt;
#include &lt;rz_lib.h&gt;
#include &lt;rz_asm.h&gt;
#include &lt;rz_analysis.h&gt;
#include &quot;snes_op_table.h&quot;

static int snes_anop(RzAnalysis *analysis, RzAnalysisOp *op, ut64 addr, const ut8 *data, int len) {
	memset (op, '\0', sizeof (RzAnalysisOp));
	op-&gt;size = snes_op[data[0]].len;
	op-&gt;addr = addr;
	op-&gt;type = RZ_ANALYSIS_OP_TYPE_UNK;
	switch (data[0]) {
		case 0xea:
			op-&gt;type = RZ_ANALYSIS_OP_TYPE_NOP;
			break;
	}
	return op-&gt;size;
}

struct rz_analysis_plugin_t rz_analysis_plugin_snes = {
	.name = &quot;snes&quot;,
	.desc = &quot;SNES analysis plugin&quot;,
	.license = &quot;LGPL3&quot;,
	.arch = RZ_SYS_ARCH_NONE,
	.bits = 16,
	.init = NULL,
	.fini = NULL,
	.op = &amp;snes_anop,
	.set_reg_profile = NULL,
	.fingerprint_bb = NULL,
	.fingerprint_fcn = NULL,
	.diff_bb = NULL,
	.diff_fcn = NULL,
	.diff_eval = NULL
};

#ifndef RZ_PLUGIN_INCORE
RZ_API RzLibStruct rizin_plugin = {
	.type = RZ_LIB_TYPE_ANALYSIS,
	.data = &amp;rz_analysis_plugin_snes,
	.version = RZ_VERSION
};
#endif
</code></pre>
<p>After compiling rizin will list this plugin in the output:</p>
<pre><code>_dA_  _8_16      snes        LGPL3   SuperNES CPU
</code></pre>
<p><strong>snes_op_table</strong>.h: https://github.com/rizinorg/rizin/blob/master/librz/asm/arch/snes/snes_op_table.h</p>
<p>Example:</p>
<ul>
<li><strong>6502</strong>: https://github.com/rizinorg/rizin/commit/64636e9505f9ca8b408958d3c01ac8e3ce254a9b</li>
<li><strong>SNES</strong>: https://github.com/rizinorg/rizin/commit/60d6e5a1b9d244c7085b22ae8985d00027624b49</li>
</ul>
<h1 id="implementing-a-new-format"><a class="header" href="#implementing-a-new-format">Implementing a new format</a></h1>
<h2 id="create-a-folder-with-file-format-name-in-librzbinformat"><a class="header" href="#create-a-folder-with-file-format-name-in-librzbinformat">Create a folder with file format name in librz/bin/format</a></h2>
<p><strong>Makefile:</strong></p>
<pre><code class="language-Makefile">NAME=bin_nes
RZ_PLUGIN_PATH=$(shell rizin -H RZ_USER_PLUGINS)
LIBEXT=$(shell rizin -H LIBEXT)
CFLAGS=-g -fPIC $(shell pkg-config --cflags rz_bin)
LDFLAGS=-shared $(shell pkg-config --libs rz_bin)
OBJS=$(NAME).o
LIB=$(NAME).$(LIBEXT)

all: $(LIB)

clean:
	rm -f $(LIB) $(OBJS)

$(LIB): $(OBJS)
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(LIB)

install:
	cp -f $(NAME).$(SO_EXT) $(RZ_PLUGIN_PATH)

uninstall:
	rm -f $(RZ_PLUGIN_PATH)/$(NAME).$(SO_EXT)

</code></pre>
<p><strong>bin_nes.c:</strong></p>
<pre><code class="language-c">#include &lt;rz_util.h&gt;
#include &lt;rz_bin.h&gt;

static bool load_buffer(RzBinFile *bf, void **bin_obj, RzBuffer *b, ut64 loadaddr, Sdb *sdb) {
	ut64 size;
	const ut8 *buf = rz_buf_data (b, &amp;size);
	rz_return_val_if_fail (buf, false);
	*bin_obj = rz_bin_internal_nes_load (buf, size);
	return *bin_obj != NULL;
}

static void destroy(RzBinFile *bf) {
	rz_bin_free_all_nes_obj (bf-&gt;o-&gt;bin_obj);
	bf-&gt;o-&gt;bin_obj = NULL;
}

static bool check_buffer(RzBuffer *b) {
	if (!buf || length &lt; 4) return false;
	return (!memcmp (buf, &quot;\x4E\x45\x53\x1A&quot;, 4));
}

static RzBinInfo* info(RzBinFile *arch) {
	RzBinInfo \*ret = RZ_NEW0 (RzBinInfo);
	if (!ret) return NULL;

	if (!arch || !arch-&gt;buf) {
		free (ret);
		return NULL;
	}
	ret-&gt;file = strdup (arch-&gt;file);
	ret-&gt;type = strdup (&quot;ROM&quot;);
	ret-&gt;machine = strdup (&quot;Nintendo NES&quot;);
	ret-&gt;os = strdup (&quot;nes&quot;);
	ret-&gt;arch = strdup (&quot;6502&quot;);
	ret-&gt;bits = 8;

	return ret;
}

struct rz_bin_plugin_t rz_bin_plugin_nes = {
	.name = &quot;nes&quot;,
	.desc = &quot;NES&quot;,
	.license = &quot;BSD&quot;,
	.get_sdb = NULL,
	.load_buffer = &amp;load_buffer,
	.destroy = &amp;destroy,
	.check_buffer = &amp;check_buffer,
	.baddr = NULL,
	.entries = NULL,
	.sections = NULL,
	.info = &amp;info,
};

#ifndef RZ_PLUGIN_INCORE
RZ_API RzLibStruct rizin_plugin = {
	.type = RZ_LIB_TYPE_BIN,
	.data = &amp;rz_bin_plugin_nes,
	.version = RZ_VERSION
};
#endif

</code></pre>
<h3 id="some-examples"><a class="header" href="#some-examples">Some Examples</a></h3>
<ul>
<li>Java - <a href="https://github.com/rizinorg/rizin/commit/7cfddb1da8204587cdc1ba1a26bc07c9fee403dc">https://github.com/rizinorg/rizin/commit/7cfddb1da8204587cdc1ba1a26bc07c9fee403dc</a></li>
<li>Zimgz - <a href="https://github.com/rizinorg/rizin/commit/d1351cf836df3e2e63043a6dc728e880316f00eb">https://github.com/rizinorg/rizin/commit/d1351cf836df3e2e63043a6dc728e880316f00eb</a></li>
<li>OMF - <a href="https://github.com/rizinorg/rizin/commit/44fd8b2555a0446ea759901a94c06f20566bbc40">https://github.com/rizinorg/rizin/commit/44fd8b2555a0446ea759901a94c06f20566bbc40</a></li>
</ul>
<h2 id="write-a-debugger-plugin"><a class="header" href="#write-a-debugger-plugin">Write a debugger plugin</a></h2>
<ul>
<li>Adding the debugger registers profile into the shlr/gdb/src/core.c</li>
<li>Adding the registers profile and architecture support in the librz/debug/p/debug_native.c and librz/debug/p/debug_gdb.c</li>
<li>Add the code to apply the profiles into the function <code>rz_debug_gdb_attach(RzDebug *dbg, int pid)</code></li>
</ul>
<p>If you want to add support for the gdb, you can see the register profile in the active gdb session using command <code>maint print registers</code>.</p>
<h2 id="more-to-come"><a class="header" href="#more-to-come">More to come..</a></h2>
<ul>
<li>Related article: http://rizin.today/posts/extending-r2-with-new-plugins/</li>
</ul>
<p>Some commits related to &quot;Implementing a new architecture&quot;</p>
<ul>
<li>Extensa: https://github.com/rizinorg/rizin/commit/6f1655c49160fe9a287020537afe0fb8049085d7</li>
<li>Malbolge: https://github.com/rizinorg/rizin/pull/579</li>
<li>6502: https://github.com/rizinorg/rizin/pull/656</li>
<li>h8300: https://github.com/rizinorg/rizin/pull/664</li>
<li>GBA: https://github.com/rizinorg/rizin/pull/702</li>
<li>CR16: https://github.com/rizinorg/rizin/pull/721/ &amp;&amp; 726</li>
<li>XCore: https://github.com/rizinorg/rizin/commit/bb16d1737ca5a471142f16ccfa7d444d2713a54d</li>
<li>SharpLH5801: https://github.com/neuschaefer/rizin/commit/f4993cca634161ce6f82a64596fce45fe6b818e7</li>
<li>MSP430: https://github.com/rizinorg/rizin/pull/1426</li>
<li>HP-PA-RISC: https://github.com/rizinorg/rizin/commit/f8384feb6ba019b91229adb8fd6e0314b0656f7b</li>
<li>V810: https://github.com/rizinorg/rizin/pull/2899</li>
<li>TMS320: https://github.com/rizinorg/rizin/pull/596</li>
</ul>
<h2 id="implementing-a-new-pseudo-architecture"><a class="header" href="#implementing-a-new-pseudo-architecture">Implementing a new pseudo architecture</a></h2>
<p>This is an simple plugin for z80 that you may use as example:</p>
<p>https://github.com/rizinorg/rizin/commit/8ff6a92f65331cf8ad74cd0f44a60c258b137a06</p>
<h1 id="python-plugins"><a class="header" href="#python-plugins">Python plugins</a></h1>
<p>At first, to be able to write a plugins in Python for rizin you need to install
rz-lang plugin: <code>rz-pm -i lang-python</code>.
Note - in the following examples there are missing functions of the actual decoding
for the sake of readability!</p>
<p>For this you need to do this:</p>
<ol>
<li><code>import rzlang</code> and <code>from rzlang import RZ</code> (for constants)</li>
<li>Make a function with 2 subfunctions - <code>assemble</code> and <code>disassemble</code> and returning plugin structure - for RzAsm plugin</li>
</ol>
<pre><code class="language-python">def mycpu(a):
    def assemble(s):
        return [1, 2, 3, 4]

    def disassemble(memview, addr):
        try:
            opcode = get_opcode(memview) # https://docs.python.org/3/library/stdtypes.html#memoryview
            opstr = optbl[opcode][1]
            return [4, opstr]
        except:
            return [4, &quot;unknown&quot;]
</code></pre>
<ol start="3">
<li>This structure should contain a pointers to these 2 functions - <code>assemble</code> and <code>disassemble</code></li>
</ol>
<pre><code class="language-python">    return {
            &quot;name&quot; : &quot;mycpu&quot;,
            &quot;arch&quot; : &quot;mycpu&quot;,
            &quot;bits&quot; : 32,
            &quot;endian&quot; : RZ.RZ_SYS_ENDIAN_LITTLE,
            &quot;license&quot; : &quot;GPL&quot;,
            &quot;desc&quot; : &quot;MYCPU disasm&quot;,
            &quot;assemble&quot; : assemble,
            &quot;disassemble&quot; : disassemble,
    }
</code></pre>
<ol start="4">
<li>Make a function with 2 subfunctions - <code>set_reg_profile</code> and <code>op</code> and returning plugin structure - for RzAnalysis plugin</li>
</ol>
<pre><code class="language-python">def mycpu_analysis(a):
       def set_reg_profile():
        profile = &quot;=PC	pc\n&quot; + \
		&quot;=SP	sp\n&quot; + \
		&quot;gpr	r0	.32	0	0\n&quot; + \
		&quot;gpr	r1	.32	4	0\n&quot; + \
		&quot;gpr	r2	.32	8	0\n&quot; + \
		&quot;gpr	r3	.32	12	0\n&quot; + \
		&quot;gpr	r4	.32	16	0\n&quot; + \
		&quot;gpr	r5	.32	20	0\n&quot; + \
		&quot;gpr	sp	.32	24	0\n&quot; + \
		&quot;gpr	pc	.32	28	0\n&quot;
        return profile

    def op(memview, pc):
		analysisop = {
            &quot;type&quot; : RZ.RZ_ANALYSIS_OP_TYPE_NULL,
            &quot;cycles&quot; : 0,
            &quot;stackop&quot; : 0,
            &quot;stackptr&quot; : 0,
			&quot;ptr&quot; : -1,
            &quot;jump&quot; : -1,
            &quot;addr&quot; : 0,
            &quot;eob&quot; : False,
            &quot;esil&quot; : &quot;&quot;,
        }
        try:
            opcode = get_opcode(memview) # https://docs.python.org/3/library/stdtypes.html#memoryview
            esilstr = optbl[opcode][2]
            if optbl[opcode][0] == &quot;J&quot;: # it's jump
                analysisop[&quot;type&quot;] = RZ.RZ_ANALYSIS_OP_TYPE_JMP
                analysisop[&quot;jump&quot;] = decode_jump(opcode, j_mask)
                esilstr = jump_esil(esilstr, opcode, j_mask)

        except:
            result = analysisop
		# Don't forget to return proper instruction size!
        return [4, result]

</code></pre>
<ol start="5">
<li>This structure should contain a pointers to these 2 functions - <code>set_reg_profile</code> and <code>op</code></li>
</ol>
<pre><code class="language-python">    return {
            &quot;name&quot; : &quot;mycpu&quot;,
            &quot;arch&quot; : &quot;mycpu&quot;,
            &quot;bits&quot; : 32,
            &quot;license&quot; : &quot;GPL&quot;,
            &quot;desc&quot; : &quot;MYCPU analysis&quot;,
            &quot;esil&quot; : 1,
            &quot;set_reg_profile&quot; : set_reg_profile,
            &quot;op&quot; : op,
    }
</code></pre>
<ol start="6">
<li>Then register those using <code>rzlang.plugin(&quot;asm&quot;)</code> and <code>rzlang.plugin(&quot;analysis&quot;)</code> respectively</li>
</ol>
<pre><code class="language-python">print(&quot;Registering MYCPU disasm plugin...&quot;)
print(rzlang.plugin(&quot;asm&quot;, mycpu))
print(&quot;Registering MYCPU analysis plugin...&quot;)
print(rzlang.plugin(&quot;analysis&quot;, mycpu_analysis))
</code></pre>
<p>You can combine everything in one file and load it using <code>-i</code> option:</p>
<pre><code>rizin -I mycpu.py some_file.bin
</code></pre>
<p>Or you can load it from the rizin shell: <code>#!python mycpu.py</code></p>
<h3 id="implementing-new-format-plugin-in-python"><a class="header" href="#implementing-new-format-plugin-in-python">Implementing new format plugin in Python</a></h3>
<p>Note - in the following examples there are missing functions of the actual decoding
for the sake of readability!</p>
<p>For this you need to do this:</p>
<ol>
<li>
<p><code>import rzlang</code></p>
</li>
<li>
<p>Make a function with  subfunctions:</p>
<ul>
<li><code>load</code></li>
<li><code>load_bytes</code></li>
<li><code>destroy</code></li>
<li><code>check_bytes</code></li>
<li><code>baddr</code></li>
<li><code>entries</code></li>
<li><code>sections</code></li>
<li><code>imports</code></li>
<li><code>relocs</code></li>
<li><code>binsym</code></li>
<li><code>info</code></li>
</ul>
<p>and returning plugin structure - for RzAsm plugin</p>
</li>
</ol>
<pre><code class="language-python">def le_format(a):
    def load(binf):
        return [0]

    def check_bytes(buf):
        try:
			if buf[0] == 77 and buf[1] == 90:
                lx_off, = struct.unpack(&quot;&lt;I&quot;, buf[0x3c:0x40])
                if buf[lx_off] == 76 and buf[lx_off+1] == 88:
                    return [1]
            return [0]
        except:
            return [0]
</code></pre>
<p>and so on. Please be sure of the parameters for each function and format of returns.
Note, that functions <code>entries</code>, <code>sections</code>, <code>imports</code>, <code>relocs</code> returns a list of special
formed dictionaries - each with a different type.
Other functions return just a list of numerical values, even if single element one.
There is a special function, which returns information about the file - <code>info</code>:</p>
<pre><code class="language-python">    def info(binf):
        return [{
                &quot;type&quot; : &quot;le&quot;,
                &quot;bclass&quot; : &quot;le&quot;,
                &quot;rclass&quot; : &quot;le&quot;,
                &quot;os&quot; : &quot;OS/2&quot;,
                &quot;subsystem&quot; : &quot;CLI&quot;,
                &quot;machine&quot; : &quot;IBM&quot;,
                &quot;arch&quot; : &quot;x86&quot;,
                &quot;has_va&quot; : 0,
                &quot;bits&quot; : 32,
                &quot;big_endian&quot; : 0,
                &quot;dbg_info&quot; : 0,
                }]
</code></pre>
<ol start="3">
<li>This structure should contain a pointers to the most important functions like
<code>check_bytes</code>, <code>load</code> and <code>load_bytes</code>, <code>entries</code>, <code>relocs</code>, <code>imports</code>.</li>
</ol>
<pre><code class="language-python">    return {
            &quot;name&quot; : &quot;le&quot;,
            &quot;desc&quot; : &quot;OS/2 LE/LX format&quot;,
            &quot;license&quot; : &quot;GPL&quot;,
            &quot;load&quot; : load,
            &quot;load_bytes&quot; : load_bytes,
            &quot;destroy&quot; : destroy,
            &quot;check_bytes&quot; : check_bytes,
            &quot;baddr&quot; : baddr,
            &quot;entries&quot; : entries,
            &quot;sections&quot; : sections,
            &quot;imports&quot; : imports,
            &quot;symbols&quot; : symbols,
            &quot;relocs&quot; : relocs,
            &quot;binsym&quot; : binsym,
            &quot;info&quot; : info,
    }
</code></pre>
<ol start="4">
<li>Then you need to register it as a file format plugin:</li>
</ol>
<pre><code class="language-python">print(&quot;Registering OS/2 LE/LX plugin...&quot;)
print(rzlang.plugin(&quot;bin&quot;, le_format))
</code></pre>
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>It is common to have an issues when you write a plugin, especially if you do this for the first
time. This is why debugging them is very important. The first step for debugging is
to set an environment variable when running rizin instance:</p>
<pre><code>R_DEBUG=yes rizin /bin/ls
Loading /usr/local/lib/rizin/2.2.0-git//bin_xtr_dyldcache.so
Cannot find symbol 'rizin_plugin' in library '/usr/local/lib/rizin/2.2.0-git//bin_xtr_dyldcache.so'
Cannot open /usr/local/lib/rizin/2.2.0-git//2.2.0-git
Loading /home/user/.config/rizin/plugins/asm_mips_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/rizin/plugins/asm_sparc_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Cannot open /home/user/.config/rizin/plugins/pimp
Cannot open /home/user/.config/rizin/plugins/yara
Loading /home/user/.config/rizin/plugins/asm_arm_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/rizin/plugins/core_yara.so
Module version mismatch /home/user/.config/rizin/plugins/core_yara.so (2.1.0) vs (2.2.0-git)
Loading /home/user/.config/rizin/plugins/asm_ppc_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/rizin/plugins/lang_python3.so
PLUGIN OK 0x55b205ea5ed0 fcn 0x7f298de08692
Loading /usr/local/lib/rizin/2.2.0-git/bin_xtr_dyldcache.so
Cannot find symbol 'rizin_plugin' in library '/usr/local/lib/rizin/2.2.0-git/bin_xtr_dyldcache.so'
Cannot open /usr/local/lib/rizin/2.2.0-git/2.2.0-git
Cannot open directory '/usr/local/lib/rizin-extras/2.2.0-git'
Cannot open directory '/usr/local/lib/rizin-bindings/2.2.0-git'
USER CONFIG loaded from /home/user/.config/rizin/rizinrc
 -- In visual mode press 'c' to toggle the cursor mode. Use tab to navigate
[0x00005520]&gt;
</code></pre>
<h1 id="testing-the-plugin"><a class="header" href="#testing-the-plugin">Testing the plugin</a></h1>
<p>This plugin is used by rz-asm and rizin. You can verify that the plugin is properly loaded with this command:</p>
<pre><code>$ rz-asm -L | grep mycpu
_d  mycpu        My CPU disassembler  (LGPL3)
</code></pre>
<p>Let's open an empty file using the 'mycpu' arch and write some random code there.</p>
<pre><code>$ rizin =
 -- I endians swap
[0x00000000]&gt; e asm.arch=mycpu
[0x00000000]&gt; woR
[0x00000000]&gt; pd 10
           0x00000000    888e         mov r8, 14
           0x00000002    b2a5         ifnot r10, r5
           0x00000004    3f67         ret
           0x00000006    7ef6         bl r15, r6
           0x00000008    2701         xor r0, 1
           0x0000000a    9826         mov r2, 6
           0x0000000c    478d         xor r8, 13
           0x0000000e    6b6b         store r6, 11
           0x00000010    1382         add r8, r2
           0x00000012    7f15         ret
</code></pre>
<p>Yay! it works.. and the mandatory oneliner too!</p>
<pre><code>rizin -nqamycpu -cwoR -cpd' 10' =
</code></pre>
<h1 id="creating-an-rz-pm-package-of-the-plugin"><a class="header" href="#creating-an-rz-pm-package-of-the-plugin">Creating an rz-pm package of the plugin</a></h1>
<p>As you remember rizin has its own <a href="plugins/../tools/rz-pm/intro.html">packaging manager</a> and we can easily
add newly written plugin for everyone to access.</p>
<p>All packages are located in <a href="https://github.com/rizinorg/rizin-pm">rizin-pm</a> repository, and have
very simple text format.</p>
<pre><code>RZPM_BEGIN

RZPM_GIT &quot;https://github.com/user/mycpu&quot;
RZPM_DESC &quot;[rizin-arch] MYCPU disassembler and analyzer plugins&quot;

RZPM_INSTALL() {
	${MAKE} clean
	${MAKE} all || exit 1
	${MAKE} install RZPM_PLUGDIR=&quot;${RZPM_PLUGDIR}&quot;
}

RZPM_UNINSTALL() {
	rm -f &quot;${RZPM_PLUGDIR}/asm_mycpu.&quot;*
	rm -f &quot;${RZPM_PLUGDIR}/analysis_mycpu.&quot;*
}

RZPM_END
</code></pre>
<p>Then add it in the <code>/db</code> directory of rizin-pm repository and send a pull request to the mainline.</p>
<h1 id="crackmes"><a class="header" href="#crackmes">Crackmes</a></h1>
<p>Crackmes (from &quot;crack me&quot; challenge) are the training ground for reverse engineering people. This section will go over tutorials on how to defeat various crackmes using rizin.</p>
<h1 id="ioli-crackmes"><a class="header" href="#ioli-crackmes">IOLI CrackMes</a></h1>
<p>The IOLI crackme is a good starting point for learning rizin. This is a set of tutorials based on the tutorial at <a href="https://dustri.org/b/defeating-ioli-with-radare2.html">dustri</a></p>
<p>The IOLI crackmes are available at a locally hosted <a href="https://github.com/rizinorg/book/raw/master/src/crackmes/ioli/IOLI-crackme.tar.gz">mirror</a></p>
<h1 id="ioli-0x00"><a class="header" href="#ioli-0x00">IOLI 0x00</a></h1>
<p>This is the first IOLI crackme, and the easiest one.</p>
<pre><code>$ ./crackme0x00
IOLI Crackme Level 0x00
Password: 1234
Invalid Password!
</code></pre>
<p>The first thing to check is if the password is just plaintext inside the file. In this case, we don't need to do any disassembly, and we can just use rz-bin with the -z flag to search for strings in the binary.</p>
<pre><code>$ rz-bin -z ./crackme0x00
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x00000568 0x08048568 24  25   .rodata ascii IOLI Crackme Level 0x00\n
1   0x00000581 0x08048581 10  11   .rodata ascii Password:
2   0x0000058f 0x0804858f 6   7    .rodata ascii 250382
3   0x00000596 0x08048596 18  19   .rodata ascii Invalid Password!\n
4   0x000005a9 0x080485a9 15  16   .rodata ascii Password OK :)\n
</code></pre>
<p>So we know what the following section is, this section is the header shown when the application is run.</p>
<pre><code>nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x00000568 0x08048568 24  25   .rodata ascii IOLI Crackme Level 0x00\n
</code></pre>
<p>Here we have the prompt for the password.</p>
<pre><code>1   0x00000581 0x08048581 10  11   .rodata ascii Password:
</code></pre>
<p>This is the error on entering an invalid password.</p>
<pre><code>3   0x00000596 0x08048596 18  19   .rodata ascii Invalid Password!\n
</code></pre>
<p>This is the message on the password being accepted.</p>
<pre><code>4   0x000005a9 0x080485a9 15  16   .rodata ascii Password OK :)\n
</code></pre>
<p>What is this? It's a string, but we haven't seen it in running the application yet.</p>
<pre><code>2   0x0000058f 0x0804858f 6   7    .rodata ascii 250382
</code></pre>
<p>Let's give this a shot.</p>
<pre><code>$ ./crackme0x00
IOLI Crackme Level 0x00
Password: 250382
Password OK :)
</code></pre>
<p>So we now know that 250382 is the password, and have completed this crackme.</p>
<h1 id="ioli-0x01"><a class="header" href="#ioli-0x01">IOLI 0x01</a></h1>
<p>This is the second IOLI crackme.</p>
<pre><code>$ ./crackme0x01
IOLI Crackme Level 0x01
Password: test
Invalid Password!
</code></pre>
<p>Let's check for strings with rz-bin.</p>
<pre><code>$ rz-bin -z ./crackme0x01
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x00000528 0x08048528 24  25   .rodata ascii IOLI Crackme Level 0x01\n
1   0x00000541 0x08048541 10  11   .rodata ascii Password:
2   0x0000054f 0x0804854f 18  19   .rodata ascii Invalid Password!\n
3   0x00000562 0x08048562 15  16   .rodata ascii Password OK :)\n
</code></pre>
<p>This isn't going to be as easy as 0x00. Let's try disassembly with rizin.</p>
<pre><code>$ rizin ./crackme0x01
-- Use `zoom.byte=printable` in zoom mode ('z' in Visual mode) to find strings
[0x08048330]&gt; aa
[0x08048330]&gt; pdf@main
            ; DATA XREF from entry0 @ 0x8048347
/ 113: int main (int argc, char **argv, char **envp);
|           ; var int32_t var_4h @ ebp-0x4
|           ; var int32_t var_sp_4h @ esp+0x4
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424288504.  mov dword [esp], str.IOLI_Crackme_Level_0x01 ; [0x8048528:4]=0x494c4f49 ; &quot;IOLI Crackme Level 0x01\n&quot;
|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804840c      c70424418504.  mov dword [esp], str.Password: ; [0x8048541:4]=0x73736150 ; &quot;Password: &quot;
|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048418      8d45fc         lea eax, [var_4h]
|           0x0804841b      89442404       mov dword [var_sp_4h], eax
|           0x0804841f      c704244c8504.  mov dword [esp], 0x804854c  ; [0x804854c:4]=0x49006425
|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804842b      817dfc9a1400.  cmp dword [var_4h], 0x149a
|       ,=&lt; 0x08048432      740e           je 0x8048442
|       |   0x08048434      c704244f8504.  mov dword [esp], str.Invalid_Password ; [0x804854f:4]=0x61766e49 ; &quot;Invalid Password!\n&quot;
|       |   0x0804843b      e8dcfeffff     call sym.imp.printf         ; int printf(const char *format)
|      ,==&lt; 0x08048440      eb0c           jmp 0x804844e
|      |`-&gt; 0x08048442      c70424628504.  mov dword [esp], str.Password_OK_: ; [0x8048562:4]=0x73736150 ; &quot;Password OK :)\n&quot;
|      |    0x08048449      e8cefeffff     call sym.imp.printf         ; int printf(const char *format)
|      |    ; CODE XREF from main @ 0x8048440
|      `--&gt; 0x0804844e      b800000000     mov eax, 0
|           0x08048453      c9             leave
\           0x08048454      c3             ret
</code></pre>
<p>&quot;aa&quot; tells rizin to analyze the whole binary, which gets you symbol names, among things.</p>
<p>&quot;pdf&quot; stands for</p>
<ul>
<li>
<p>Print</p>
</li>
<li>
<p>Disassemble</p>
</li>
<li>
<p>Function</p>
</li>
</ul>
<p>This will print the disassembly of the main function, or the <code>main()</code> that everyone knows. You can see several things as well: weird names, arrows, etc.</p>
<ul>
<li>
<p>&quot;imp.&quot; stands for imports. Those are imported symbols, like printf()</p>
</li>
<li>
<p>&quot;str.&quot; stands for strings. Those are strings (obviously).</p>
</li>
</ul>
<p>If you look carefully, you'll see a <code>cmp</code> instruction, with a constant, 0x149a. <code>cmp</code> is an x86 compare instruction, and the 0x in front of it specifies it is in base 16, or hex (hexadecimal).</p>
<pre><code>0x0804842b    817dfc9a140. cmp dword [ebp + 0xfffffffc], 0x149a
</code></pre>
<p>You can use rizin's <code>?</code> command to display 0x149a in another numeric base.</p>
<pre><code>[0x08048330]&gt; ? 0x149a
int32   5274
uint32  5274
hex     0x149a
octal   012232
unit    5.2K
segment 0000:049a
string  &quot;\x9a\x14&quot;
fvalue: 5274.0
float:  0.000000f
double: 0.000000
binary  0b0001010010011010
trits   0t21020100
</code></pre>
<p>So now we know that 0x149a is 5274 in decimal. Let's try this as a password.</p>
<pre><code>$ ./crackme0x01
IOLI Crackme Level 0x01
Password: 5274
Password OK :)
</code></pre>
<p>Bingo, the password was 5274. In this case, the password function at 0x0804842b was comparing the input against the value, 0x149a in hex. Since user input is usually decimal, it was a safe bet that the input was intended to be in decimal, or 5274. Now, since we're hackers, and curiosity drives us, let's see what happens when we input in hex.</p>
<pre><code>$ ./crackme0x01
IOLI Crackme Level 0x01
Password: 0x149a
Invalid Password!
</code></pre>
<p>It was worth a shot, but it doesn't work. That's because <code>scanf()</code> will take the 0 in 0x149a to be a zero, rather than accepting the input as actually being the hex value.</p>
<p>And this concludes IOLI 0x01.</p>
<h1 id="ioli-0x02"><a class="header" href="#ioli-0x02">IOLI 0x02</a></h1>
<p>This is the third one.</p>
<pre><code>$ ./crackme0x02
IOLI Crackme Level 0x02
Password: hello
Invalid Password!
</code></pre>
<p>Firstly, let's check it with rz-bin.</p>
<pre><code>$ rz-bin -z ./crackme0x02
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x00000548 0x08048548 24  25   .rodata ascii IOLI Crackme Level 0x02\n
1   0x00000561 0x08048561 10  11   .rodata ascii Password:
2   0x0000056f 0x0804856f 15  16   .rodata ascii Password OK :)\n
3   0x0000057f 0x0804857f 18  19   .rodata ascii Invalid Password!\n
</code></pre>
<p>Similar to 0x01, there's no explicit password string here. So, it's time to analyze it with Rizin.</p>
<pre><code>[0x08048330]&gt; aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x08048330]&gt; pdf@main
            ; DATA XREF from entry0 @ 0x8048347
/ 144: int main (int argc, char **argv, char **envp);
|           ; var int32_t var_ch @ ebp-0xc
|           ; var int32_t var_8h @ ebp-0x8
|           ; var int32_t var_4h @ ebp-0x4
|           ; var int32_t var_sp_4h @ esp+0x4
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424488504.  mov dword [esp], str.IOLI_Crackme_Level_0x02 ; [0x8048548:4]=0x494c4f49 ; &quot;IOLI Crackme Level 0x02\n&quot;
|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804840c      c70424618504.  mov dword [esp], str.Password: ; [0x8048561:4]=0x73736150 ; &quot;Password: &quot;
|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048418      8d45fc         lea eax, [var_4h]
|           0x0804841b      89442404       mov dword [var_sp_4h], eax
|           0x0804841f      c704246c8504.  mov dword [esp], 0x804856c  ; [0x804856c:4]=0x50006425
|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804842b      c745f85a0000.  mov dword [var_8h], 0x5a    ; 'Z' ; 90
|           0x08048432      c745f4ec0100.  mov dword [var_ch], 0x1ec   ; 492
|           0x08048439      8b55f4         mov edx, dword [var_ch]
|           0x0804843c      8d45f8         lea eax, [var_8h]
|           0x0804843f      0110           add dword [eax], edx
|           0x08048441      8b45f8         mov eax, dword [var_8h]
|           0x08048444      0faf45f8       imul eax, dword [var_8h]
|           0x08048448      8945f4         mov dword [var_ch], eax
|           0x0804844b      8b45fc         mov eax, dword [var_4h]
|           0x0804844e      3b45f4         cmp eax, dword [var_ch]
|       ,=&lt; 0x08048451      750e           jne 0x8048461
|       |   0x08048453      c704246f8504.  mov dword [esp], str.Password_OK_: ; [0x804856f:4]=0x73736150 ; &quot;Password OK :)\n&quot;
|       |   0x0804845a      e8bdfeffff     call sym.imp.printf         ; int printf(const char *format)
|      ,==&lt; 0x0804845f      eb0c           jmp 0x804846d
|      |`-&gt; 0x08048461      c704247f8504.  mov dword [esp], str.Invalid_Password ; [0x804857f:4]=0x61766e49 ; &quot;Invalid Password!\n&quot;
|      |    0x08048468      e8affeffff     call sym.imp.printf         ; int printf(const char *format)
|      |    ; CODE XREF from main @ 0x804845f
|      `--&gt; 0x0804846d      b800000000     mov eax, 0
|           0x08048472      c9             leave
\           0x08048473      c3             ret

</code></pre>
<p>With the experience of solving crackme0x01, we can first locate the position of <code>cmp</code> instruction by using this simple oneliner:</p>
<pre><code>[0x08048330]&gt; pdf@main~cmp
|           0x0804844e      3b45f4         cmp eax, dword [var_ch]
</code></pre>
<p>Unfortunately, the variable compared to <code>eax</code> is stored in the stack. We can't check the value of this variable directly. It's a common case in reverse engineering that we have to derive the value of the variable from the previous sequence. As the amount of code is relatively small, it can be easily done.</p>
<p>for example:</p>
<pre><code>|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
</code></pre>
<p>We can easily get the value of <code>eax</code>. It's 16.</p>
<p>Directly looking at the disassembly gets hard when the scale of program grows. Rizin's flagship decompiler <a href="https://github.com/rizinorg/rz-ghidra">rz-ghidra</a> might be of help, here. You can install it easily:</p>
<pre><code>rz-pm -i rz-ghidra
</code></pre>
<p>Decompile <code>main()</code> with the following command (like <code>F5</code> in IDA):</p>
<pre><code class="language-C">[0x08048330]&gt; pdg
undefined4 main(void)
{
    uint32_t var_ch;
    undefined4 var_8h;
    int32_t var_4h;
    
    printf(&quot;IOLI Crackme Level 0x02\n&quot;);
    printf(&quot;Password: &quot;);
    scanf(0x804856c, &amp;var_4h);
    if (var_4h == 0x52b24) {
        printf(&quot;Password OK :)\n&quot;);
    } else {
        printf(&quot;Invalid Password!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>It's more human-readable now. To check the string in <code>0x804856c</code>, we can:</p>
<ul>
<li>Seek</li>
<li>Print the string</li>
</ul>
<pre><code>[0x08048330]&gt; s 0x804856c
[0x0804856c]&gt; ps
%d
</code></pre>
<p>It's exactly the format string of <code>scanf()</code>. And rz-ghidra recognizes that the second argument (eax) is a pointer and it points to <code>var_4h</code>. Which means our input will be stored in <code>var_4h</code>.</p>
<p>We can easily write out the pseudo code here.</p>
<pre><code class="language-C">var_ch = (var_8h + var_ch)^2;
if (var_ch == our_input)
  printf(&quot;Password OK :)\n&quot;);
</code></pre>
<p>Given the initial status that <code>var_8h</code> is <code>0x5a</code>, <code>var_ch</code> is <code>0x1ec</code>, we have
var_ch = 338724 (0x52b24):</p>
<pre><code>$ rz-ax '=10' '(0x5a+0x1ec)*(0x5a+0x1ec)'
338724

$ ./crackme0x02
IOLI Crackme Level 0x02
Password: 338724
Password OK :)
</code></pre>
<p>And we finish the crackme0x02.</p>
<h1 id="ioli-0x03"><a class="header" href="#ioli-0x03">IOLI 0x03</a></h1>
<p>crackme 0x03, let's skip the string check part and analyze it directly.</p>
<pre><code class="language-C">[0x08048360]&gt; aaa
[0x08048360]&gt; pdd@sym.main
/* jsdec pseudo code output */
/* ./crackme0x03 @ 0x8048498 */
#include &lt;stdint.h&gt;

int32_t main (void) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;
    printf (&quot;IOLI Crackme Level 0x03\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_4h;
    scanf (0x8048634, eax);
    var_8h = 0x5a;
    var_ch = 0x1ec;
    edx = 0x1ec;
    eax = &amp;var_8h;
    *(eax) += edx;
    eax = var_8h;
    eax *= var_8h;
    var_ch = eax;
    eax = var_4h;
    test (eax, eax);
    eax = 0;
    return eax;
}
</code></pre>
<p>It looks straightforward except the function <code>test(eax, eax)</code>. This is unusual to call a function with same two parameters , so I speculate that the decompiler has gone wrong. we can check it in disassembly.</p>
<pre><code class="language-asm">[0x08048360]&gt; pdf@sym.main
...
           0x080484fc      8945f4         mov dword [var_ch], eax
           0x080484ff      8b45f4         mov eax, dword [var_ch]
           0x08048502      89442404       mov dword [var_sp_4h], eax   ; uint32_t arg_ch
           0x08048506      8b45fc         mov eax, dword [var_4h]
           0x08048509      890424         mov dword [esp], eax         ; int32_t arg_8h
           0x0804850c      e85dffffff     call sym.test
...
</code></pre>
<p>Here comes the<code>sym.test</code>, called with two parameters. One is var_4h (our input from <code>scanf()</code>). The other is var_ch. The value of var_ch (as the parameter of <code>test()</code>) can be calculated like it did in crackme_0x02. It's  0x52b24. Try it!</p>
<pre><code class="language-sh">./crackme0x03
IOLI Crackme Level 0x03
Password: 338724
Password OK!!! :)
</code></pre>
<p>Take a look at <code>sym.test</code>. It's a two path conditional jump which compares two parameters and then do shift. We can guess that shift is most likely the decryption part (shift cipher, e.g. Caesar cipher).</p>
<pre><code class="language-C">/* jsdec pseudo code output */
/* ./crackme0x03 @ 0x804846e */
#include &lt;stdint.h&gt;

int32_t test (int32_t arg_8h, uint32_t arg_ch) {
    eax = arg_8h;
    if (eax != arg_ch) {
        shift (&quot;Lqydolg#Sdvvzrug$&quot;);
    } else {
        shift (&quot;Sdvvzrug#RN$$$#=,&quot;);
    }
    return eax;
}
</code></pre>
<p>can also reverse <code>shift()</code> to satisfy curiosity.</p>
<pre><code class="language-asm">[0x08048360]&gt; pdf@sym.shift
        ; CODE (CALL) XREF 0x08048491 (sym.test)
        ; CODE (CALL) XREF 0x08048483 (sym.test)
/ function: sym.shift (90)
|       0x08048414  sym.shift:
|       0x08048414     55               push ebp
|       0x08048415     89e5             mov ebp, esp
|       0x08048417     81ec98000000     sub esp, 0x98
|       0x0804841d     c7458400000000   mov dword [ebp-0x7c], 0x0  ; this seems to be a counter
|  .    ; CODE (JMP) XREF 0x0804844e (sym.shift)
/ loc: loc.08048424 (74)
|  .    0x08048424  loc.08048424:
|  .--&gt; 0x08048424     8b4508           mov eax, [ebp+0x8] ; ebp+0x8 = strlen(chain)
|  |    0x08048427     890424           mov [esp], eax
|  |    0x0804842a     e811ffffff       call dword imp.strlen
|  |       ; imp.strlen()
|  |    0x0804842f     394584           cmp [ebp-0x7c], eax
|  |,=&lt; 0x08048432     731c             jae loc.08048450
|  ||   0x08048434     8d4588           lea eax, [ebp-0x78]
|  ||   0x08048437     89c2             mov edx, eax
|  ||   0x08048439     035584           add edx, [ebp-0x7c]
|  ||   0x0804843c     8b4584           mov eax, [ebp-0x7c]
|  ||   0x0804843f     034508           add eax, [ebp+0x8]
|  ||   0x08048442     0fb600           movzx eax, byte [eax]
|  ||   0x08048445     2c03             sub al, 0x3
|  ||   0x08048447     8802             mov [edx], al
|  ||   0x08048449     8d4584           lea eax, [ebp-0x7c]
|  ||   0x0804844c     ff00             inc dword [eax]
|  `==&lt; 0x0804844e     ebd4             jmp loc.08048424
|   |   ; CODE (JMP) XREF 0x08048432 (sym.shift)
/ loc: loc.08048450 (30)
|   |   0x08048450  loc.08048450:
|   `-&gt; 0x08048450     8d4588           lea eax, [ebp-0x78]
|       0x08048453     034584           add eax, [ebp-0x7c]
|       0x08048456     c60000           mov byte [eax], 0x0
|       0x08048459     8d4588           lea eax, [ebp-0x78]
|       0x0804845c     89442404         mov [esp+0x4], eax
|       0x08048460     c70424e8850408   mov dword [esp], 0x80485e8
|       0x08048467     e8e4feffff       call dword imp.printf
|          ; imp.printf()
|       0x0804846c     c9               leave
\       0x0804846d     c3               ret
        ; ------------
</code></pre>
<p>you can read the assembly code and find the decryption is actually a &quot;sub al, 0x3&quot;. we can write a python script for it:</p>
<pre><code class="language-python">print(''.join([chr(ord(i)-0x3) for i in 'SdvvzrugRN$$$']))
print(''.join([chr(ord(i)-0x3) for i in 'LqydolgSdvvzrug$']))
</code></pre>
<p>the easier way is to <code>run</code> the decryption code, that means debug it or emulate it. I used rizin ESIL emulator but it got stuck when executed <code> call dword imp.strlen</code>. And I can't find the usage of hooking function / skip instruction in rizin.  The following is an example to show u how to emulate ESIL.</p>
<pre><code class="language-sh">[0x08048414]&gt; s 0x08048445		# the 'sub al, 0x03'
[0x08048445]&gt; aei				# init VM
[0x08048445]&gt; aeim				# init memory
[0x08048445]&gt; aeip				# init ip
[0x08048445]&gt; aer eax=0x41		# set eax=0x41 -- 'A'
[0x08048445]&gt; aer				# show current value of regs
oeax = 0x00000000
eax = 0x00000041
ebx = 0x00000000
ecx = 0x00000000
edx = 0x00000000
esi = 0x00000000
edi = 0x00000000
esp = 0x00178000
ebp = 0x00178000
eip = 0x08048445
eflags = 0x00000000
[0x08048445]&gt; V					# enter Visual mode
# 'p' or 'P' to change visual mode
# I prefer the [xaDvc] mode
# use 's' to step in and 'S' to step over
[0x08048442 [xaDvc]0 0% 265 ./crackme0x03]&gt; diq;?0;f t.. @ sym.shift+46 # 0x8048442
dead at 0x00000000
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x00178000  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178010  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178020  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178030  0000 0000 0000 0000 0000 0000 0000 0000  ................
   oeax 0x00000000      eax 0x00000041      ebx 0x00000000      ecx 0x00000000
    edx 0x00000000      esi 0x00000000      edi 0x00000000      esp 0x00178000
    ebp 0x00178000      eip 0x08048445   eflags 0x00000000
       :   0x08048442      0fb600         movzx eax, byte [eax]
       :   ;-- eip:
       :   0x08048445      2c03           sub al, 3
       :   0x08048447      8802           mov byte [edx], al
       :   0x08048449      8d4584         lea eax, [var_7ch]
       :   0x0804844c      ff00           inc dword [eax]
       :=&lt; 0x0804844e      ebd4           jmp 0x8048424
           ; CODE XREF from sym.shift @ 0x8048432
           0x08048450      8d4588         lea eax, [var_78h]
</code></pre>
<p>By the way, you can also open the file and use write data command to decrypt data.</p>
<pre><code class="language-sh">rizin -w ./crackme0x03
[0x08048360]&gt; aaa
[0x08048360]&gt; fs strings
[0x08048360]&gt; f
0x080485ec 18 str.Lqydolg_Sdvvzrug
0x080485fe 18 str.Sdvvzrug_RN
0x08048610 25 str.IOLI_Crackme_Level_0x03
0x08048629 11 str.Password:
[0x08048360]&gt; s str.Lqydolg_Sdvvzrug
[0x080485ec]&gt; wos 0x03 @ str.Lqydolg_Sdvvzrug!0x11
[0x080485ec]&gt; px
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x080485ec  496e 7661 6c69 6420 5061 7373 776f 7264  Invalid Password
0x080485fc  2100 5364 7676 7a72 7567 2352 4e24 2424  !.Sdvvzrug#RN$$$
0x0804860c  233d 2c00 494f 4c49 2043 7261 636b 6d65  #=,.IOLI Crackme
0x0804861c  204c 6576 656c 2030 7830 330a 0050 6173   Level 0x03..Pas
0x0804862c  7377 6f72 643a 2000 2564 0000 0000 0000  sword: .%d......
[0x080485ec]&gt; wos 0x03 @ str.Sdvvzrug_RN!17
[0x080485ec]&gt; px
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x080485ec  496e 7661 6c69 6420 5061 7373 776f 7264  Invalid Password
0x080485fc  2100 5061 7373 776f 7264 204f 4b21 2121  !.Password OK!!!
0x0804860c  203a 2900 494f 4c49 2043 7261 636b 6d65   :).IOLI Crackme
0x0804861c  204c 6576 656c 2030 7830 330a 0050 6173   Level 0x03..Pas
0x0804862c  7377 6f72 643a 2000 2564 0000 0000 0000  sword: .%d......
[0x080485ec]&gt;
</code></pre>
<h1 id="ioli-0x04"><a class="header" href="#ioli-0x04">IOLI 0x04</a></h1>
<h1 id="0x04"><a class="header" href="#0x04">0x04</a></h1>
<pre><code class="language-C">[0x080483d0]&gt; pdd@main
/* jsdec pseudo code output */
/* ./crackme0x04 @ 0x8048509 */
#include &lt;stdint.h&gt;

int32_t main (void) {
    int32_t var_78h;
    int32_t var_4h;
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;
    printf (&quot;IOLI Crackme Level 0x04\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_78h;
    scanf (0x8048682, eax);
    eax = &amp;var_78h;
    check (eax);
    eax = 0;
    return eax;
}
</code></pre>
<p>Let's enter check.</p>
<pre><code class="language-C">#include &lt;stdint.h&gt;

int32_t check (char * s) {
    char * var_dh;
    uint32_t var_ch;
    uint32_t var_8h;
    int32_t var_4h;
    char * format;
    int32_t var_sp_8h;
    var_8h = 0;
    var_ch = 0;
    do {
        eax = s;
        eax = strlen (eax);
        if (var_ch &gt;= eax) {
            goto label_0;
        }
        eax = var_ch;
        eax += s;
        eax = *(eax);
        var_dh = al;
        eax = &amp;var_4h;
        eax = &amp;var_dh;
        sscanf (eax, eax, 0x8048638);
        edx = var_4h;
        eax = &amp;var_8h;
        *(eax) += edx;
        if (var_8h == 0xf) {
            printf (&quot;Password OK!\n&quot;);
            exit (0);
        }
        eax = &amp;var_ch;
        *(eax)++;
    } while (1);
label_0:
    printf (&quot;Password Incorrect!\n&quot;);
    return eax;
}
</code></pre>
<p>manually analyze with both the assembly and pseudo code we can simply write down the C-like code to describe this function:</p>
<pre><code class="language-C">#include &lt;stdint.h&gt;
int32_t check(char *s)
{
    var_ch = 0;
    var_8h = 0;
    for (var_ch = 0; var_ch &lt; strlen(s); ++var_ch)
    {
        var_dh = s[var_ch];
        sscanf(&amp;var_dh, %d, &amp;var_4h);			// read from string[var_ch], store to var_4h
        var_8h += var_4h;
        if(var_8h == 0xf)
            printf(&quot;Password OK\n&quot;);
    }
    printf(&quot;Password Incorrect!\n&quot;);
    return 0;
}
</code></pre>
<p>In short, it calculates the Digit Sum of a number (add a number digit by digit. for example, 96 =&gt; 9 + 6 = 15) :</p>
<pre><code class="language-sh">./crackme0x04
IOLI Crackme Level 0x04
Password: 12345
Password OK!

./crackme0x04
IOLI Crackme Level 0x04
Password: 96
Password OK!
</code></pre>
<h1 id="ioli-0x05"><a class="header" href="#ioli-0x05">IOLI 0x05</a></h1>
<p>check again, it uses <code>scanf()</code> to get our input and pass it to <code>check()</code> as parameter.</p>
<pre><code class="language-C">[0x080483d0]&gt; pdd@main
/* jsdec pseudo code output */
/* ./crackme0x05 @ 0x8048540 */
#include &lt;stdint.h&gt;

int32_t main (void) {
    int32_t var_78h;
    int32_t var_4h;
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;
    printf (&quot;IOLI Crackme Level 0x05\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_78h;
    scanf (0x80486b2, eax);			// 0x80486b2 is %s
    eax = &amp;var_78h;
    check (eax);
    eax = 0;
    return eax;
}
</code></pre>
<p>the check() function:</p>
<pre><code class="language-C">/* jsdec pseudo code output */
/* ./crackme0x05 @ 0x80484c8 */
#include &lt;stdint.h&gt;

int32_t check (char * s) {
    char * var_dh;
    uint32_t var_ch;
    uint32_t var_8h;
    int32_t var_4h;
    char * format;
    int32_t var_sp_8h;
    var_8h = 0;
    var_ch = 0;
    do {
        eax = s;
        eax = strlen (eax);
        if (var_ch &gt;= eax) {
            goto label_0;
        }
        eax = var_ch;
        eax += s;
        eax = *(eax);
        var_dh = al;
        eax = &amp;var_4h;
        eax = &amp;var_dh;
        sscanf (eax, eax, 0x8048668);			// 0x8048668 is %d
        edx = var_4h;
        eax = &amp;var_8h;
        *(eax) += edx;
        if (var_8h == 0x10) {
            eax = s;
            parell (eax);
        }
        eax = &amp;var_ch;
        *(eax)++;
    } while (1);
label_0:
    printf (&quot;Password Incorrect!\n&quot;);
    return eax;
}
</code></pre>
<p>The same, we can write our own C-like pseudo code.</p>
<pre><code class="language-C">#include &lt;stdint.h&gt;
int32_t check(char *s)
{
    var_ch = 0;
    var_8h = 0;
    for (var_ch = 0; var_ch &lt; strlen(s); ++var_ch)
    {
        var_dh = s[var_ch];
        sscanf(&amp;var_dh, %d, &amp;var_4h);			// read from string[var_ch], store to var_4h
        var_8h += var_4h;
        if(var_8h == 0x10)
            parell(s);
    }
    printf(&quot;Password Incorrect!\n&quot;);
    return 0;
}
</code></pre>
<p>The if condition becomes <code>var_8h == 0x10</code>. In addition, a new function call - <code>parell(s)</code> replace the <code>printf(&quot;password OK&quot;)</code>now. The next step is to reverse sym.parell.</p>
<pre><code class="language-C">[0x08048484]&gt; s sym.parell
[0x08048484]&gt; pdd@sym.parell
/* jsdec pseudo code output */
/* ./crackme0x05 @ 0x8048484 */
#include &lt;stdint.h&gt;

uint32_t parell (char * s) {
    int32_t var_4h;
    char * format;
    int32_t var_8h;
    eax = &amp;var_4h;
    eax = s;
    sscanf (eax, eax, 0x8048668);
    eax = var_4h;
    eax &amp;= 1;
    if (eax == 0) {
        printf (&quot;Password OK!\n&quot;);
        exit (0);
    }
    return eax;
}
</code></pre>
<p>the decompiled code looks well except the <code>sscanf()</code> function. It can be easily corrected by checking the assembly code.</p>
<pre><code class="language-asm">/ 68: sym.parell (int32_t arg_8h);
|           ; var int32_t var_4h @ ebp-0x4
|           ; arg int32_t arg_8h @ ebp+0x8
|           ; var int32_t var_sp_4h @ esp+0x4
|           ; var int32_t var_8h @ esp+0x8
|           0x08048484      55             push ebp
|           0x08048485      89e5           mov ebp, esp
|           0x08048487      83ec18         sub esp, 0x18
|           0x0804848a      8d45fc         lea eax, [var_4h]
|           0x0804848d      89442408       mov dword [var_8h], eax
|           0x08048491      c74424046886.  mov dword [var_sp_4h], 0x8048668 ; [0x8048668:4]=0x50006425 %d
|           0x08048499      8b4508         mov eax, dword [arg_8h]
|           0x0804849c      890424         mov dword [esp], eax
|           0x0804849f      e800ffffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)
....
</code></pre>
<p>The <code>mov dword [esp], eax</code> is the nearest instruction to sscanf (and it's equivalent to a push instruction). It stores the string 's' to the stack top (arg1).  <code>mov dword [var_sp_4h], 0x8048668</code> push '%d' as arg2 into stack. var_8h (esp + 0x8) which keeps the address of var_4h is the arg3.</p>
<p>Finally we have the corrected pseudo code:</p>
<pre><code class="language-C">uint32_t parell (char * s) {
    sscanf (s, %d, &amp;var_4h);
    if ((var_4h &amp; 1) == 0) {
        printf (&quot;Password OK!\n&quot;);
        exit(0);
    }
    return 0;
}
</code></pre>
<p>Now there are 2 constraints:</p>
<ul>
<li>Digit Sum is 16 (0x10)</li>
<li>Must be an odd number (1 &amp; number == 0)</li>
</ul>
<p>The password is at our fingertips now.</p>
<pre><code class="language-sh">./crackme0x05
IOLI Crackme Level 0x05
Password: 88
Password OK!

./crackme0x05
IOLI Crackme Level 0x05
Password: 12346
Password OK!
</code></pre>
<p>we can also use angr to solve it since we have two constraints to the password.</p>
<h1 id="ioli-0x06"><a class="header" href="#ioli-0x06">IOLI 0x06</a></h1>
<p>nearly a routine to check this binary (not complete output in the following):</p>
<pre><code class="language-shell">rz-bin -z ./crackme0x06
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x00000738 0x08048738 4   5    .rodata ascii LOLO
1   0x00000740 0x08048740 13  14   .rodata ascii Password OK!\n
2   0x0000074e 0x0804874e 20  21   .rodata ascii Password Incorrect!\n
3   0x00000763 0x08048763 24  25   .rodata ascii IOLI Crackme Level 0x06\n
4   0x0000077c 0x0804877c 10  11   .rodata ascii Password:

rz-bin -I ./crackme0x06
arch     x86
baddr    0x8048000
bintype  elf
bits     32
compiler GCC: (GNU) 3.4.6 (Gentoo 3.4.6-r2, ssp-3.4.6-1.0, pie-8.7.10)
crypto   false
endian   little
havecode true
lang     c
machine  Intel 80386
maxopsz  16
minopsz  1
os       linux
static   false
va       true
</code></pre>
<p>and analyze it then decompile main</p>
<pre><code class="language-C">[0x08048400]&gt; pdd@main
/* jsdec pseudo code output */
/* ./crackme0x06 @ 0x8048607 */
#include &lt;stdint.h&gt;

int32_t main (int32_t arg_10h) {
    int32_t var_78h;
    int32_t var_4h;
    // adjusting stack
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;

    // main logic
    printf (&quot;IOLI Crackme Level 0x06\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_78h;
    scanf (0x8048787, eax);
    eax = arg_10h;
    eax = &amp;var_78h;
    check (eax, arg_10h);
    eax = 0;
    return eax;
}
</code></pre>
<p>main has 3 arguments <code>argc, argv, envp</code>, and this program is compiled with GCC, so the stack should be like this :</p>
<pre><code class="language-sh">[esp + 0x10] - envp
[esp + 0x0c] - argv
[esp + 0x08] - argc
[esp + 0x04] - return address
</code></pre>
<p>enter the <code>check()</code> and decompile it. this function is different from 0x05 now. but they still have similar code structure.</p>
<pre><code class="language-C">int32_t check (char * s, int32_t arg_ch) {
    char * var_dh;
    uint32_t var_ch;
    uint32_t var_8h;
    int32_t var_4h;
    char * format;
    int32_t var_sp_8h;
    var_8h = 0;
    var_ch = 0;
    do {
        eax = s;
        eax = strlen (eax);
        if (var_ch &gt;= eax) {
            goto label_0;
        }
        eax = var_ch;
        eax += s;
        eax = *(eax);
        var_dh = al;
        eax = &amp;var_4h;
        eax = &amp;var_dh;
        sscanf (eax, eax, 0x804873d);
        edx = var_4h;
        eax = &amp;var_8h;
        *(eax) += edx;
        if (var_8h == 0x10) {
            eax = arg_ch;
            eax = s;
            parell (eax, arg_ch);
        }
        eax = &amp;var_ch;
        *(eax)++;
    } while (1);
label_0:
    printf (&quot;Password Incorrect!\n&quot;);
    return eax;
}
</code></pre>
<p>Correct the <code>sscanf</code> part and <code>parell</code> part, both of them were generated incorrectly:</p>
<pre><code class="language-C">int32_t check (char * s, void* envp)
{
    var_ch = 0;
    var_8h = 0;
    for (var_ch = 0; var_ch &lt; strlen(s); ++var_ch)
    {
        var_dh = s[var_ch];
        sscanf(&amp;var_dh, %d, &amp;var_4h);			// read from string[var_ch], store to var_4h
        var_8h += var_4h;
        if(var_8h == 0x10)
            parell(s, envp);
    }
    printf(&quot;Password Incorrect!\n&quot;);
    return 0;
}
</code></pre>
<p>no more info, we have to reverse <code>parell()</code> again.</p>
<pre><code class="language-C">#include &lt;stdint.h&gt;

uint32_t parell (char * s, char * arg_ch) {
    sscanf (s, %d, &amp;var_4h);

    if (dummy (var_4h, arg_ch) == 0)
        return 0;

    for (var_bp_8h = 0; var_bp_8h &lt;= 9; ++var_bp_8h){
        if (var_4h &amp; 1 == 0){
            printf(&quot;Password OK!\n&quot;);
            exit(0);
        }
    }

    return 0;
}
</code></pre>
<p>well, there is a new check condition in <code>parell()</code> -- <code>dummy (var_4h, arg_ch) == 0</code>. then reverse dummy!</p>
<pre><code class="language-C">[0x080484b4]&gt; pdd@sym.dummy
/* jsdec pseudo code output */
/* ./crackme0x06 @ 0x80484b4 */
#include &lt;stdint.h&gt;

int32_t dummy (char ** s1) {
    int32_t var_8h;
    int32_t var_4h;
    char * s2;
    size_t * n;
    var_4h = 0;
    do {
        eax = 0;
        edx = eax*4;
        eax = s1;
        if (*((edx + eax)) == 0) {
            goto label_0;
        }
        eax = var_4h;
        ecx = eax*4;
        edx = s1;
        eax = &amp;var_4h;
        *(eax)++;
        eax = *((ecx + edx));
        eax = strncmp (eax, 3, &quot;LOLO&quot;);
    } while (eax != 0);
    var_8h = 1;
    goto label_1;
label_0:
    var_8h = 0;
label_1:
    eax = 0;
    return eax;
}
</code></pre>
<p>looks like a loop to process string. we can beautify it.</p>
<pre><code class="language-C">[0x080484b4]&gt; pdd@sym.dummy
/* jsdec pseudo code output */
/* ./crackme0x06 @ 0x80484b4 */
#include &lt;stdint.h&gt;

int32_t dummy (char ** s1) {
    for (var_4h = 0; strncmp(s1[var_4h], &quot;LOLO&quot;, 3) != 0; var_4h++){
        if (s1[i] == NULL)
            return 0;
    }
    return 1;
}
</code></pre>
<p>There are 3 constraints to crackme_0x06:</p>
<ul>
<li>Digit Sum</li>
<li>Odd Number</li>
<li>should have an environment variable whose name started with &quot;LOL&quot;.</li>
</ul>
<pre><code class="language-sh">$ ./crackme0x06
IOLI Crackme Level 0x06
Password: 12346
Password Incorrect!
$ export LOLAA=help
$ ./cracke0x06
IOLI Crackme Level 0x06
Password: 12346
Password OK!
</code></pre>
<h1 id="ioli-0x07"><a class="header" href="#ioli-0x07">IOLI 0x07</a></h1>
<p>a weird &quot;wtf?&quot; string.</p>
<pre><code class="language-sh">$ rz-bin -z ./crackme0x07
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x000007a8 0x080487a8 4   5    .rodata ascii LOLO
1   0x000007ad 0x080487ad 20  21   .rodata ascii Password Incorrect!\n
2   0x000007c5 0x080487c5 13  14   .rodata ascii Password OK!\n
3   0x000007d3 0x080487d3 5   6    .rodata ascii wtf?\n
4   0x000007d9 0x080487d9 24  25   .rodata ascii IOLI Crackme Level 0x07\n
5   0x000007f2 0x080487f2 10  11   .rodata ascii Password:
</code></pre>
<p>again, no password string or compare in <code>main()</code>. I put the simplified pseudo code here. var_78h is likely to a char *pointer (string) .</p>
<pre><code class="language-asm">#include &lt;stdint.h&gt;
int32_t main (int32_t arg_10h) {
    printf (&quot;IOLI Crackme Level 0x07\n&quot;);
    printf (&quot;Password: &quot;);
    scanf (%s, &amp;var_78h);
    return fcn_080485b9 (&amp;var_78h, arg_10h);
}
</code></pre>
<p>due to the symbol info lost, neither <code>aa</code> nor <code>aaa</code> show the name of functions. we can double check this in &quot;flagspace&quot;. Rizin use fcn_080485b9 as the function name. It's a common case in reverse engineering that we don't have any symbol info of the binary.</p>
<pre><code class="language-sh">[0x080487fd]&gt; fs symbols
[0x080487fd]&gt; f
0x08048400 33 entry0
0x0804867d 92 main
0x080487a4 4 obj._IO_stdin_used
</code></pre>
<p>decompile the <code>fcn_080485b9()</code>:</p>
<pre><code class="language-C">[0x080485b9]&gt; pdfc
            ; CALL XREF from main @ 0x80486d4
/ 118: fcn.080485b9 (char *s, int32_t arg_ch);
|           ; var char *var_dh @ ebp-0xd
|           ; var signed int var_ch  { &gt;= 0xffffffffffffffff} @ ebp-0xc
|           ; var uint32_t var_8h @ ebp-0x8
|           ; var int32_t var_bp_4h @ ebp-0x4
|           ; arg char *s @ ebp+0x8
|           ; arg int32_t arg_ch @ ebp+0xc
|           ; var char *format @ esp+0x4
|           ; var int32_t var_sp_8h @ esp+0x8
|           0x080485b9      55             push ebp
|           0x080485ba      89e5           mov ebp, esp
|           0x080485bc      83ec28         sub esp, 0x28
|           0x080485bf      c745f8000000.  mov dword [var_8h], 0
|           0x080485c6      c745f4000000.  mov dword [var_ch], 0
|           ; CODE XREF from fcn.080485b9 @ 0x8048628
|       .-&gt; 0x080485cd      8b4508         mov eax, dword [s]
|       :   0x080485d0      890424         mov dword [esp], eax        ; const char *s
|       :   0x080485d3      e8d0fdffff     call sym.imp.strlen         ; size_t strlen(const char *s)
|       :   0x080485d8      3945f4         cmp dword [var_ch], eax
|      ,==&lt; 0x080485db      734d           jae 0x804862a
|      |:   0x080485dd      8b45f4         mov eax, dword [var_ch]
|      |:   0x080485e0      034508         add eax, dword [s]
|      |:   0x080485e3      0fb600         movzx eax, byte [eax]
|      |:   0x080485e6      8845f3         mov byte [var_dh], al
|      |:   0x080485e9      8d45fc         lea eax, [var_bp_4h]
|      |:   0x080485ec      89442408       mov dword [var_sp_8h], eax  ;   ...
|      |:   0x080485f0      c7442404c287.  mov dword [format], 0x80487c2 ; [0x80487c2:4]=0x50006425 ; const char *format
|      |:   ;-- eip:
|      |:   0x080485f8      8d45f3         lea eax, [var_dh]
|      |:   0x080485fb      890424         mov dword [esp], eax        ; const char *s
|      |:   0x080485fe      e8c5fdffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)
|      |:   0x08048603      8b55fc         mov edx, dword [var_bp_4h]
|      |:   0x08048606      8d45f8         lea eax, [var_8h]
|      |:   0x08048609      0110           add dword [eax], edx
|      |:   0x0804860b      837df810       cmp dword [var_8h], 0x10
|     ,===&lt; 0x0804860f      7512           jne 0x8048623
|     ||:   0x08048611      8b450c         mov eax, dword [arg_ch]
|     ||:   0x08048614      89442404       mov dword [format], eax     ; char *arg_ch
|     ||:   0x08048618      8b4508         mov eax, dword [s]
|     ||:   0x0804861b      890424         mov dword [esp], eax        ; char *s
|     ||:   0x0804861e      e81fffffff     call fcn.08048542
|     ||:   ; CODE XREF from fcn.080485b9 @ 0x804860f
|     `---&gt; 0x08048623      8d45f4         lea eax, [var_ch]
|      |:   0x08048626      ff00           inc dword [eax]
|      |`=&lt; 0x08048628      eba3           jmp 0x80485cd
|      |    ; CODE XREF from fcn.080485b9 @ 0x80485db
\      `--&gt; 0x0804862a      e8f5feffff     call fcn.08048524
</code></pre>
<p>we got familiar with this code structure in the previous challenges (the check function). It's not difficult for us even we don't have the symbol info. you can also use <code>afn</code> command to rename the function name if you like.</p>
<pre><code class="language-C">int32_t fcn_080485b9 (char * s, void* envp)
{
    var_ch = 0;
    var_8h = 0;
    for (var_ch = 0; var_ch &lt; strlen(s); ++var_ch)
    {
        var_dh = s[var_ch];
        sscanf(&amp;var_dh, %d, &amp;var_4h);			// read from string[var_ch], store to var_4h
        var_8h += var_4h;
        if(var_8h == 0x10)
            fcn_08048542(s, envp);
    }
    return fcn_08048524();
}
</code></pre>
<p>most part of crackme 0x07 is the same with 0x06. and it can be solved by the same password &amp; environment:</p>
<pre><code class="language-sh">$ export LOLAA=help
$ ./cracke0x07
IOLI Crackme Level 0x07
Password: 12346
Password OK!
</code></pre>
<p>wait ... where is the 'wtf?'. Often, we would like to find the cross reference (xref) to strings (or data, functions, etc.) in reverse engineering. The related commands in Rizin are under &quot;ax&quot; namespace:</p>
<pre><code class="language-sh">[0x08048400]&gt; f
0x080487a8 5 str.LOLO
0x080487ad 21 str.Password_Incorrect
0x080487c5 14 str.Password_OK
0x080487d3 6 str.wtf
0x080487d9 25 str.IOLI_Crackme_Level_0x07
0x080487f2 11 str.Password:
[0x08048400]&gt; axt 0x80487d3
(nofunc) 0x804865c [DATA] mov dword [esp], str.wtf
[0x08048400]&gt; axF str.wtf
Finding references of flags matching 'str.wtf'...
[0x001eff28-0x001f0000] (nofunc) 0x804865c [DATA] mov dword [esp], str.wtf
Macro 'findstref' removed.
</code></pre>
<p>the <code>[DATA] mov dword [esp], str.wtf</code> at <code>0x804865c</code> is an instruction of fcn.080485b9. But the analysis in my PC ignores the remained instructions and only display the incomplete assembly. the range of fcn.080485b9 should be <code>0x080485b9 ~ 0x0804867c</code> . we can reset block size and print opcodes.</p>
<pre><code>[0x08040000]&gt; s 0x080485b9
[0x080485b9]&gt; b 230
[0x08048400]&gt; pd
...
            0x0804862f      8b450c         mov eax, dword [ebp + 0xc]
            0x08048632      89442404       mov dword [esp + 4], eax
            0x08048636      8b45fc         mov eax, dword [ebp - 4]
            0x08048639      890424         mov dword [esp], eax        ; char **s1
            0x0804863c      e873feffff     call fcn.080484b4
            0x08048641      85c0           test eax, eax
        ,=&lt; 0x08048643      7436           je 0x804867b
        |   0x08048645      c745f4000000.  mov dword [ebp - 0xc], 0
        |   ; CODE XREF from fcn.080485b9 @ +0xc0
       .--&gt; 0x0804864c      837df409       cmp dword [ebp - 0xc], 9
      ,===&lt; 0x08048650      7f29           jg 0x804867b
      |:|   0x08048652      8b45fc         mov eax, dword [ebp - 4]
      |:|   0x08048655      83e001         and eax, 1
      |:|   0x08048658      85c0           test eax, eax
     ,====&lt; 0x0804865a      7518           jne 0x8048674
     ||:|   0x0804865c      c70424d38704.  mov dword [esp], str.wtf    ; [0x80487d3:4]=0x3f667477 ; &quot;wtf?\n&quot; ; const char *format
     ||:|   0x08048663      e850fdffff     call sym.imp.printf         ; int printf(const char *format)
     ||:|   0x08048668      c70424000000.  mov dword [esp], 0          ; int status
     ||:|   0x0804866f      e874fdffff     call sym.imp.exit           ; void exit(int status)
     ||:|   ; CODE XREF from fcn.080485b9 @ +0xa1
     `----&gt; 0x08048674      8d45f4         lea eax, [ebp - 0xc]
      |:|   0x08048677      ff00           inc dword [eax]
      |`==&lt; 0x08048679      ebd1           jmp 0x804864c
      | |   ; CODE XREFS from fcn.080485b9 @ +0x8a, +0x97
      `-`-&gt; 0x0804867b      c9             leave
            0x0804867c      c3             ret

</code></pre>
<p><code>test eax, ea;je 0x804867b</code> will jump to <code>leave; ret</code>, which forever skips the str.wtf part. only use <code>aa</code> to analyze this binary can display the whole function.</p>
<h1 id="ioli-0x08"><a class="header" href="#ioli-0x08">IOLI 0x08</a></h1>
<p>we can reverse it and find it's similar to 0x07, and use the same password to solve it:</p>
<pre><code class="language-sh">$ export LOLAA=help
$ ./cracke0x08
IOLI Crackme Level 0x08
Password: 12346
Password OK!
</code></pre>
<p><a href="https://dustri.org/b/defeating-ioli-with-rizin.html">dustri</a> provided a better way to check crackme0x08. 0x07 is the stripped version of 0x08.</p>
<pre><code class="language-sh">$ rz-diff -A -C ./crackme0x07 ./crackme0x08
...
              fcn.08048360  23 0x8048360 |   MATCH  (1.000000) | 0x8048360   23 sym._init
 sym.imp.__libc_start_main   6 0x8048388 |   MATCH  (1.000000) | 0x8048388    6 sym.imp.__libc_start_main
             sym.imp.scanf   6 0x8048398 |   MATCH  (1.000000) | 0x8048398    6 sym.imp.scanf
            sym.imp.strlen   6 0x80483a8 |   MATCH  (1.000000) | 0x80483a8    6 sym.imp.strlen
            sym.imp.printf   6 0x80483b8 |   MATCH  (1.000000) | 0x80483b8    6 sym.imp.printf
            sym.imp.sscanf   6 0x80483c8 |   MATCH  (1.000000) | 0x80483c8    6 sym.imp.sscanf
           sym.imp.strncmp   6 0x80483d8 |   MATCH  (1.000000) | 0x80483d8    6 sym.imp.strncmp
              sym.imp.exit   6 0x80483e8 |   MATCH  (1.000000) | 0x80483e8    6 sym.imp.exit
                    entry0  33 0x8048400 |   MATCH  (1.000000) | 0x8048400   33 entry0
              fcn.08048424  33 0x8048424 |   MATCH  (1.000000) | 0x8048424   33 fcn.08048424
              fcn.08048450  47 0x8048450 |   MATCH  (1.000000) | 0x8048450   47 sym.__do_global_dtors_aux
              fcn.08048480  50 0x8048480 |   MATCH  (1.000000) | 0x8048480   50 sym.frame_dummy
              fcn.080484b4 112 0x80484b4 |   MATCH  (1.000000) | 0x80484b4  112 sym.dummy
              fcn.08048524  30 0x8048524 |   MATCH  (1.000000) | 0x8048524   30 sym.che
              fcn.08048542 119 0x8048542 |   MATCH  (1.000000) | 0x8048542  119 sym.parell
              fcn.080485b9 118 0x80485b9 |   MATCH  (1.000000) | 0x80485b9  118 sym.check
                      main  92 0x804867d |   MATCH  (1.000000) | 0x804867d   92 main
              fcn.08048755   4 0x8048755 |   MATCH  (1.000000) | 0x8048755    4 sym.__i686.get_pc_thunk.bx
              fcn.08048760  35 0x8048760 |   MATCH  (1.000000) | 0x8048760   35 sym.__do_global_ctors_aux
              fcn.0804878d  17 0x804878d |     NEW  (0.000000)
       sym.__libc_csu_init  99 0x80486e0 |     NEW  (0.000000)
       sym.__libc_csu_fini   5 0x8048750 |     NEW  (0.000000)
                 sym._fini  26 0x8048784 |     NEW  (0.000000)
</code></pre>
<h1 id="ioli-0x09"><a class="header" href="#ioli-0x09">IOLI 0x09</a></h1>
<p>Hints: crackme0x09 hides the format string (%d and %s), and nothing more than 0x08.</p>
<pre><code class="language-sh">$ export LOLA=help
$ ./crackme0x09
IOLI Crackme Level 0x09
Password: 12346
Password OK!
</code></pre>
<h2 id="avatao-r3v3rs3-4"><a class="header" href="#avatao-r3v3rs3-4">Avatao R3v3rs3 4</a></h2>
<p>After a few years of missing out on wargames at
<a href="https://hacktivity.com">Hacktivity</a>, this year I've finally found the time to
begin, and almost finish (yeah, I'm quite embarrassed about that unfinished
webhack :) ) one of them. There were 3 different games at the conf, and I've
chosen the one that was provided by <a href="https://avatao.com">avatao</a>. It consisted
of 8 challenges, most of them being basic web hacking stuff, one sandbox escape,
one simple buffer overflow exploitation, and there were two reverse engineering
exercises too. You can find these challenges on https://platform.avatao.com.</p>
<h2 id="rizin-1"><a class="header" href="#rizin-1">.rizin</a></h2>
<p>I've decided to solve the reversing challenges using
<a href="http://www.rizin.org/r/">rizin</a>, a free and open source reverse engineering
framework. I have first learned about rizin back in 2011. during a huge project,
where I had to reverse a massive, 11MB statically linked ELF. I simply needed
something that I could easily patch Linux ELFs with. Granted, back then I've
used rizin alongside IDA, and only for smaller tasks, but I loved the whole concept
at first sight. Since then, rizin evolved a lot, and I was planning for some
time now to solve some crackmes with the framework, and write writeups about
them. Well, this CTF gave me the perfect opportunity :)</p>
<p>Because this writeup aims to show some of rizin's features besides how the crackmes
can be solved, I will explain every rizin command I use in blockquote paragraphs
like this one:</p>
<blockquote>
<p><em><strong>rizin tip:</strong></em> Always use ? or -h to get more information!</p>
</blockquote>
<p>If you know rizin, and just interested in the crackme, feel free to skip those
parts! Also keep in mind please, that because of this tutorial style I'm going
to do a lot of stuff that you just don't do during a CTF, because there is no
time for proper bookkeeping (e.g. flag every memory area according to its
purpose), and with such small executables you can succeed without doing these
stuff.</p>
<p>A few advice if you are interested in learning rizin (and frankly, if you are
into RE, you should be interested in learning rizin :) ):</p>
<p>The framework has a lot of supplementary executables and a vast amount of
functionality - and they are very well documented. I encourage you to read the
available docs, and use the built-in help (by appending a ? to any command)
extensively! E.g.:</p>
<pre><code>[0x00000000]&gt; ?
Usage: [.][times][cmd][~grep][@[@iter]addr!size][|&gt;pipe] ; ...
Append '?' to any char command to get detailed help
Prefix with number to repeat command N times (f.ex: 3x)
|%var =valueAlias for 'env' command
| *off[=[0x]value]     Pointer read/write data/values (see ?v, wx, wv)
| (macro arg0 arg1)    Manage scripting macros
| .[-|(m)|f|!sh|cmd]   Define macro or load rizin, cparse or rlang file
| = [cmd]              Run this command via rap://
| /                    Search for bytes, regexps, patterns, ..
| ! [cmd]              Run given command as in system(3)
| # [algo] [len]       Calculate hash checksum of current block
| #!lang [..]          Hashbang to run an rlang script
| a                    Perform analysis of code
| b                    Get or change block size

...

[0x00000000]&gt; a?
|Usage: a[abdefFghoprxstc] [...]
| ab [hexpairs]     analyze bytes
| aa                analyze all (fcns + bbs) (aa0 to avoid sub renaming)
| ac [cycles]       analyze which op could be executed in [cycles]
| ad                analyze data trampoline (wip)
| ad [from] [to]    analyze data pointers to (from-to)
| ae [expr]         analyze opcode eval expression (see ao)
| af[rnbcsl?+-*]    analyze Functions
| aF                same as above, but using analysis.depth=1

...
</code></pre>
<p>Also, the project is under heavy development, there is no day
without commits to the GitHub repo. So, as the readme says, you should always
use the git version!</p>
<p>Some highly recommended reading materials:</p>
<ul>
<li><a href="https://book.rizin.re">Rizin Book</a></li>
<li><a href="https://rizin.re/posts/">Rizin Blog</a></li>
</ul>
<h2 id="first_steps"><a class="header" href="#first_steps">.first_steps</a></h2>
<p>OK, enough of praising rizin, lets start reversing this stuff. First, you have to
know your enemy:</p>
<pre><code>[0x00 avatao]$ rz-bin -I reverse4
pic      false
canary   true
nx       true
crypto   false
va       true
intrp    /lib64/ld-linux-x86-64.so.2
bintype  elf
class    ELF64
lang     c
arch     x86
bits     64
machine  AMD x86-64 architecture
os       linux
subsys   linux
endian   little
stripped true
static   false
linenum  false
lsyms    false
relocs   false
rpath    NONE
binsz    8620
</code></pre>
<blockquote>
<p><em><strong>rizin tip:</strong></em> rz-bin is one of the handy tools that comes with rizin. It can
be used to extract information (imports, symbols, libraries, etc.) about
binary executables. As always, check the help (rz-bin -h)!</p>
</blockquote>
<p>So, its a dynamically linked, stripped, 64bit Linux executable - nothing fancy
here. Let's try to run it:</p>
<pre><code>[0x00 avatao]$ ./reverse4
?
Size of data: 2623
pamparam
Wrong!

[0x00 avatao]$ &quot;\x01\x00\x00\x00&quot; | ./reverse4
Size of data: 1
</code></pre>
<p>OK, so it reads a number as a size from the standard input first, than reads
further, probably &quot;size&quot; bytes/characters, processes this input, and outputs
either &quot;Wrong!&quot;, nothing or something else, presumably our flag. But do not
waste any more time monkeyfuzzing the executable, let's fire up rizin, because in
asm we trust!</p>
<pre><code>[0x00 avatao]$ rizin -A reverse4
 -- Heisenbug: A bug that disappears or alters its behavior when one attempts to probe or isolate it.
[0x00400720]&gt;
</code></pre>
<blockquote>
<p><em><strong>rizin tip:</strong></em> The -A switch runs <em>aaa</em> command at start to analyze all
referenced code, so we will have functions, strings, XREFS, etc. right at the
beginning. As usual, you can get help with <em>?</em>.</p>
</blockquote>
<p>It is a good practice to create a project, so we can save our progress, and we
can come back at a later time:</p>
<pre><code>[0x00400720]&gt; Ps avatao_reverse4
avatao_reverse4
[0x00400720]&gt;
</code></pre>
<blockquote>
<p><em><strong>rizin tip:</strong></em> You can save a project using Ps [file], and load one using Po [file].
With the -p option, you can load a project when starting rizin.</p>
</blockquote>
<p>We can list all the strings rizin found:</p>
<pre><code>[0x00400720]&gt; fs strings
[0x00400720]&gt; f
0x00400e98 7 str.Wrong_
0x00400e9f 27 str.We_are_in_the_outer_space_
0x00400f80 18 str.Size_of_data:__u_n
0x00400f92 23 str.Such_VM__MuCH_reV3rse_
0x00400fa9 16 str.Use_everything_
0x00400fbb 9 str.flag.txt
0x00400fc7 26 str.You_won__The_flag_is:__s_n
0x00400fe1 21 str.Your_getting_closer_
[0x00400720]&gt;
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: rizin puts so called flags on important/interesting offsets, and
organizes these flags into flagspaces (strings, functions, symbols, etc.) You
can list all flagspaces using <em>fs</em>, and switch the current one using
<em>fs [flagspace]</em> (the default is *, which means all the flagspaces). The
command <em>f</em> prints all flags from the currently selected flagspace(s).</p>
</blockquote>
<p>OK, the strings looks interesting, especially the one at 0x00400f92. It seems to
hint that this crackme is based on a virtual machine. Keep that in mind!</p>
<p>These strings could be a good starting point if we were talking about a
real-life application with many-many features. But we are talking about a
crackme, and they tend to be small and simple, and focused around the problem to
be solved. So I usually just take a look at the entry point(s) and see if I can
figure out something from there. Nevertheless, I'll show you how to find where
these strings are used:</p>
<pre><code>[0x00400720]&gt; axt @@=`f~[0]`
d 0x400cb5 mov edi, str.Size_of_data:__u_n
d 0x400d1d mov esi, str.Such_VM__MuCH_reV3rse_
d 0x400d4d mov edi, str.Use_everything_
d 0x400d85 mov edi, str.flag.txt
d 0x400db4 mov edi, str.You_won__The_flag_is:__s_n
d 0x400dd2 mov edi, str.Your_getting_closer_
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: We can list cross-references to addresses using the <em>axt [addr]</em>
command (similarly, we can use <em>axf</em> to list references from the address).
The <em>@@</em> is an iterator, it just runs the command once for every arguments
listed.</p>
<p>The argument list in this case comes from the command <em>f~[0]</em>. It lists the
strings from the executable with <em>f</em>, and uses the internal grep command <em>~</em>
to select only the first column (<em>[0]</em>) that contains the strings' addresses.</p>
</blockquote>
<h2 id="main-1"><a class="header" href="#main-1">.main</a></h2>
<p>As I was saying, I usually take a look at the entry point, so let's just do
that:</p>
<pre><code>[0x00400720]&gt; s main
[0x00400c63]&gt;
</code></pre>
<blockquote>
<p><em><strong>rizin tip:</strong></em> You can go to any offset, flag, expression, etc. in the
executable using the <em>s</em> command (seek). You can use references, like <em>$$</em>
(current offset), you can undo (<em>s-</em>) or redo (<em>s+</em>) seeks, search strings
(<em>s/ [string]</em>) or hex values (<em>s/x 4142</em>), and a lot of other useful stuff.
Make sure to check out <em>s?</em>!</p>
</blockquote>
<p>Now that we are at the beginning of the main function, we could use <em>p</em> to show
a disassembly (<em>pd</em>, <em>pdf</em>), but rizin can do something much cooler: it has a
visual mode, and it can display graphs similar to IDA, but way cooler, since
they are ASCII-art graphs :)</p>
<blockquote>
<p><em><strong>rizin tip:</strong></em> The command family <em>p</em> is used to print stuff. For example it can
show disassembly (<em>pd</em>), disassembly of the current function (<em>pdf</em>), print
strings (<em>ps</em>), hexdump (<em>px</em>), base64 encode/decode data (<em>p6e</em>, <em>p6d</em>), or
print raw bytes (<em>pr</em>) so you can for example dump parts of the binary to other
files. There are many more functionalities, check <em>?</em>!</p>
</blockquote>
<p>R2 also has a minimap view which is incredibly useful for getting an overall
look at a function:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/main_minimap.png" alt="main functions's minimap" /></p>
<blockquote>
<p><em><strong>rizin tip:</strong></em> With command <em>V</em> you can enter the so-called visual mode, which
has several views. You can switch between them using <em>p</em> and <em>P</em>. The graph
view can be displayed by hitting <em>V</em> in visual mode (or using <em>VV</em> at the
prompt).</p>
<p>Hitting <em>p</em> in graph view will bring up the minimap. It displays the
basic blocks and the connections between them in the current function, and it
also shows the disassembly of the currently selected block (marked with @@@@@
on the minimap). You can select the next or the previous block using the
*&lt;TAB&gt;* and the *&lt;SHIFT&gt;&lt;TAB&gt;* keys respectively. You can also
select the true or the false branches using the <em>t</em> and the <em>f</em> keys.</p>
<p>It is possible to bring up the prompt in visual mode using the <em>:</em> key, and
you can use <em>o</em> to seek.</p>
</blockquote>
<p>Lets read main node-by-node! The first block looks like this:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0c63.png" alt="main bb-0c63" /></p>
<p>We can see that the program reads a word (2 bytes) into the local variable named
<em>local_10_6</em>, and than compares it to 0xbb8. That's 3000 in decimal:</p>
<pre><code>[0x00400c63]&gt; ? 0xbb8
3000 0xbb8 05670 2.9K 0000:0bb8 3000 10111000 3000.0 0.000000f 0.000000
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: yep, <em>?</em> will evaluate expressions, and print the result in
various formats.</p>
</blockquote>
<p>If the value is greater than 3000, then it will be forced to be 3000:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0ca6.png" alt="main bb-0ca6" /></p>
<p>There are a few things happening in the next block:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0cac.png" alt="main bb-0cac" /></p>
<p>First, the &quot;Size of data: &quot; message we saw when we run the program is printed.
So now we know that the local variable <em>local_10_6</em> is the size of the input
data - so lets name it accordingly (remember, you can open the rizin shell from
visual mode using the <em>:</em> key!):</p>
<pre><code>:&gt; afvn local_10_6 input_size
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: The <em>af</em> command family is used to analyze functions. This
includes manipulating arguments and local variables too, which is accessible
via the <em>afv</em> commands. You can list function arguments (<em>afa</em>),  local
variables (<em>afv</em>), or you can even rename them (<em>afan</em>, <em>afvn</em>). Of course
there are lots of other features too - as usual: use the &quot;?&quot;, Luke!</p>
</blockquote>
<p>After this an <em>input_size</em> bytes long memory chunk is allocated, and filled with
data from the standard input. The address of this memory chunk is stored in
<em>local_10</em> - time to use <em>afvn</em> again:</p>
<pre><code>:&gt; afvn local_10 input_data
</code></pre>
<p>We've almost finished with this block, there are only two things remained.
First, an 512 (0x200) bytes memory chunk is zeroed out at offset 0x00602120.
A quick glance at XREFS to this address reveals that this memory is indeed used
somewhere in the application:</p>
<pre><code>:&gt; axt 0x00602120
d 0x400cfe mov edi, 0x602120
d 0x400d22 mov edi, 0x602120
d 0x400dde mov edi, 0x602120
d 0x400a51 mov qword [rbp - 8], 0x602120
</code></pre>
<p>Since it probably will be important later on, we should label it:</p>
<pre><code>:&gt; f sym.memory 0x200 0x602120
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: Flags can be managed using the <em>f</em> command family. We've just
added the flag sym.memory to a 0x200 bytes long memory area at 0x602120. It is
also possible to remove (<em>f-name</em>), rename (<em>fr [old] [new]</em>), add comment
(<em>fC [name] [cmt]</em>) or even color (<em>fc [name] [color]</em>) flags.</p>
</blockquote>
<p>While we are here, we should also declare that memory chunk as data, so it will
show up as a hexdump in disassembly view:</p>
<pre><code>:&gt; Cd 0x200 @ sym.memory
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: The command family <em>C</em> is used to manage metadata. You can set
(<em>CC</em>) or edit (<em>CC</em>) comments, declare memory areas as data (<em>Cd</em>), strings
(<em>Cs</em>), etc. These commands can also be issued via a menu in visual mode
invoked by pressing <em>d</em>.</p>
</blockquote>
<p>The only remaining thing in this block is a function call to 0x400a45 with the
input data as an argument. The function's return value is compared to &quot;*&quot;, and
a conditional jump is executed depending on the result.</p>
<p>Earlier I told you that this crackme is probably based on a virtual machine.
Well, with that information in mind, one can guess that this function will be
the VM's main loop, and the input data is the instructions the VM will execute.
Based on this hunch, I've named this function <em>vmloop</em>, and renamed
<em>input_data</em> to <em>bytecode</em> and <em>input_size</em> to <em>bytecode_length</em>. This is not
really necessary in a small project like this, but it's a good practice to name
stuff according to their purpose (just like when you are writing programs).</p>
<pre><code>:&gt; af vmloop 0x400a45
:&gt; afvn input_size bytecode_length
:&gt; afvn input_data bytecode
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: The <em>af</em> command is used to analyze a function with a given name
at the given address. The other two commands should be familiar from earlier.</p>
</blockquote>
<p>After renaming local variables, flagging that memory area, and renaming the VM
loop function the disassembly looks like this:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0cac_meta.png" alt="main bb-0cac_meta" /></p>
<p>So, back to that conditional jump. If <em>vmloop</em> returns anything else than &quot;*&quot;,
the program just exits without giving us our flag. Obviously we don't want that,
so we follow the false branch.</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d1d.png" alt="main bb-0d1d" /></p>
<p>Now we see that a string in that 512 bytes memory area (<em>sym.memory</em>) gets
compared to &quot;Such VM! MuCH reV3rse!&quot;. If they are not equal, the program prints
the bytecode, and exits:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0dde.png" alt="main bb-0dde" /></p>
<p>OK, so now we know that we have to supply a bytecode that will generate that
string when executed. As we can see on the minimap, there are still a few more
branches ahead, which probably means more conditions to meet. Lets investigate
them before we delve into <em>vmloop</em>!</p>
<p>If you take a look at the minimap of the whole function, you can probably
recognize that there is some kind of loop starting at block <em>[<em>0d34</em>]</em>, and it
involves the following nodes:</p>
<ul>
<li>[<em>0d34</em>]</li>
<li>[<em>0d65</em>]</li>
<li>[<em>0d3d</em>]</li>
<li>[<em>0d61</em>]</li>
</ul>
<p>Here are the assembly listings for those blocks. The first one puts 0 into local
variable <em>local_10_4</em>:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d34.png" alt="main bb-0d34" /></p>
<p>And this one compares <em>local_10_4</em> to 8, and executing a conditional jump based
on the result:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d65.png" alt="main bb-0d65" /></p>
<p>It's pretty obvious that <em>local_10_4</em> is the loop counter, so lets name it
accordingly:</p>
<pre><code>:&gt; afvn local_10_4 i
</code></pre>
<p>Next block is the actual loop body:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d3d.png" alt="main bb-0d3d" /></p>
<p>The memory area at 0x6020e0 is treated as an array of dwords (4 byte values),
and checked if the ith value of it is zero. If it is not, the loop simply
continues:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d61.png" alt="main bb-0d61" /></p>
<p>If the value is zero, the loop breaks and this block is executed before exiting:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d4d.png" alt="main bb-0d4d" /></p>
<p>It prints the following message: Use everything!&quot; As we've established earlier,
we are dealing with a virtual machine. In that context, this message probably
means that we have to use every available instructions. Whether we executed an
instruction or not is stored at 0x6020e0 - so lets flag that memory area:</p>
<pre><code>:&gt; f sym.instr_dirty 4*9 0x6020e0
</code></pre>
<p>Assuming we don't break out and the loop completes, we are moving on to some
more checks:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d6b.png" alt="main bb-0d6b" /></p>
<p>This piece of code may look a bit strange if you are not familiar with x86_64
specific stuff. In particular, we are talking about RIP-relative addressing,
where offsets are described as displacements from the current instruction
pointer, which makes implementing PIE easier. Anyways, rizin is nice enough to
display the actual address (0x602104). Got the address, flag it!</p>
<pre><code>:&gt; f sym.good_if_ne_zero 4 0x602104
</code></pre>
<p>Keep in mind though, that if RIP-relative addressing is used, flags won't appear
directly in the disassembly, but rizin displays them as comments:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d6b_meta.png" alt="main bb-0d6b_meta" /></p>
<p>If <em>sym.good_if_ne_zero</em> is zero, we get a message (&quot;Your getting closer!&quot;), and
then the program exits. If it is non-zero, we move to the last check:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d75.png" alt="main bb-0d75" /></p>
<p>Here the program compares a dword at 0x6020f0 (again, RIP-relative addressing)
to 9. If its greater than 9, we get the same &quot;Your getting closer!&quot; message, but
if it's lesser, or equal to 9, we finally reach our destination, and get the flag:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d80.png" alt="main bb-0d80" /></p>
<p>As usual, we should flag 0x6020f0:</p>
<pre><code>:&gt; f sym.good_if_le_9 4 0x6020f0
</code></pre>
<p>Well, it seems that we have fully reversed the main function. To summarize it:
the program reads a bytecode from the standard input, and feeds it to a virtual
machine. After VM execution, the program's state have to satisfy these
conditions in order to reach the goodboy code:</p>
<ul>
<li><em>vmloop</em>'s return value has to be &quot;*&quot;</li>
<li><em>sym.memory</em> has to contain the string &quot;Such VM! MuCH reV3rse!&quot;</li>
<li>all 9 elements of <em>sym.instr_dirty</em> array should not be zero (probably means
that all instructions had to be used at least once)</li>
<li><em>sym.good_if_ne_zero</em> should not be zero</li>
<li><em>sym.good_if_le_9</em> has to be lesser or equal to 9</li>
</ul>
<p>This concludes our analysis of the main function, we can now move on to the VM
itself.</p>
<h2 id="vmloop"><a class="header" href="#vmloop">.vmloop</a></h2>
<pre><code>[offset]&gt; fcn.vmloop
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a45.png" alt="vmloop bb-0a45" /></p>
<p>Well, that seems disappointingly short, but no worries, we have plenty to
reverse yet. The thing is that this function uses a jump table at 0x00400a74,</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a74.png" alt="vmloop bb-0a74" /></p>
<p>and rizin can't yet recognize jump tables
(<a href="https://github.com/rizinorg/rizin/issues/3201">Issue 3201</a>), so the analysis of
this function is a bit incomplete. This means that we can't really use the graph
view now, so either we just use visual mode, or fix those basic blocks. The
entire function is just 542 bytes long, so we certainly could reverse it without
the aid of the graph mode, but since this writeup aims to include as much rizin
wisdom as possible, I'm going to show you how to define basic blocks.</p>
<p>First, lets analyze what we already have! First, <em>rdi</em> is put into local_3.
Since the application is a 64bit Linux executable, we know that <em>rdi</em> is the
first function argument (as you may have recognized, the automatic analysis of
arguments and local variables was not entirely correct), and we also know that
<em>vmloop</em>'s first argument is the bytecode. So lets rename local_3:</p>
<pre><code>:&gt; afvn local_3 bytecode
</code></pre>
<p>Next, <em>sym.memory</em> is put into another local variable at <em>rbp-8</em> that rizin did not
recognize. So let's define it!</p>
<pre><code>:&gt; afv 8 memory qword
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: The <em>afv [idx] [name] [type]</em> command is used to define local
variable at [frame pointer - idx] with the name [name] and type [type]. You
can also remove local variables using the <em>afv- [idx]</em> command.</p>
</blockquote>
<p>In the next block, the program checks one byte of bytecode, and if it is 0, the
function returns with 1.</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0c4d.png" alt="vmloop bb-0c4d" /></p>
<p>If that byte is not zero, the program subtracts 0x41 from it, and compares the
result to 0x17. If it is above 0x17, we get the dreaded &quot;Wrong!&quot; message, and
the function returns with 0. This basically means that valid bytecodes are ASCII
characters in the range of &quot;A&quot; (0x41) through &quot;X&quot; (0x41 + 0x17). If the bytecode
is valid, we arrive at the code piece that uses the jump table:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a74.png" alt="vmloop bb-0a74" /></p>
<p>The jump table's base is at 0x400ec0, so lets define that memory area as a
series of qwords:</p>
<pre><code>[0x00400a74]&gt; s 0x00400ec0
[0x00400ec0]&gt; Cd 8 @@=`?s $$ $$+8*0x17 8`
</code></pre>
<blockquote>
<p><em><strong>rizin tip</strong></em>: Except for the <em>?s</em>, all parts of this command should be
familiar now, but lets recap it! <em>Cd</em> defines a memory area as data, and 8 is
the size of that memory area. <em>@@</em> is an iterator that make the preceding
command run for every element that <em>@@</em> holds. In this example it holds a
series generated using the <em>?s</em> command. <em>?s</em> simply generates a series from
the current seek (<em>$$</em>) to current seek + 8<em>0x17 (</em>$$+8<em>0x17</em>) with a step
of 8.</p>
</blockquote>
<p>This is how the disassembly looks like after we add this metadata:</p>
<pre><code>[0x00400ec0]&gt; pd 0x18
            ; DATA XREF from 0x00400a76 (unk)
            0x00400ec0 .qword 0x0000000000400a80
            0x00400ec8 .qword 0x0000000000400c04
            0x00400ed0 .qword 0x0000000000400b6d
            0x00400ed8 .qword 0x0000000000400b17
            0x00400ee0 .qword 0x0000000000400c04
            0x00400ee8 .qword 0x0000000000400c04
            0x00400ef0 .qword 0x0000000000400c04
            0x00400ef8 .qword 0x0000000000400c04
            0x00400f00 .qword 0x0000000000400aec
            0x00400f08 .qword 0x0000000000400bc1
            0x00400f10 .qword 0x0000000000400c04
            0x00400f18 .qword 0x0000000000400c04
            0x00400f20 .qword 0x0000000000400c04
            0x00400f28 .qword 0x0000000000400c04
            0x00400f30 .qword 0x0000000000400c04
            0x00400f38 .qword 0x0000000000400b42
            0x00400f40 .qword 0x0000000000400c04
            0x00400f48 .qword 0x0000000000400be5
            0x00400f50 .qword 0x0000000000400ab6
            0x00400f58 .qword 0x0000000000400c04
            0x00400f60 .qword 0x0000000000400c04
            0x00400f68 .qword 0x0000000000400c04
            0x00400f70 .qword 0x0000000000400c04
            0x00400f78 .qword 0x0000000000400b99
</code></pre>
<p>As we can see, the address 0x400c04 is used a lot, and besides that there are 9
different addresses. Lets see that 0x400c04 first!</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0c04.png" alt="vmloop bb-0c04" /></p>
<p>We get the message &quot;Wrong!&quot;, and the function just returns 0. This means that
those are not valid instructions (they are valid bytecode though, they can be
e.g. parameters!) We should flag 0x400c04 accordingly:</p>
<pre><code>[0x00400ec0]&gt; f not_instr @ 0x0000000000400c04
</code></pre>
<p>As for the other offsets, they all seem to be doing something meaningful, so we
can assume they belong to valid instructions. I'm going to flag them using the
instructions' ASCII values:</p>
<pre><code>[0x00400ec0]&gt; f instr_A @ 0x0000000000400a80
[0x00400ec0]&gt; f instr_C @ 0x0000000000400b6d
[0x00400ec0]&gt; f instr_D @ 0x0000000000400b17
[0x00400ec0]&gt; f instr_I @ 0x0000000000400aec
[0x00400ec0]&gt; f instr_J @ 0x0000000000400bc1
[0x00400ec0]&gt; f instr_P @ 0x0000000000400b42
[0x00400ec0]&gt; f instr_R @ 0x0000000000400be5
[0x00400ec0]&gt; f instr_S @ 0x0000000000400ab6
[0x00400ec0]&gt; f instr_X @ 0x0000000000400b99
</code></pre>
<p>Ok, so these offsets were not on the graph, so it is time to define basic blocks
for them!</p>
<blockquote>
<p><em><strong>rizin tip</strong></em>: You can define basic blocks using the <em>afb+</em> command. You have
to supply what function the block belongs to, where does it start, and what is
its size. If the block ends in a jump, you have to specify where does it jump
too. If the jump is a conditional jump, the false branch's destination address
should be specified too.</p>
</blockquote>
<p>We can get the start and end addresses of these basic blocks from the full disasm
of <em>vmloop</em>.</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/vmloop-full.png" alt="vmloop full" /></p>
<p>As I've mentioned previously, the function itself is pretty short, and easy to
read, especially with our annotations. But a promise is a promise, so here is
how we can create the missing basic blocks for the instructions:</p>
<pre><code>[0x00400ec0]&gt; afb+ 0x00400a45 0x00400a80 0x00400ab6-0x00400a80 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400ab6 0x00400aec-0x00400ab6 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400aec 0x00400b17-0x00400aec 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400b17 0x00400b42-0x00400b17 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400b42 0x00400b6d-0x00400b42 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400b6d 0x00400b99-0x00400b6d 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400b99 0x00400bc1-0x00400b99 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400bc1 0x00400be5-0x00400bc1 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400be5 0x00400c04-0x00400be5 0x400c15
</code></pre>
<p>It is also apparent from the disassembly that besides the instructions there
are three more basic blocks. Lets create them too!</p>
<pre><code>[0x00400ec0]&gt; afb+ 0x00400a45 0x00400c15 0x00400c2d-0x00400c15 0x400c3c 0x00400c2d
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400c2d 0x00400c3c-0x00400c2d 0x400c4d 0x00400c3c
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400c3c 0x00400c4d-0x00400c3c 0x400c61
</code></pre>
<p>Note that the basic blocks starting at 0x00400c15 and 0x00400c2d ending in a
conditional jump, so we had to set the false branch's destination too!</p>
<p>And here is the graph in its full glory after a bit of manual restructuring:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/vmloop-graph-reconstructed_full.png" alt="vmloop graph" /></p>
<p>I think it worth it, don't you? :) (Well, the restructuring did not really worth
it, because it is apparently not stored when you save the project.)</p>
<blockquote>
<p><em><strong>rizin tip</strong></em>: You can move the selected node around in graph view using the
HJKL keys.</p>
</blockquote>
<p>By the way, here is how IDA's graph of this same function looks like for comparison:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop_ida.png" alt="IDA graph" /></p>
<p>As we browse through the disassembly of the <em>instr_LETTER</em> basic blocks, we
should realize a few things. The first: all of the instructions starts with a
sequence like these:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a80.png" alt="vmloop bb-0a80" /></p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0ab6.png" alt="vmloop bb-0ab6" /></p>
<p>It became clear now that the 9 dwords at <em>sym.instr_dirty</em> are not simply
indicators that an instruction got executed, but they are used to count how many
times an instruction got called. Also I should have realized earlier that
<em>sym.good_if_le_9</em> (0x6020f0) is part of this 9 dword array, but yeah, well, I
didn't, I have to live with it... Anyways, what the condition
&quot;<em>sym.good_if_le_9</em> have to be lesser or equal 9&quot; really means is that <em>instr_P</em>
can not be executed more than 9 times:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0b42.png" alt="vmloop bb-0b42" /></p>
<p>Another similarity of the instructions is that 7 of them calls a function with
either one or two parameters, where the parameters are the next, or the next two
bytecodes. One parameter example:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0aec.png" alt="vmloop bb-0aec" /></p>
<p>And a two parameters example:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a80_full.png" alt="vmloop bb-0a80_full" /></p>
<p>We should also realize that these blocks put the number of bytes they eat up of
the bytecode (1 byte instruction + 1 or 2 bytes arguments = 2 or 3) into a local
variable at 0xc. rizin did not recognize this local var, so lets do it manually!</p>
<pre><code>:&gt; afv 0xc instr_ptr_step dword
</code></pre>
<p>If we look at <em>instr_J</em> we can see that this is an exception to the above rule,
since it puts the return value of the called function into <em>instr_ptr_step</em>
instead of a constant 2 or 3:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0bc1.png" alt="vmloop bb-0bc1" /></p>
<p>And speaking of exceptions, here are the two instructions that do not call functions:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0be5.png" alt="vmloop bb-0be5" /></p>
<p>This one simply puts the next bytecode (the first the argument) into <em>eax</em>, and
jumps to the end of <em>vmloop</em>. So this is the VM's <em>ret</em> instruction, and we know
that <em>vmloop</em> has to return &quot;*&quot;, so &quot;R*&quot; should be the last two bytes of our
bytecode.</p>
<p>The next one that does not call a function:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0b6d.png" alt="vmloop bb-0b6d" /></p>
<p>This is a one argument instruction, and it puts its argument to 0x6020c0. Flag
that address!</p>
<pre><code>:&gt; f sym.written_by_instr_C 4 @ 0x6020c0
</code></pre>
<p>Oh, and by the way, I do have a hunch that <em>instr_C</em> also had a function call in
the original code, but it got inlined by the compiler. Anyways, so far we have
these two instructions:</p>
<ul>
<li><em>instr_R(a1):</em> returns with <em>a1</em></li>
<li><em>instr_C(a1):</em> writes <em>a1</em> to <em>sym.written_by_instr_C</em></li>
</ul>
<p>And we also know that these accept one argument,</p>
<ul>
<li>instr_I</li>
<li>instr_D</li>
<li>instr_P</li>
<li>instr_X</li>
<li>instr_J</li>
</ul>
<p>and these accept two:</p>
<ul>
<li>instr_A</li>
<li>instr_S</li>
</ul>
<p>What remains is the reversing of the seven functions that are called by the
instructions, and finally the construction of a valid bytecode that gives us the
flag.</p>
<p>###instr_A</p>
<p>The function this instruction calls is at offset 0x40080d, so lets seek there!</p>
<pre><code>[offset]&gt; 0x40080d
</code></pre>
<blockquote>
<p><em><strong>rizin tip:</strong></em> In visual mode you can just hit &lt;Enter&gt; when the current line is
a jump or a call, and rizin will seek to the destination address.</p>
</blockquote>
<p>If we seek to that address from the graph mode, we are presented with a message
that says &quot;Not in a function. Type 'df' to define it here. This is because the
function is called from a basic block rizin did not recognize, so rizin could not
find the function either. Lets obey, and type <em>df</em>! A function is indeed created, but
we want some meaningful name for it. So press <em>dr</em> while still in visual mode,
and name this function <em>instr_A</em>!</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/instr_A_minimap.png" alt="instr_A minimap" /></p>
<blockquote>
<p><em><strong>rizin tip:</strong></em> You should realize that these commands are all part of the same
menu system in visual mode I was talking about when we first used <em>Cd</em> to
declare <em>sym.memory</em> as data.</p>
</blockquote>
<p>Ok, now we have our shiny new <em>fcn.instr_A</em>, lets reverse it! We can see from
the shape of the minimap that probably there is some kind cascading
if-then-elif, or a switch-case statement involved in this function. This is one
of the reasons the minimap is so useful: you can recognize some patterns at a
glance, which can help you in your analysis (remember the easily recognizable
for loop from a few paragraphs before?) So, the minimap is cool and useful, but
I've just realized that I did not yet show you the full graph mode, so I'm
going to do this using full graph. The first basic blocks:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/bb-080d.png" alt="instr_A bb-080d" /></p>
<p>The two function arguments (<em>rdi</em> and <em>rsi</em>) are stored in local variables, and
the first is compared to 0. If it is, the function returns (you can see it on
the minimap), otherwise the same check is executed on the second argument. The
function returns from here too, if the argument is zero. Although this function
is really tiny, I am going to stick with my methodology, and rename the local
vars:</p>
<pre><code>:&gt; afvn local_1 arg1
:&gt; afvn local_2 arg2
</code></pre>
<p>And we have arrived to the predicted switch-case statement, and we can see that
<em>arg1</em>'s value is checked against &quot;M&quot;, &quot;P&quot;, and &quot;C&quot;.</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/switch-values.png" alt="instr_A switch values" /></p>
<p>This is the &quot;M&quot; branch:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/switch-M.png" alt="instr_A switch-M" /></p>
<p>It basically loads an address from offset 0x602088 and adds <em>arg2</em> to the byte
at that address. As rizin kindly shows us in a comment, 0x602088 initially holds
the address of <em>sym.memory</em>, the area where we have to construct the &quot;Such VM!
MuCH reV3rse!&quot; string. It is safe to assume that somehow we will be able to
modify the value stored at 0x602088, so this &quot;M&quot; branch will be able to modify
bytes other than the first. Based on this assumption, I'll flag 0x602088 as
<em>sym.current_memory_ptr</em>:</p>
<pre><code>:&gt; f sym.current_memory_ptr 8 @ 0x602088
</code></pre>
<p>Moving on to the &quot;P&quot; branch:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/switch-P.png" alt="instr_A switch-P" /></p>
<p>Yes, this is the piece of code that allows us to modify
<em>sym.current_memory_ptr</em>: it adds <em>arg2</em> to it.</p>
<p>Finally, the &quot;C&quot; branch:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/switch-C.png" alt="instr_A switch-C" /></p>
<p>Well, it turned out that <em>instr_C</em> is not the only instruction that modifies 
<em>sym.written_by_instr_C</em>: this piece of code adds <em>arg2</em> to it.</p>
<p>And that was <em>instr_A</em>, lets summarize it! Depending on the first argument, this
instruction does the following:</p>
<ul>
<li><em>arg1</em> == &quot;M&quot;: adds <em>arg2</em> to the byte at <em>sym.current_memory_ptr</em>.</li>
<li><em>arg1</em> == &quot;P&quot;: steps <em>sym.current_memory_ptr</em> by <em>arg2</em> bytes.</li>
<li><em>arg1</em> == &quot;C&quot;: adds <em>arg2</em> to the value at <em>sym.written_by_instr_C</em>.</li>
</ul>
<p>###instr_S</p>
<p>This function is not recognized either, so we have to manually define it like we
did with <em>instr_A</em>. After we do, and take a look at the minimap, scroll through
the basic blocks, it is pretty obvious that these two functions are very-very
similar. We can use <em>rz-diff</em> to see the difference.</p>
<blockquote>
<p><em><strong>rizin tip:</strong></em> rz-diff is used to compare binary files. There's a few options
we can control the type of binary diffing the tool does, and to what kind of
output format we want. One of the cool features is that it can generate
<a href="http://www.darungrim.org/">DarumGrim</a>-style bindiff graphs using the <em>-g</em>
option.</p>
</blockquote>
<p>Since now we want to diff two functions from the same binary, we specify the
offsets with <em>-g</em>, and use reverse4 for both binaries. Also, we create the
graphs for comparing <em>instr_A</em> to <em>instr_S</em> and for comparing <em>instr_S</em> to
<em>instr_A</em>.</p>
<pre><code>[0x00 ~]$ rz-diff -g 0x40080d,0x40089f  reverse4 reverse4 | xdot -
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_S/graph1.png" alt="instr_S graph1" /></p>
<pre><code>[0x00 ~]$ rz-diff -g 0x40089f,0x40080d  reverse4 reverse4 | xdot -
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_S/graph2.png" alt="instr_S graph2" /></p>
<p>A sad truth reveals itself after a quick glance at these graphs: rz-diff is a
liar! In theory, grey boxes should be identical, yellow ones should differ only
at some offsets, and red ones should differ seriously. Well this is obviously
not the case here - e.g. the larger grey boxes are clearly not identical. This
is something I'm definitely going to take a deeper look at after I've finished
this writeup.</p>
<p>Anyways, after we get over the shock of being lied to, we can easily recognize
that <em>instr_S</em> is basically a reverse-<em>instr_A</em>: where the latter does addition,
the former does subtraction. To summarize this:</p>
<ul>
<li><em>arg1</em> == &quot;M&quot;: subtracts <em>arg2</em> from the byte at <em>sym.current_memory_ptr</em>.</li>
<li><em>arg1</em> == &quot;P&quot;: steps <em>sym.current_memory_ptr</em> backwards by <em>arg2</em> bytes.</li>
<li><em>arg1</em> == &quot;C&quot;: subtracts <em>arg2</em> from the value at <em>sym.written_by_instr_C</em>.</li>
</ul>
<p>###instr_I</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_I/instr_I.png" alt="instr_I" /></p>
<p>This one is simple, it just calls <em>instr_A(arg1, 1)</em>. As you may have noticed
the function call looks like <code>call fcn.0040080d</code> instead of <code>call fcn.instr_A</code>.
This is because when you save and open a project, function names get lost -
another thing to examine and patch in rizin!</p>
<p>###instr_D</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_D/instr_D.png" alt="instr_D" /></p>
<p>Again, simple: it calls <em>instr_S(arg1, 1)</em>.</p>
<p>###instr_P</p>
<p>It's local var rename time again!</p>
<pre><code>:&gt; afvn local_0_1 const_M
:&gt; afvn local_0_2 const_P
:&gt; afvn local_3 arg1
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_P/instr_P.png" alt="instr_P" /></p>
<p>This function is pretty straightforward also, but there is one oddity: const_M
is never used. I don't know why it is there - maybe it is supposed to be some
kind of distraction? Anyways, this function simply writes <em>arg1</em> to
<em>sym.current_memory_ptr</em>, and than calls <em>instr_I(&quot;P&quot;)</em>. This basically means
that <em>instr_P</em> is used to write one byte, and put the pointer to the next byte.
So far this would seem the ideal instruction to construct most of the &quot;Such VM!
MuCH reV3rse!&quot; string, but remember, this is also the one that can be used only
9 times!</p>
<p>###instr_X</p>
<p>Another simple one, rename local vars anyways!</p>
<pre><code>:&gt; afvn local_1 arg1
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_X/instr_X.png" alt="instr_X" /></p>
<p>This function XORs the value at <em>sym.current_memory_ptr</em> with <em>arg1</em>.</p>
<p>###instr_J</p>
<p>This one is not as simple as the previous ones, but it's not that complicated
either. Since I'm obviously obsessed with variable renaming:</p>
<pre><code>:&gt; afvn local_3 arg1
:&gt; afvn local_0_4 arg1_and_0x3f
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/instr_J.png" alt="instr_J" /></p>
<p>After the result of <em>arg1 &amp; 0x3f</em> is put into a local variable, <em>arg1 &amp; 0x40</em> is
checked against 0. If it isn't zero, <em>arg1_and_0x3f</em> is negated:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09e1.png" alt="instr_J bb-09e1" /></p>
<p>The next branching: if <em>arg1</em> &gt;= 0, then the function returns <em>arg1_and_0x3f</em>,</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09e4.png" alt="instr_J bb-09e4" /></p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-0a1a.png" alt="instr_J bb-0a1a" /></p>
<p>else the function branches again, based on the value of
<em>sym.written_by_instr_C</em>:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09ef.png" alt="instr_J bb-09ef" /></p>
<p>If it is zero, the function returns 2,</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-0a13.png" alt="instr_J bb-0a13" /></p>
<p>else it is checked if <em>arg1_and_0x3f</em> is a negative number,</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09f9.png" alt="instr_J bb-09f9" /></p>
<p>and if it is, <em>sym.good_if_ne_zero</em> is incremented by 1:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09ff.png" alt="instr_J bb-09ff" /></p>
<p>After all this, the function returns with <em>arg1_and_0x3f</em>:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-0a0e.png" alt="instr_J bb-0a0e" /></p>
<h2 id="instructionset"><a class="header" href="#instructionset">.instructionset</a></h2>
<p>We've now reversed all the VM instructions, and have a full understanding about
how it works. Here is the VM's instruction set:</p>
<table><thead><tr><th>Instruction</th><th>1st arg</th><th>2nd arg</th><th>What does it do?</th></tr></thead><tbody>
<tr><td>&quot;A&quot;</td><td>&quot;M&quot;</td><td>arg2</td><td>*sym.current_memory_ptr += arg2</td></tr>
<tr><td></td><td>&quot;P&quot;</td><td>arg2</td><td>sym.current_memory_ptr += arg2</td></tr>
<tr><td></td><td>&quot;C&quot;</td><td>arg2</td><td>sym.written_by_instr_C += arg2</td></tr>
<tr><td>&quot;S&quot;</td><td>&quot;M&quot;</td><td>arg2</td><td>*sym.current_memory_ptr -= arg2</td></tr>
<tr><td></td><td>&quot;P&quot;</td><td>arg2</td><td>sym.current_memory_ptr -= arg2</td></tr>
<tr><td></td><td>&quot;C&quot;</td><td>arg2</td><td>sym.written_by_instr_C -= arg2</td></tr>
<tr><td>&quot;I&quot;</td><td>arg1</td><td>n/a</td><td>instr_A(arg1, 1)</td></tr>
<tr><td>&quot;D&quot;</td><td>arg1</td><td>n/a</td><td>instr_S(arg1, 1)</td></tr>
<tr><td>&quot;P&quot;</td><td>arg1</td><td>n/a</td><td>*sym.current_memory_ptr = arg1; instr_I(&quot;P&quot;)</td></tr>
<tr><td>&quot;X&quot;</td><td>arg1</td><td>n/a</td><td>*sym.current_memory_ptr ^= arg1</td></tr>
<tr><td>&quot;J&quot;</td><td>arg1</td><td>n/a</td><td>arg1_and_0x3f = arg1 &amp; 0x3f;<br>if (arg1 &amp; 0x40 != 0)<br>  arg1_and_0x3f *= -1<br>if (arg1 &gt;= 0) return arg1_and_0x3f;<br>else if (*sym.written_by_instr_C != 0) {<br>  if (arg1_and_0x3f &lt; 0)<br>    ++*sym.good_if_ne_zero;<br>  return arg1_and_0x3f;<br>} else return 2;</td></tr>
<tr><td>&quot;C&quot;</td><td>arg1</td><td>n/a</td><td>*sym.written_by_instr_C = arg1</td></tr>
<tr><td>&quot;R&quot;</td><td>arg1</td><td>n/a</td><td>return(arg1)</td></tr>
</tbody></table>
<h2 id="bytecode"><a class="header" href="#bytecode">.bytecode</a></h2>
<p>Well, we did the reverse engineering part, now we have to write a program for
the VM with the instruction set described in the previous paragraph. Here is
the program's functional specification:</p>
<ul>
<li>the program must return &quot;*&quot;</li>
<li><em>sym.memory</em> has to contain the string &quot;Such VM! MuCH reV3rse!&quot; after
execution</li>
<li>all 9 instructions have to be used at least once</li>
<li><em>sym.good_if_ne_zero</em> should not be zero</li>
<li>instr_P is not allowed to be used more than 9 times</li>
</ul>
<p>Since this document is about reversing, I'll leave the programming part to the
fellow reader :) But I'm not going to leave you empty-handed, I'll give you one
advice: Except for &quot;J&quot;, all of the instructions are simple, easy to use, and it
should not be a problem to construct the &quot;Such VM! MuCH reV3rse!&quot; using them.
&quot;J&quot; however is a bit complicated compared to the others. One should realize that
its sole purpose is to make <em>sym.good_if_ne_zero</em> bigger than zero, which is a
requirement to access the flag. In order to increment <em>sym.good_if_ne_zero</em>,
three conditions should be met:</p>
<ul>
<li><em>arg1</em> should be a negative number, otherwise we would return early</li>
<li><em>sym.written_by_instr_C</em> should not be 0 when &quot;J&quot; is called. This means that
&quot;C&quot;, &quot;AC&quot;, or &quot;SC&quot; instructions should be used before calling &quot;J&quot;.</li>
<li><em>arg1_and_0x3f</em> should be negative when checked. Since 0x3f's sign bit is
zero, no matter what <em>arg1</em> is, the result of <em>arg1</em> &amp; 0x3f will always be
non-negative. But remember that &quot;J&quot; negates <em>arg1_and_0x3f</em> if <em>arg1</em> &amp; 0x40
is not zero. This basically means that <em>arg1</em>'s 6th bit should be 1
(0x40 = 01000000b). Also, because <em>arg1_and_0x3f</em> can't be 0 either, at least
one of <em>arg1</em>'s 0th, 1st, 2nd, 3rd, 4th or 5th bits should be 1 (0x3f =
00111111b).</li>
</ul>
<p>I think this is enough information, you can go now and write that program. Or,
you could just reverse engineer the quick'n'dirty one I've used during the CTF:</p>
<pre><code>\x90\x00PSAMuAP\x01AMcAP\x01AMhAP\x01AM AP\x01AMVAP\x01AMMAP\x01AM!AP\x01AM AP\x01AMMAP\x01AMuAP\x01AMCAP\x01AMHAP\x01AM AP\x01AMrAP\x01AMeAP\x01AMVAP\x01AM3AP\x01AMrAP\x01AMsAP\x01AMeIPAM!X\x00CAJ\xc1SC\x00DCR*
</code></pre>
<p>Keep in mind though, that it was written on-the-fly, parallel to the reversing
phase - for example there are parts that was written without the knowledge of
all possible instructions. This means that the code is ugly and inefficient.</p>
<h2 id="outro"><a class="header" href="#outro">.outro</a></h2>
<p>Well, what can I say? Such VM, much reverse! :)</p>
<p>What started out as a simple writeup for a simple crackme, became a rather
lengthy writeup/rizin tutorial, so kudos if you've read through it. I hope you
enjoyed it (I know I did), and maybe even learnt something from it. I've surely
learnt a lot about rizin during the process, and I've even contributed some small
patches, and got a few ideas of more possible improvements.</p>
<h1 id="hackthebox"><a class="header" href="#hackthebox">hackthebox</a></h1>
<p>The well-known <em>hack the box</em> hacking training platform offers reversing challenges.</p>
<p>We talk about of retired one solved with Rizin.</p>
<h1 id="find-the-easy-pass"><a class="header" href="#find-the-easy-pass">Find The Easy Pass</a></h1>
<p>This challenge implies to find the right password to win some points.</p>
<p>We present you a methodology to solve it with Rizin in particular by
its built-in debugger on the Windows operating system.</p>
<h1 id="identification"><a class="header" href="#identification">identification</a></h1>
<p>After un-compressing  the challenge file <code>Find The Easy Pass.zip</code>, we can find
a file named <code>EasyPass.exe</code> inside it.</p>
<p>We using <code>rz-bin</code> to identify the executable file.</p>
<pre><code class="language-bash">C:\Users\User\Desktop\htb&gt;rz-bin -I EasyPass.exe
arch     x86
baddr    0x400000
binsz    402432
bintype  pe
bits     32
canary   false
retguard false
class    PE32
cmp.csum 0x00063785
compiled Fri Jun 19 15:22:17 1992
crypto   false
endian   little
havecode true
hdr.csum 0x00000000
laddr    0x0
lang     c
linenum  true
lsyms    true
machine  i386
maxopsz  16
minopsz  1
nx       false
os       windows
overlay  false
cc       cdecl
pcalign  0
pic      false
relocs   false
signed   false
sanitiz  false
static   false
stripped false
subsys   Windows GUI
va       true
</code></pre>
<p>That's interesting, <code>EasyPass.exe</code> is an x86 program, it's a GUI program.</p>
<p>Now, we will run the program to have some better idea on what it's doing.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/identification-00.png" alt="identification-run-program" /></p>
<p>We click on the <strong>Check Password</strong></p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/identification-01.png" alt="identification-error-message-printed" /></p>
<p>Interesting, let's search for <strong>Wrong Password!</strong> in the executable.</p>
<pre><code class="language-bash">C:\Users\User\Desktop\htb&gt;rz-bin -iz EasyPass.exe | findstr /I Wrong

C:\Users\User\Desktop\htb&gt;
</code></pre>
<p>We're unlucky but don't panic, we will launch a more thorough research:</p>
<pre><code class="language-bash">C:\Users\User\Desktop\htb&gt;rz-bin -izz EasyPass.exe | findstr /I Wrong
5483 0x00053600 0x00454200 15  16   CODE    ascii   Wrong Password!
</code></pre>
<p>The &quot;Wrong Password!&quot; string is located at <strong><code>0x00454200</code></strong> in the CODE section.</p>
<blockquote>
<p><em><strong>rizin tips:</strong></em> The first search (<code>-iz</code>) works on some flag spaces but
not on the whole file, while the second command (<code>-izz</code>) is more exhaustive.</p>
</blockquote>
<h1 id="find-the-validation-routine"><a class="header" href="#find-the-validation-routine">Find the validation routine</a></h1>
<p>The string &quot;Wrong Password!&quot; is located at <code>0x00454200</code> in the CODE section.</p>
<p>In this step, we wish to find the password, our approach will be to debug
the program based on the information already collected.</p>
<pre><code class="language-bash">Spawned new process with pid 8556, tid = 8576
= attach 8556 8576
bin.baddr 0x00400000
Using 0x400000
asm.bits 32
</code></pre>
<blockquote>
<pre><code class="language-bash">[0x7ffeaa1c2630]&gt; iz~Wrong
[0x7ffeaa1c2630]&gt; izz~Wrong
5483 0x00053600 0x00454200 15  16   CODE    ascii   Wrong Password!
</code></pre>
<p><em><strong>rizin tips:</strong></em> We know where is located the &quot;Wrong Password!&quot; at
<code>0x00454200</code> in the CODE section.
To do the same research, we can use the <code>iz</code> and <code>izz</code></p>
</blockquote>
<p><code>~</code> is Rizin's built-in <code>grep</code> command which you can use to filter the
output.
Here, we've searched for the word &quot;Wrong&quot; in the strings of the data
section.</p>
<p>Seeking to <code>0x00454200</code>- the location of the string:</p>
<pre><code class="language-bash">[0x7ffeaa1c2630]&gt; s 0x00454200

[0x00454200]&gt; aaaa
</code></pre>
<p>We will ask Rizin to analyze the program with <code>aaa</code>.</p>
<pre><code class="language-bash">[0x00454200]&gt; aaaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[Warning: Invalid range. Use different search.in=? or analysis.in=dbg.maps.x
Warning: Invalid range. Use different search.in=? or analysis.in=dbg.maps.x
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Check for classes
[TOFIX: aaft can't run in debugger mode.ions (aaft)
[x] Type matching analysis for all functions (aaft)
[x] Propagate noreturn information
[x] Use -AA or aaaa to perform additional experimental analysis.
[Warning: Invalid range. Use different search.in=? or analysis.in=dbg.maps.x
[x] Finding function preludes
[x] Enable constraint types analysis for variables
</code></pre>
<pre><code class="language-bash">[0x00454200]&gt; V
</code></pre>
<blockquote>
<p><em><strong>rizin tips:</strong></em> The <code>V</code> command triggers the visual mode.</p>
</blockquote>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-00.png" alt="find-the-validation-routine-wrong-password" /></p>
<p>Press <code>p</code> command to switch on the code view.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-01.png" alt="find-the-validation-routine-wrong-password-code-view" /></p>
<p>Press <code>x</code> to display the cross-references.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-02.png" alt="find-the-validation-routine-wrong-password-xref" /></p>
<p>Press <code>enter</code> or <code>return</code> to jump of this reference.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-03.png" alt="find-the-validation-routine-wrong-password-jump-to-xref" /></p>
<p>Rizin allows you to have a graph view by pressing the <code>space bar</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-04.png" alt="find-the-validation-routine-wrong-password-graph-view-not-work" /></p>
<p>For the graph view to work here, Rizin needs the function to be analyzed.
We will help by creating it from the beginning of the function
where the string &quot;Wrong Password!&quot; is located.</p>
<p>Scroll up to the address <code>0x00454078</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-05.png" alt="find-the-validation-routine-wrong-password-prologue-function" /></p>
<p>Press <code>d</code> and <code>f</code> to analyze the function.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-06.png" alt="find-the-validation-routine-wrong-password-analyze-function" /></p>
<p>Now if you press the <code>space bar</code> the graph will be displayed.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-07.png" alt="find-the-validation-routine-wrong-password-graph-view" /></p>
<blockquote>
<p><em><strong>rizin tips:</strong></em> to move around of graph, you can use the same keys like Vim:
<code>h</code>, <code>j</code>, <code>k</code>, <code>l</code>.</p>
</blockquote>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-08.png" alt="find-the-validation-routine-wrong-password-interesting-code" /></p>
<p>By deduction, the address <code>0x00427a30</code> is the function which popup the messagebox.</p>
<p>The right node, print the &quot;Wrong Password!&quot;, the left one, probably prints the congratulations message.</p>
<p>At <code>0x00404628</code> is what which looks like a validation function because it is
followed by a conditional test that either leads to the &quot;Wrong Password!&quot; message
or the congratulation message.</p>
<p>Press <code>g</code> and enter the address <code>0x004041dc</code> to check if this one is the
congratulation message.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-09.png" alt="find-the-validation-routine-wrong-jump-to-congrats" /></p>
<p>Press <code>n</code> to ignore the create function message and press <code>P</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-10.png" alt="find-the-validation-routine-congrats" /></p>
<p>Press <code>x</code> and <code>p</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-11.png" alt="find-the-validation-routine-congrats-node" /></p>
<p>Press <code>;</code> to enter a comment:</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-12.png" alt="find-the-validation-routine-congrats-node-comment" /></p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-13.png" alt="find-the-validation-routine-congrats-node-comment-1" /></p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-14.png" alt="find-the-validation-routine-breakpoint-to-fish-code" /></p>
<h1 id="fire-up-the-debugger"><a class="header" href="#fire-up-the-debugger">Fire up the debugger</a></h1>
<p>The next step will be to put a breakpoint at <code>0x0045412b</code>,
this address contains probably the right password or our.
Press <code>F2</code> key to put a breakpoint.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/find-the-validation_routine-15.png" alt="find-the-validation-routine-breakpoint-to-fish-code-1" /></p>
<p>Press <code>:</code> , <code>d</code> and <code>c</code> to run <code>EasyPass.exe</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-01.png" alt="run-the-program-debugged-1" /></p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-02.png" alt="run-the-program-debugged-2" /></p>
<p>Press <code>:</code> , <code>d</code> and <code>c</code> or <code>F9</code> key.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-03.png" alt="run-the-program-debugged-3" /></p>
<p>Press <code>:</code> , <code>d</code> and <code>c</code> or <code>F9</code> key.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-04.png" alt="run-the-program-debugged-4" /></p>
<p>The program is launched.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-05.png" alt="run-the-program-debugged-5" /></p>
<p>Enter a placeholder text and click on the &quot;Check Password&quot; button.</p>
<p>Logically, the program should stop at our breakpoint point.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-06.png" alt="run-the-program-debugged-6" /></p>
<p>Press <code>q</code> and then <code>p</code> to show the debugger view panel.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-07.png" alt="run-the-program-debugged-7" /></p>
<p>Press <code>F8</code> key to step over.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-08.png" alt="run-the-program-debugged-8" /></p>
<p>Press <code>g</code>, enter <code>eax</code> and <code>P</code> twice.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-09.png" alt="run-the-program-debugged-9" /></p>
<p>That's great our placeholder text is in memory.</p>
<p>Press <code>p</code> twice, <code>g</code> and enter <code>rip</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-10.png" alt="run-the-program-debugged-10" /></p>
<p>Press <code>F8</code> key.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-11.png" alt="run-the-program-debugged-11" /></p>
<p>Press <code>g</code>, enter <code>edx</code> and <code>P</code> twice.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-12.png" alt="run-the-program-debugged-12" /></p>
<p>The right password seems to be <strong>fortan!</strong>.</p>
<p>Press <code>p</code> twice, <code>g</code> and enter <code>rip</code>.</p>
<p>Press <code>F8</code> key twice.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-13.png" alt="run-the-program-debugged-13" /></p>
<p>The call at <code>0x0045413d</code> seems to compare the previous password and 
when unequal, the program jumps to the &quot;Wrong Pasword!&quot; message.</p>
<p>Press <code>F9</code> key to show the message box.</p>
<p>After that, enter &quot;fortan!&quot; string and repeat the previous step until
the address <code>0x0045413d</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-14.png" alt="run-the-program-debugged-14" /></p>
<p>Press <code>F8</code>key twice.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-15.png" alt="run-the-program-debugged-15" /></p>
<p>It seems all right! Press <code>F9</code> key to confirm this fact.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/fire-up-the-debugger-16.png" alt="run-the-program-debugged-16" /></p>
<h1 id="bonus"><a class="header" href="#bonus">Bonus</a></h1>
<p>In the previous pages, we found out the the right password.
Now, we can figure out whether it is calculated at runtime or
hard-coded into the binary.</p>
<p>To do this, we will look at what happens from the
beginning of the current function from the
address <code>0x00454084</code>.</p>
<p>As a first, we'll go to the address <code>0x00454084</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/bonus-01.png" alt="bonus-01" /></p>
<p>Take a break and observe the assembly code.
You will see a repeating code sequence :</p>
<pre><code class="language-assembly">mov eax, [ebp - X] ; or X is between 0x8 and 0x24
mov edx, Y ; or Y is between 0x00454188  and 0x004541d0
</code></pre>
<p>Look the address <code>0x00454188</code>.</p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/bonus-02.png" alt="bonus-02" /></p>
<p><img src="crackmes/hackthebox/find-the-easy-pass/./img/bonus-03.png" alt="bonus-03" /></p>
<p>Pay attention to the previous picture. You can see the password
broken down letter by letter.</p>
<p>We can see that the routine is concatenating each letter into a string and compares
it to a user input.</p>
<h1 id="rizin-reference-card"><a class="header" href="#rizin-reference-card">Rizin Reference Card</a></h1>
<p>This chapter is based on the Radare 2 reference card by Thanat0s, which is under the GNU GPL. Original license is as follows:</p>
<pre><code>This card may be freely distributed under the terms of the GNU
general public licence — Copyright by Thanat0s - v0.1 -
</code></pre>
<h2 id="survival-guide"><a class="header" href="#survival-guide">Survival Guide</a></h2>
<p>Those are the basic commands you will want to know and use for moving
around a binary and getting information about it.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">s (tab)</td><td align="left">Seek to a different place</td></tr>
<tr><td align="left">x [nbytes]</td><td align="left">Hexdump of nbytes, $b by default</td></tr>
<tr><td align="left">aa</td><td align="left">Auto analyze</td></tr>
<tr><td align="left">pdf@ <a href="refcard/Tab">funcname</a></td><td align="left">Disassemble function (main, fcn, etc.)</td></tr>
<tr><td align="left">f fcn(Tab)</td><td align="left">List functions</td></tr>
<tr><td align="left">f str(Tab)</td><td align="left">List strings</td></tr>
<tr><td align="left">fr [flagname] [newname]</td><td align="left">Rename flag</td></tr>
<tr><td align="left">psz [offset]~grep</td><td align="left">Print strings and grep for one</td></tr>
<tr><td align="left">axF [flag]</td><td align="left">Find cross reference for a flag</td></tr>
</tbody></table>
<h2 id="flags-1"><a class="header" href="#flags-1">Flags</a></h2>
<p>Flags are like bookmarks, but they carry some extra information like size, tags or associated flagspace. Use the <code>f</code> command to list, set, get them.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">f</td><td align="left">List flags</td></tr>
<tr><td align="left">fd $$</td><td align="left">Describe an offset</td></tr>
<tr><td align="left">fj</td><td align="left">Display flags in JSON</td></tr>
<tr><td align="left">fl</td><td align="left">Show flag length</td></tr>
<tr><td align="left">fx [flagname]</td><td align="left">Show hexdump of flag</td></tr>
<tr><td align="left">fC [name] [comment]</td><td align="left">Set flag comment</td></tr>
</tbody></table>
<h2 id="flagspaces"><a class="header" href="#flagspaces">Flagspaces</a></h2>
<p>Flags are created into a flagspace, by default none is selected,
and listing flags will list them all. To display a subset of flags
you can use the <code>fs</code> command to restrict it.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">fs</td><td align="left">Display flagspaces</td></tr>
<tr><td align="left">fs *</td><td align="left">Select all flagspaces</td></tr>
<tr><td align="left">fs [space]</td><td align="left">Select one flagspace</td></tr>
</tbody></table>
<h2 id="information"><a class="header" href="#information">Information</a></h2>
<p>Binary files have information stored inside the headers. The <code>i</code>
command uses the RzBin api and allows us to the same things rz-bin
do. Those are the most common ones.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">ii</td><td align="left">Information on imports</td></tr>
<tr><td align="left">iI</td><td align="left">Info on binary</td></tr>
<tr><td align="left">ie</td><td align="left">Display entrypoint</td></tr>
<tr><td align="left">iS</td><td align="left">Display sections</td></tr>
<tr><td align="left">ir</td><td align="left">Display relocations</td></tr>
<tr><td align="left">iz</td><td align="left">List strings (izz, izzz)</td></tr>
</tbody></table>
<h2 id="print-string"><a class="header" href="#print-string">Print string</a></h2>
<p>There are different ways to represent a string in memory. The <code>ps</code> command
allows us to print it in utf-16, pascal, zero terminated, .. formats.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">psz [offset]</td><td align="left">Print zero terminated string</td></tr>
<tr><td align="left">psb [offset]</td><td align="left">Print strings in current block</td></tr>
<tr><td align="left">psx [offset]</td><td align="left">Show string with scaped chars</td></tr>
<tr><td align="left">psp [offset]</td><td align="left">Print pascal string</td></tr>
<tr><td align="left">psw [offset]</td><td align="left">Print wide string</td></tr>
</tbody></table>
<h2 id="visual-mode-2"><a class="header" href="#visual-mode-2">Visual mode</a></h2>
<p>The visual mode is the standard interactive interface of rizin.</p>
<p>To enter in visual mode use the <code>v</code> or <code>V</code> command, and then you'll only
have to press keys to get the actions happen instead of commands.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">V</td><td align="left">Enter visual mode</td></tr>
<tr><td align="left">p/P</td><td align="left">Rotate modes (hex, disasm, debug, words, buf)</td></tr>
<tr><td align="left">c</td><td align="left">Toggle (c)ursor</td></tr>
<tr><td align="left">q</td><td align="left">Back to rizin shell</td></tr>
<tr><td align="left">hjkl</td><td align="left">Move around (or HJKL) (left-down-up-right)</td></tr>
<tr><td align="left">Enter</td><td align="left">Follow address of jump/call</td></tr>
<tr><td align="left">sS</td><td align="left">Step/step over</td></tr>
<tr><td align="left">o</td><td align="left">Toggle asm.pseudo and asm.esil</td></tr>
<tr><td align="left">.</td><td align="left">Seek to program counter</td></tr>
<tr><td align="left">/</td><td align="left">In cursor mode, search in current block</td></tr>
<tr><td align="left">:cmd</td><td align="left">Run rizin command</td></tr>
<tr><td align="left">;[-]cmt</td><td align="left">Add/remove comment</td></tr>
<tr><td align="left">/*+-[]</td><td align="left">Change block size, [] = resize hex.cols</td></tr>
<tr><td align="left">&lt;,&gt;</td><td align="left">Seek aligned to block size</td></tr>
<tr><td align="left">i/a/A</td><td align="left">(i)nsert hex, (a)ssemble code, visual (A)ssembler</td></tr>
<tr><td align="left">b</td><td align="left">Toggle breakpoint</td></tr>
<tr><td align="left">B</td><td align="left">Browse evals, symbols, flags, classes, ...</td></tr>
<tr><td align="left">d[f?]</td><td align="left">Define function, data, code, ..</td></tr>
<tr><td align="left">D</td><td align="left">Enter visual diff mode (set diff.from/to)</td></tr>
<tr><td align="left">e</td><td align="left">Edit eval configuration variables</td></tr>
<tr><td align="left">f/F</td><td align="left">Set/unset flag</td></tr>
<tr><td align="left">gG</td><td align="left">Go seek to begin and end of file (0-$s)</td></tr>
<tr><td align="left">mK/’K</td><td align="left">Mark/go to Key (any key)</td></tr>
<tr><td align="left">n/N</td><td align="left">Seek next/prev function/flag/hit (scr.nkey)</td></tr>
<tr><td align="left">C</td><td align="left">Toggle (C)olors</td></tr>
<tr><td align="left">R</td><td align="left">Randomize color palette (ecr)</td></tr>
<tr><td align="left">tT</td><td align="left">Tab related. see also <a href="refcard/visual_panels.html">tab</a></td></tr>
<tr><td align="left">v</td><td align="left">Visual code analysis menu</td></tr>
<tr><td align="left">V</td><td align="left">(V)iew graph (agv?)</td></tr>
<tr><td align="left">wW</td><td align="left">Seek cursor to next/prev word</td></tr>
<tr><td align="left">uU</td><td align="left">Undo/redo seek</td></tr>
<tr><td align="left">x</td><td align="left">Show xrefs of current func from/to data/code</td></tr>
<tr><td align="left">yY</td><td align="left">Copy and paste selection</td></tr>
<tr><td align="left">z</td><td align="left">fold/unfold comments in disassembly</td></tr>
</tbody></table>
<h2 id="searching"><a class="header" href="#searching">Searching</a></h2>
<p>There are many situations where we need to find a value inside a binary
or in some specific regions. Use the <code>e search.in=?</code> command to choose
where the <code>/</code> command may search for the given value.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">/ foo\00</td><td align="left">Search for string ’foo\0’</td></tr>
<tr><td align="left">/b</td><td align="left">Search backwards</td></tr>
<tr><td align="left">//</td><td align="left">Repeat last search</td></tr>
<tr><td align="left">/w foo</td><td align="left">Search for wide string ’f\0o\0o\0’</td></tr>
<tr><td align="left">/wi foo</td><td align="left">Search for wide string ignoring case</td></tr>
<tr><td align="left">/! ff</td><td align="left">Search for first occurrence not matching</td></tr>
<tr><td align="left">/i foo</td><td align="left">Search for string ’foo’ ignoring case</td></tr>
<tr><td align="left">/e /E.F/i</td><td align="left">Match regular expression</td></tr>
<tr><td align="left">/x a1b2c3</td><td align="left">Search for bytes; spaces and uppercase nibbles are allowed, same as /x A1 B2 C3</td></tr>
<tr><td align="left">/x a1..c3</td><td align="left">Search for bytes ignoring some nibbles (auto-generates mask, in this example: ff00ff)</td></tr>
<tr><td align="left">/x a1b2:fff3</td><td align="left">Search for bytes with mask (specify individual bits)</td></tr>
<tr><td align="left">/d 101112</td><td align="left">Search for a deltified sequence of bytes</td></tr>
<tr><td align="left">/!x 00</td><td align="left">Inverse hexa search (find first byte != 0x00)</td></tr>
<tr><td align="left">/c jmp [esp]</td><td align="left">Search for asm code (see search.asmstr)</td></tr>
<tr><td align="left">/a jmp eax</td><td align="left">Assemble opcode and search its bytes</td></tr>
<tr><td align="left">/A</td><td align="left">Search for AES expanded keys</td></tr>
<tr><td align="left">/r sym.printf</td><td align="left">Analyze opcode reference an offset</td></tr>
<tr><td align="left">/R</td><td align="left">Search for ROP gadgets</td></tr>
<tr><td align="left">/P</td><td align="left">Show offset of previous instruction</td></tr>
<tr><td align="left">/m magicfile</td><td align="left">Search for matching magic file</td></tr>
<tr><td align="left">/p patternsize</td><td align="left">Search for pattern of given size</td></tr>
<tr><td align="left">/z min max</td><td align="left">Search for strings of given size</td></tr>
<tr><td align="left">/v[?248] num</td><td align="left">Look for a asm.bigendian 32bit value</td></tr>
</tbody></table>
<h2 id="usable-variables-in-expression"><a class="header" href="#usable-variables-in-expression">Usable variables in expression</a></h2>
<p>The <code>?$?</code> command will display the variables that can be used in any math
operation inside the rizin shell. For example, using the <code>? $$</code> command to evaluate
a number or <code>?v</code> to just the value in one format.</p>
<p>All commands in rizin that accept a number supports the use of those variables.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">$$</td><td align="left">here (current virtual seek)</td></tr>
<tr><td align="left">$$$</td><td align="left">current non-temporary virtual seek</td></tr>
<tr><td align="left">$?</td><td align="left">last comparison value</td></tr>
<tr><td align="left">$alias=value</td><td align="left">alias commands (simple macros)</td></tr>
<tr><td align="left">$b</td><td align="left">block size</td></tr>
<tr><td align="left">$B</td><td align="left">base address (aligned lowest map address)</td></tr>
<tr><td align="left">$f</td><td align="left">jump fail address (e.g. jz 0x10 =&gt; next instruction)</td></tr>
<tr><td align="left">$fl</td><td align="left">flag length (size) at current address (fla; pD $l @ entry0)</td></tr>
<tr><td align="left">$F</td><td align="left">current function size</td></tr>
<tr><td align="left">$FB</td><td align="left">begin of function</td></tr>
<tr><td align="left">$Fb</td><td align="left">address of the current basic block</td></tr>
<tr><td align="left">$Fs</td><td align="left">size of the current basic block</td></tr>
<tr><td align="left">$FE</td><td align="left">end of function</td></tr>
<tr><td align="left">$FS</td><td align="left">function size</td></tr>
<tr><td align="left">$Fj</td><td align="left">function jump destination</td></tr>
<tr><td align="left">$Ff</td><td align="left">function false destination</td></tr>
<tr><td align="left">$FI</td><td align="left">function instructions</td></tr>
<tr><td align="left">$c,$r</td><td align="left">get width and height of terminal</td></tr>
<tr><td align="left">$Cn</td><td align="left">get nth call of function</td></tr>
<tr><td align="left">$Dn</td><td align="left">get nth data reference in function</td></tr>
<tr><td align="left">$D</td><td align="left">current debug map base address ?v $D @ rsp</td></tr>
<tr><td align="left">$DD</td><td align="left">current debug map size</td></tr>
<tr><td align="left">$e</td><td align="left">1 if end of block, else 0</td></tr>
<tr><td align="left">$j</td><td align="left">jump address (e.g. jmp 0x10, jz 0x10 =&gt; 0x10)</td></tr>
<tr><td align="left">$Ja</td><td align="left">get nth jump of function</td></tr>
<tr><td align="left">$Xn</td><td align="left">get nth xref of function</td></tr>
<tr><td align="left">$l</td><td align="left">opcode length</td></tr>
<tr><td align="left">$m</td><td align="left">opcode memory reference (e.g. mov eax,[0x10] =&gt; 0x10)</td></tr>
<tr><td align="left">$M</td><td align="left">map address (lowest map address)</td></tr>
<tr><td align="left">$o</td><td align="left">here (current disk io offset)</td></tr>
<tr><td align="left">$p</td><td align="left">getpid()</td></tr>
<tr><td align="left">$P</td><td align="left">pid of children (only in debug)</td></tr>
<tr><td align="left">$s</td><td align="left">file size</td></tr>
<tr><td align="left">$S</td><td align="left">section offset</td></tr>
<tr><td align="left">$SS</td><td align="left">section size</td></tr>
<tr><td align="left">$v</td><td align="left">opcode immediate value (e.g. lui a0,0x8010 =&gt; 0x8010)</td></tr>
<tr><td align="left">$w</td><td align="left">get word size, 4 if asm.bits=32, 8 if 64, ...</td></tr>
<tr><td align="left">${ev}</td><td align="left">get value of eval config variable</td></tr>
<tr><td align="left">$r{reg}</td><td align="left">get value of named register</td></tr>
<tr><td align="left">$k{kv}</td><td align="left">get value of an sdb query value</td></tr>
<tr><td align="left">$s{flag}</td><td align="left">get size of flag</td></tr>
<tr><td align="left">RzNum</td><td align="left">$variables usable in math expressions</td></tr>
</tbody></table>
<h2 id="authors--contributors"><a class="header" href="#authors--contributors">Authors &amp; Contributors</a></h2>
<p>This book wouldn't be possible without the help of a large list of contributors who have been reviewing, writing and reporting bugs and stuff in the rizin project as well as in this book.</p>
<h3 id="the-rizin-book"><a class="header" href="#the-rizin-book">The rizin book</a></h3>
<p>This book was started by maijin as a new version of the original radare1 book written by pancake. It was updated and reworked significantly for the radare2.
With the rizin fork the book has been reworked again.</p>
<ul>
<li>Old radare2 book <a href="https://book.rada.re">https://book.rada.re</a></li>
</ul>
<p>Many thanks to everyone who has been involved with the gitbook:</p>
<p>Adrian Studer,
Ahmed Mohamed Abd El-MAwgood,
Akshay Krishnan R,
Andrew Hoog,
Anton Kochkov,
Antonio Sánchez,
Austin Hartzheim,
Aswin C (officialcjunior),
Bob131,
DZ_ruyk,
David Tomaschik,
Eric,
Fangrui Song,
Francesco Tamagni,
FreeArtMan,
Gerardo García Peña,
Giuseppe,
Grigory Rechistov,
Hui Peng,
ITAYC0HEN,
Itay Cohen,
Jeffrey Crowell,
John,
Judge Dredd (key 6E23685A),
Jupiter,
Kevin Grandemange,
Kevin Laeufer,
Luca Di Bartolomeo,
Lukas Dresel,
Maijin,
Michael Scherer,
Mike,
Nikita Abdullin,
Paul,
Paweł Łukasik,
Peter C,
RandomLive,
Ren Kimura,
Reto Schneider,
SchumBlubBlub,
SkUaTeR,
Solomon,
Srimanta Barua,
Sushant Dinesh,
TDKPS,
Thanat0s,
Vanellope,
Vex Woo,
Vorlent,
XYlearn,
Yuri Slobodyanyuk,
ali,
aoighost,
condret,
hdznrrd,
izhuer,
jvoisin,
kij,
madblobfish,
muzlightbeer,
pancake,
polym (Tim),
puddl3glum,
rizin,
sghctoma,
shakreiner,
sivaramaaa,
taiyu,
vane11ope,
xarkes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
