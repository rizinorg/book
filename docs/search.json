[
  {
    "href": "index.html#welcome",
    "title": "The Official Rizin Book",
    "section": "Welcome",
    "text": "This is a book about Rizin reverse engineering framework and it’s originally based on the radare2 book\nCheck the Github site to add new contents or fix typos:\nGithub: https://github.com/rizinorg/book\nOnline: https://book.rizin.re/"
  },
  {
    "href": "index.html#offline",
    "title": "The Official Rizin Book",
    "section": "Offline",
    "text": "This book can be read offline by cloning the repository and by simply opening the HTML files."
  },
  {
    "href": "src/first_steps/overview.html",
    "title": "1  The Framework",
    "section": "",
    "text": "The Rizin project is a set of small command-line utilities that can be used together or independently.\nThis chapter will give you a quick understanding of them, but you can check the dedicated sections for each tool at the end of this book.\n\n1.0.1 rizin\nThe main tool of the whole framework. It uses the core of the hexadecimal editor and debugger. rizin allows you to open a number of input/output sources as if they were simple, plain files, including disks, network connections, kernel drivers, processes under debugging, and so on.\nIt implements an advanced command line interface for moving around a file, analyzing data, disassembling, binary patching, data comparison, searching, replacing, and visualizing. It can be scripted with a variety of languages, including Python, Haskell, OCaml, JavaScript, and others.\n\n\n1.0.2 rz-bin\nA program to extract information from executable binaries, such as ELF, PE, Java CLASS, Mach-O, plus any format supported by rizin plugins. rz-bin is used by the core to get data like exported symbols, imports, file information, cross references (xrefs), library dependencies, and sections.\n\n\n1.0.3 rz-asm\nA command line assembler and disassembler for multiple architectures (including Intel x86 and x86-64, MIPS, ARM, PowerPC, Java, and myriad of others).\n\n1.0.3.1 Examples\n$ rz-asm -a java 'nop'\n00\n$ rz-asm -a x86 -d '90'\nnop\n$ rz-asm -a x86 -b 32 'mov eax, 33'\nb821000000\n$ echo 'push eax;nop;nop' | rz-asm -f -\n509090\n\n\n\n1.0.4 rz-hash\nAn implementation of a block-based hash tool. From small text strings to large disks, rz-hash supports multiple algorithms, including MD4, MD5, CRC16, CRC32, SHA1, SHA256, and others. rz-hash can be used to check the integrity or track changes of big files, memory dumps, or disks.\n\n\n1.0.5 Examples\n$ rz-hash file\nfile: 0x00000000-0x00000007 sha256: 887cfbd0d44aaff69f7bdbedebd282ec96191cce9d7fa7336298a18efc3c7a5a\n$ rz-hash -a md5 file\nfile: 0x00000000-0x00000007 md5: d1833805515fc34b46c2b9de553f599d\n\n\n1.0.6 rz-diff\nA binary diffing utility that implements multiple algorithms. It supports byte-level or delta diffing for binary files, and code-analysis diffing to find changes in basic code blocks obtained from the rizin code analysis.\n\n\n1.0.7 rz-find\nA program to find byte patterns in files.\n\n\n1.0.8 rz-egg\nA frontend for r_egg. rz-egg compiles programs written in a simple high-level language into tiny binaries for x86, x86-64, and ARM.\n\n1.0.8.1 Examples\n$ cat hi.r\n/* hello world in r_egg */\nwrite@syscall(4); //x64 write@syscall(1);\nexit@syscall(1); //x64 exit@syscall(60);\n\nmain@global(128) {\n .var0 = \"hi!\\n\";\n write(1,.var0, 4);\n exit(0);\n}\n$ rz-egg -O -F hi.r\n$ ./hi\nhi!\n\n$ cat hi.c\nmain@global(0,6) {\n write(1, \"Hello0\", 6);\n exit(0);\n}\n$ rz-egg hi.c\n$ ./hi.c.bin\nHello\n\n\n\n1.0.9 rz-run\nA launcher for running programs within different environments, with different arguments, permissions, directories, and overridden default file descriptors. rz-run is useful for:\n\nSolving crackmes\nFuzzing\nTest suites\n\n\n1.0.9.1 Sample rz-run script\n$ cat foo.rrz\n#!/usr/bin/rz-run\nprogram=./pp400\narg0=10\nstdin=foo.txt\nchdir=/tmp\n#chroot=.\n./foo.rrz\n\n\n1.0.9.2 Connecting a Program with a Socket\n$ nc -l 9999\n$ rz-run program=/bin/ls connect=localhost:9999\n\n\n1.0.9.3 Debugging a Program Redirecting the stdio into Another Terminal\n1 - open a new terminal and type ‘tty’ to get a terminal name:\n$ tty ; clear ; sleep 999999\n/dev/ttyS010\n2 - Create a new file containing the following rz-run profile named foo.rrz:\n#!/usr/bin/rz-run\nprogram=/bin/ls\nstdio=/dev/ttys010\n3 - Launch the following rizin command:\nrizin -r foo.rrz -d /bin/ls\n\n\n\n1.0.10 rz-ax\nA minimalistic mathematical expression evaluator for the shell that is useful for making base conversions between floating point values, hexadecimal representations, hexpair strings to ASCII, octal to integer, and more. It also supports endianness settings and can be used as an interactive shell if no arguments are given.\n\n1.0.10.1 Examples\n$ rz-ax 1337\n0x539\n\n$ rz-ax 0x400000\n4194304\n\n$ rz-ax -b 01111001\ny\n\n$ rz-ax -S rizin\n72616461726532\n\n$ rz-ax -s 617765736f6d65\nawesome\n\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/getting_rizin.html",
    "title": "2  Downloading Rizin",
    "section": "",
    "text": "Binary packages are available for most of the common platforms (e.g. Windows, MacOS, Linux), however you can still compile rizin yourself for many other architectures/operating systems.\nPlease have a look at the releases tab of Rizin’s GitHub repository for the binary packages. See BUILDING.md for more detailed instructions on how to build the tool.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/compilation_portability.html",
    "title": "3  Compilation and Portability",
    "section": "",
    "text": "Currently the core of rizin can be compiled on many systems and architectures, but the main development is done on GNU/Linux with GCC, and on MacOS X with clang. Rizin is also known to compile on many different systems and architectures (including TCC and SunStudio).\nPeople often want to use rizin as a debugger for reverse engineering. Currently, the debugger layer can be used on Windows, GNU/Linux (Intel x86 and x86_64, MIPS, and ARM), OS X, FreeBSD, NetBSD, and OpenBSD (Intel x86 and x86_64)..\nCompared to core, the debugger feature is more restrictive portability-wise. If the debugger has not been ported to your favorite platform, you can disable the debugger layer with the meson option -Ddebugger=false. Have a look at BUILDING.md for more information.\nNote that there are I/O plugins that use GDB, WinDbg, or Wine as back-ends, and therefore rely on presence of corresponding third-party tools (in case of remote debugging - just on the target machine).\n\n3.0.1 Docker\nRizin repository ships a Dockerfile that you can use with Docker.\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/windows_compilation.html",
    "title": "4  Windows",
    "section": "",
    "text": "Rizin relies on the Meson build system generator to support compilation on all platforms, including Windows. Meson will generate a Visual Studio Solution, all the necessary project files, and wire up the Microsoft Visual C++ compiler for you.\n\ntip You can download nightly binaries from https://ci.appveyor.com/project/rizinorg/rizin/history. Be sure to download only from master branch!\n\n\n4.0.1 Prerequisites\n\nVisual Studio 2015 (or higher)\nPython 3\nMeson\nGit\n\n\n\n4.0.2 Step-by-Step\n\n4.0.2.1 Install Visual Studio 2015 (or higher)\nVisual Studio must be installed with a Visual C++ compiler, supporting C++ libraries, and the appropriate Windows SDK for the target platform version.\n\nIn the Visual Studio 2015 installer, ensure Programming Languages > Visual C++ is selected\nIn the Visual Studio 2017+ installers, ensure the Desktop development with C++ workload is selected\n\nIf you need a copy of Visual Studio, the Community versions are free and work great.\n\nDownload Visual Studio 2015 Community (registration required)\nDownload Visual Studio 2017 Community\nDownload Visual Studio 2019 Community\n\n\n\n4.0.2.2 Install Python 3 and Meson/Ninja via Conda\nIt is strongly recommended you install Conda — a Python environment management system — when working with Python on the Windows platform. This will isolate the Rizin build environment from other installed Python versions and minimize potential conflicts.\n\n4.0.2.2.1 Set Up Conda:\n\nDownload the appropriate Conda (Python 3.x) for your platform (https://conda.io/miniconda.html)\nInstall Conda with the recommended defaults\n\n\n\n4.0.2.2.2 Create a Python Environment for Rizin\nFollow these steps to create and activate a Conda environment named rizin. All instructions from this point on will assume this name matches your environment, but you may change this if desired.\n\nStart > Anaconda Prompt\nconda create -n rizin python=3\nactivate rizin\n\nAny time you wish to enter this environment, open the Anaconda Prompt and re-issue activate rizin. Conversely, deactivate will leave the environment.\n\n\n4.0.2.2.3 Install Meson + Ninja\n\nEnter the Rizin Conda environment, if needed (activate rizin)\nDownload meson + ninja\npip install meson ninja\nVerify Meson is version 0.50 or higher (meson -v)\n\n\n\n\n4.0.2.3 Install Git for Windows\nAll Rizin code is managed via the Git version control system and hosted on GitHub.\nFollow these steps to install Git for Windows.\n\nDownload Git for Windows\n\nAs you navigate the install wizard, we recommend you set these options when they appear: * Use a TrueType font in all console windows * Use Git from the Windows Command Prompt * Use the native Windows Secure Channel library (instead of OpenSSL) * Checkout Windows-style, commit Unix-style line endings (core.autocrlf=true) * Use Windows’ default console window (instead of Mintty)\n\nClose any previously open console windows and re-open them to ensure they receive the new PATH\nEnsure git --version works\n\n\n\n4.0.2.4 Get Rizin Code\nFollow these steps to clone the Rizin git repository.\n\nIn your Rizin Conda environment, navigate to a location where the code will be saved and compiled. This location needs approximately 3-4GiB of space\nClone the repository with git clone --recurse-submodules https://github.com/rizinorg/rizin.git\n\n\n\n4.0.2.5 Compile Rizin Code\nFollow these steps to compile the Rizin Code.\nCompiled binaries will be installed into the dest folder.\n\nEnter the Rizin Conda environment\nNavigate to the root of the Rizin sources (cd rizin)\nInitialize Visual Studio tooling by executing the command below that matches the version of Visual Studio installed on your machine and the version of Rizin you wish to install:\n\nVisual Studio 2015:\nNote: For the 64-bit version change only the x86 at the very end of the command below to x64.\n\"%ProgramFiles(x86)%\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat\" x86\nVisual Studio 2017/2019:\nNote 1: Change Community to either Professional or Enterprise in the command below depending on the version installed.\nNote 2: Change vcvars32.bat to vcvars64.bat in the command below for the 64-bit version.\nNote 3: Change 2017 to 2019 if you are using Visual Studio 2019.\n\"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\"\nVisual Studio Preview:\nNote 1: Change Community to either Professional or Enterprise in the command below depending on the version installed.\nNote 2: Change vcvars32.bat to vcvars64.bat in the command below for the 64-bit version.\n\"%ProgramFiles(x86)%\\Microsoft Visual Studio\\Preview\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\"\n\nGenerate the build system with Meson:\n\nNote 1: Change debug to release in the command below depending on whether the latest version or release version is desired.\nmeson --buildtype debug --prefix %cd%\\dest build\nMeson currently requires --prefix to point to an absolute path. We use the %CD% pseudo-variable to get the absolute path to the current working directory.\n\nStart a build:\n\nninja -C build\n\nInstall into your destination folder: ninja -C build install\nCheck your Rizin version: dest\\bin\\rizin.exe -v\n\n\n\n4.0.2.6 Check That Rizin Runs From All Locations\n\nIn the file explorer go to the folder Rizin was just installed in.\nFrom this folder go to dest > bin and keep this window open.\nGo to System Properties: In the Windows search bar enter sysdm.cpl.\nGo to Advanced > Environment Variables.\nClick on the PATH variable and then click edit (if it exists within both the user and system variables, look at the user version).\nEnsure the file path displayed in the window left open is listed within the PATH variable. If it is not add it and click ok.\nLog out of your Windows session.\nOpen up a new Windows Command Prompt: type cmd in the search bar. Ensure that the current path is not in the Rizin folder.\nCheck Rizin version from Command Prompt Window: rizin -v\n\n\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/compilation_android.html",
    "title": "5  Android",
    "section": "",
    "text": "Rizin can be cross-compiled for other architectures/systems as well, like Android.\n\n5.0.1 Prerequisites\n\nPython 3\nMeson\nNinja\nGit\nAndroid NDK\n\n\n\n5.0.2 Step-by-step\n\n5.0.2.1 Download and extract the Android NDK\nDownload the Android NDK from the official site and extract it somewhere on your system (e.g. /tmp/android-ndk)\n\n\n5.0.2.2 Meson\nSee also BUILDING.md.\n\n5.0.2.2.1 Create a cross-file for meson\nMeson needs a configuration file that describes the cross compilation environment (e.g. meson-android.ini). You can adjust it as necessary, but something like the following should be a good starting point:\n[binaries]\nc       = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang'\ncpp     = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang++'\nar      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ar'\nas      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-as'\nranlib  = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ranlib'\nld      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ld'\nstrip   = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-strip'\npkgconfig = 'false'\n\n[properties]\nsys_root = '/tmp/android-ndk/sysroot'\n\n[host_machine]\nsystem = 'android'\ncpu_family = 'arm'\ncpu = 'aarch64'\nendian = 'little'\n\n\n5.0.2.2.2 Compile with meson + ninja\nNow setup the build directory with meson as usual:\n$ meson --default-library static -Dstatic_runtime=true --prefix=/tmp/android-dir -Dblob=true build --cross-file ./meson-android.ini\nA bit of explanation about all the options: * --default-library static -Dstatic_runtime=true: this ensure that libraries and binaries are statically compiled, so you do not need to properly set LD_ environment variables in your Android environment to make it find the right libraries. Binaries have everything they need inside.  -Dblob=true: it tells meson to compile just one binary with all the needed code for running rizin, rz-bin, rz-asm, etc. and creates symbolic links to those names. This avoids creating many statically compiled large binaries and just create one that provides all features. You will still have rz-bin, rz-asm, rz-ax, etc. but they are just symlinks to rizin. * --cross-file ./meson-android.ini: it describes how to compile rizin for Android\nThen compile and install the project:\n$ ninja -C build\n$ ninja -C build install\n\n\n5.0.2.2.3 Move files to your android device and enjoy\nAt this point you can copy the generated files in /tmp/android-dir to your Android device and running rizin from it. For example:\n$ cd /tmp && tar -cvf rizin-android.tar.gz android-dir\n$ adb push rizin-android.tar.gz /data/local/tmp\n$ adb shell\nDEVICE:/ $ cd /data/local/tmp\nDEVICE:/data/local/tmp $ tar xvf rizin-android.tar.gz\nDEVICE:/data/local/tmp $ ./android-dir/bin/rizin\nUsage: rizin [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]\n          [-s addr] [-B baddr] [-m maddr] [-c cmd] [-e k=v] file|pid|-|--|=\n\n\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/intro.html",
    "title": "6  Basic Rizin Usage",
    "section": "",
    "text": "The learning curve is usually somewhat steep at the beginning. Although after an hour of using it you should easily understand how most things work, and how to combine the various tools rizin offers. You are encouraged to read the rest of this book to understand how some non-trivial things work, and to ultimately improve your skills.\n\n\n\nlearning_curve\n\n\nNavigation, inspection and modification of a loaded binary file is performed using three simple actions: seek (to position), print (buffer), and alternate (write, append).\nThe ‘seek’ command is abbreviated as s and accepts an expression as its argument. The expression can be something like 10, +0x25, or [0x100+ptr_table]. If you are working with block-based files, you may prefer to set the block size to a required value with b command, and seek forward or backwards with positions aligned to it. Use s++ and s-- commands to navigate this way.\nIf rizin opens an executable file, by default it will open the file in Virtual Addressing (VA) mode and the sections will be mapped to their virtual addresses. In VA mode, seeking is based on the virtual address and the starting position is set to the entry point of the executable. Using -n option you can suppress this default behavior and ask rizin to open the file in non-VA mode for you. In non-VA mode, seeking is based on the offset from the beginning of the file.\nThe ‘print’ command is abbreviated as p and has a number of submodes — the second letter specifying a desired print mode. Frequent variants include px to print in hexadecimal, and pd for disassembling.\nTo be allowed to write files, specify the -w option to rizin when opening a file. The w command can be used to write strings, hexpairs (x subcommand), or even assembly opcodes (a subcommand). Examples:\n> w hello world         ; string\n> wx 90 90 90 90        ; hexpairs\n> wa jmp 0x8048140      ; assemble\n> wf inline.bin         ; write contents of file\nAppending a ? to a command will show its help message, for example, p?. Appending ?* will show commands starting with the given string, e.g. p?*.\nTo enter visual mode, press V<enter>. Use q to quit visual mode and return to the prompt.\nIn visual mode you can use HJKL keys to navigate (left, down, up, and right, respectively). You can use these keys in cursor mode toggled by c key. To select a byte range in cursor mode, hold down SHIFT key, and press navigation keys HJKL to mark your selection.\nWhile in visual mode, you can also overwrite bytes by pressing i. You can press TAB to switch between the hex (middle) and string (right) columns. Pressing q inside the hex panel returns you to visual mode. By pressing p or P you can scroll different visual mode representations. There is a second most important visual mode - curses-like panels interface, accessible with V! command.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/commandline_flags.html",
    "title": "7  Command-line Options",
    "section": "",
    "text": "The rizin core accepts many flags from the command line.\nThis is an excerpt from the usage help message:\n$ rizin -h\nUsage: rizin [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]\n          [-s addr] [-B baddr] [-m maddr] [-c cmd] [-e k=v] file|pid|-|--|=\n --           run rizin without opening any file\n =            same as 'rizin malloc://512'\n -            read file from stdin (use -i and -c to run cmds)\n -=           perform !=! command to run all commands remotely\n -0           print \\x00 after init and every command\n -2           close stderr file descriptor (silent warning messages)\n -a [arch]    set asm.arch\n -A           run 'aaa' command to analyze all referenced code\n -b [bits]    set asm.bits\n -B [baddr]   set base address for PIE binaries\n -c 'cmd..'   execute rizin command\n -C           file is host:port (alias for -c+=http://%s/cmd/)\n -d           debug the executable 'file' or running process 'pid'\n -D [backend] enable debug mode (e cfg.debug=true)\n -e k=v       evaluate config var\n -f           block size = file size\n -F [binplug] force to use that rbin plugin\n -h, -hh      show help message, -hh for long\n -H ([var])   display variable\n -i [file]    run script file\n -I [file]    run script file before the file is opened\n -k [OS/kern] set asm.os (linux, macos, w32, netbsd, ...)\n -l [lib]     load plugin file\n -L           list supported IO plugins\n -m [addr]    map file at given address (loadaddr)\n -M           do not demangle symbol names\n -n, -nn      do not load RzBin info (-nn only load bin structures)\n -N           do not load user settings and scripts\n -q           quiet mode (no prompt) and quit after -i\n -Q           quiet mode (no prompt) and quit faster (quickLeak=true)\n -p [prj]     use project, list if no arg, load if no file\n -P [file]    apply rapatch file and quit\n -r [rz-run]  specify rz-run profile to load (same as -e dbg.profile=X)\n -R [rrzrule] specify custom rz-run directive\n -s [addr]    initial seek\n -S           start rizin in sandbox mode\n -t           load rz-bin info in thread\n -u           set bin.filter=false to get raw sym/sec/cls names\n -v, -V       show rizin version (-V show lib versions)\n -w           open file in write mode\n -x           open without exec-flag (asm.emu will not work), See io.exec\n -X           same as -e bin.usextr=false (useful for dyldcache)\n -z, -zz      do not load strings or load them even in raw\n\n7.0.1 Common usage patterns\nOpen a file in write mode without parsing the file format headers.\n$ rizin -nw file\nQuickly get into an rizin shell without opening any file.\n$ rizin \nQuickly get into an rizin shell with malloc://512\n$ rizin = \nSpecify which sub-binary you want to select when opening a fatbin file:\n$ rizin -a ppc -b 32 ls.fat\nRun a script before showing interactive command-line prompt:\n$ rizin -i patch.rz target.bin\nExecute a command and quit without entering the interactive mode:\n$ rizin -qc ij hi.bin > imports.json\nSet the configuration variable:\n$ rizin -e scr.color=0 blah.bin\nDebug a program:\n$ rizin -d ls\nUse an existing project file:\n$ rizin -p test\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/command_format.html",
    "title": "8  Command Format",
    "section": "",
    "text": "A general format for rizin commands is as follows:\n[.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ;\nPeople who use Vim daily and are familiar with its commands will find themselves at home. You will see this format used throughout the book. Commands are identified by a single case-sensitive character [a-zA-Z].\nTo repeatedly execute a command, prefix the command with a number:\npx    # run px\n3px   # run px 3 times\nThe ! prefix is used to execute a command in shell context. If you want to use the cmd callback from the I/O plugin you must prefix with R!.\nNote that a single exclamation mark will run the command and print the output through the RCons API. This means that the execution will be blocking and not interactive. Use double exclamation marks – !! – to run a standard system call.\nAll the socket, filesystem and execution APIs can be restricted with the cfg.sandbox configuration variable.\nA few examples:\nds                    ; call the debugger's 'step' command\npx 200 @ esp          ; show 200 hex bytes at esp\npc > file.c           ; dump buffer as a C byte array to file.c\nwx 90 @@is            ; write a nop on every symbol\npd 2000 | grep eax    ; grep opcodes that use the 'eax' register\npx 20 ; pd 3 ; px 40  ; multiple commands in a single line\nThe standard UNIX pipe | is also available in the rizin shell. You can use it to filter the output of an rizin command with any shell program that reads from stdin, such as grep, less, wc. If you do not want to spawn anything, or you can’t, or the target system does not have the basic UNIX tools you need (Windows or embedded users), you can also use the built-in grep (~).\nSee ~? for help.\nThe ~ character enables internal grep-like function used to filter output of any command:\npd 20~call            ; disassemble 20 instructions and grep output for 'call'\nAdditionally, you can grep either for columns or for rows:\npd 20~call:0          ; get first row\npd 20~call:1          ; get second row\npd 20~call[0]         ; get first column\npd 20~call[1]         ; get second column\nOr even combine them:\npd 20~call:0[0]       ; grep the first column of the first row matching 'call'\nThis internal grep function is a key feature for scripting rizin, because it can be used to iterate over a list of offsets or data generated by disassembler, ranges, or any other command. Refer to the loops section (iterators) for more information.\nThe @ character is used to specify a temporary offset at which the command to its left will be executed. The original seek position in a file is then restored.\nFor example, pd 5 @ 0x100000fce to disassemble 5 instructions at address 0x100000fce.\nMost of the commands offer autocompletion support using <TAB> key, for example seek or flags commands. It offers autocompletion using all possible values, taking flag names in this case. Note that it is possible to see the history of the commands using the !~... command - it offers a visual mode to scroll through the rizin command history.\nTo extend the autocompletion support to handle more commands or enable autocompletion to your own commands defined in core, I/O plugins you must use the !!! command.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/expressions.html",
    "title": "9  Expressions",
    "section": "",
    "text": "Expressions are mathematical representations of 64-bit numerical values. They can be displayed in different formats, be compared or used with all commands accepting numeric arguments. Expressions can use traditional arithmetic operations, as well as binary and boolean ones. To evaluate mathematical expressions prepend them with command ?:\n[0xb7f9d810]> ?vi 0x8048000\n134512640\n[0xv7f9d810]> ?vi 0x8048000+34\n134512674\n[0xb7f9d810]> ?vi 0x8048000+0x34\n134512692\n[0xb7f9d810]> ? 1+2+3-4*3\nhex     0xfffffffffffffffa\noctal   01777777777777777777772\nunit    17179869184.0G\nsegment fffff000:0ffa\nint64   -6\nstring  \"\\xfa\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\nbinary  0b1111111111111111111111111111111111111111111111111111111111111010\nfvalue: -6.0\nfloat:  nanf\ndouble: nan\ntrits   0t11112220022122120101211020120210210211201\nSupported arithmetic operations are:\n\n+ : addition\n- : subtraction\n* : multiplication\n/ : division\n% : modulus\n> : shift right\n< : shift left\n\n[0x00000000]> ?vi 1+2+3\n6\nTo use of logical OR should quote the whole command to avoid executing the | pipe:\n[0x00000000]> \"? 1 | 2\"\nhex     0x3\noctal   03\nunit    3\nsegment 0000:0003\nint32   3\nstring  \"\\x03\"\nbinary  0b00000011\nfvalue: 2.0\nfloat:  0.000000f\ndouble: 0.000000\ntrits   0t10\nNumbers can be displayed in several formats:\n0x033   : hexadecimal can be displayed\n3334    : decimal\nsym.fo  : resolve flag offset\n10K     : KBytes  10*1024\n10M     : MBytes  10*1024*1024\nYou can also use variables and seek positions to build complex expressions.\nUse the ?$? command to list all the available commands or read the refcard chapter of this book.\n$$    here (the current virtual seek)\n$l    opcode length\n$s    file size\n$j    jump address (e.g. jmp 0x10, jz 0x10 => 0x10)\n$f    jump fail address (e.g. jz 0x10 => next instruction)\n$m    opcode memory reference (e.g. mov eax,[0x10] => 0x10)\n$b    block size\nSome more examples:\n[0x4A13B8C0]> ? $m + $l\n140293837812900 0x7f98b45df4a4 03771426427372244 130658.0G 8b45d000:04a4 140293837812900 10100100 140293837812900.0 -0.000000\n[0x4A13B8C0]> pd 1 @ +$l\n0x4A13B8C2   call 0x4a13c000\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/basic_debugger_session.html",
    "title": "10  Basic Debugger Session",
    "section": "",
    "text": "To debug a program, start rizin with the -d option. Note that you can attach to a running process by specifying its PID, or you can start a new program by specifying its name and parameters:\n$ pidof mc\n32220\n$ rizin -d 32220\n$ rizin -d /bin/ls\n$ rizin -a arm -b 16 -d gdb://192.168.1.43:9090\n...\nIn the second case, the debugger will fork and load the debuggee ls program in memory.\nIt will pause its execution early in ld.so dynamic linker. As a result, you will not yet see the entrypoint or any shared libraries at this point.\nYou can override this behavior by setting another name for an entry breakpoint. To do this, add a rizin command e dbg.bep=entry or e dbg.bep=main to your startup script, usually it is ~/.config/rizin/rizinrc.\nAnother way to continue until a specific address is by using the dcu command. Which means: “debug continue until” taking the address of the place to stop at. For example:\ndcu main\nBe warned that certain malware or other tricky programs can actually execute code before main() and thus you’ll be unable to control them. (Like the program constructor or the tls initializers)\nBelow is a list of most common commands used with debugger:\n> d?            ; get help on debugger commands\n> ds 3          ; step 3 times\n> db 0x8048920  ; setup a breakpoint\n> db -0x8048920 ; remove a breakpoint\n> dc            ; continue process execution\n> dcs           ; continue until syscall\n> dd            ; manipulate file descriptors\n> dm            ; show process maps\n> dmp A S rwx   ; change permissions of page at A and size S\n> dr eax=33     ; set register value. eax = 33\nThere is another option for debugging in rizin, which may be easier: using visual mode.\nThat way you will neither need to remember many commands nor to keep program state in your mind.\nTo enter visual debugger mode use Vpp:\n[0xb7f0c8c0]> Vpp\nThe initial view after entering visual mode is a hexdump view of the current target program counter (e.g., EIP for x86). Pressing p will allow you to cycle through the rest of visual mode views. You can press p and P to rotate through the most commonly used print modes. Use F7 or s to step into and F8 or S to step over current instruction. With the c key you can toggle the cursor mode to mark a byte range selection (for example, to later overwrite them with nop). You can set breakpoints with F2 key.\nIn visual mode you can enter regular rizin commands by prepending them with :. For example, to dump a one block of memory contents at ESI:\n<Press ':'>\nx @ esi\nTo get help on visual mode, press ?. To scroll the help screen, use arrows. To exit the help view, press q.\nA frequently used command is dr, which is used to read or write values of the target’s general purpose registers. For a more compact register value representation you might use dr= command. You can also manipulate the hardware and the extended/floating point registers.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/first_steps/contributing.html",
    "title": "11  Contributing",
    "section": "",
    "text": "11.0.1 Rizin Book\nIf you want to contribute to the Rizin book, you can do it at the Github repository. Suggested contributions include:\n\nCrackme writeups\nCTF writeups\nDocumentation on how to use Rizin\nDocumentation on developing for Rizin\nConference presentations/workshops using Rizin\nMissing content from the Radare1 book updated to Rizin\n\nPlease get permission to port any content you do not own/did not create before you put it in the Rizin book.\nSee https://github.com/rizinorg/rizin/blob/dev/CONTRIBUTING.md for general help on contributing to rizin.\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/configuration/intro.html",
    "title": "12  Configuration",
    "section": "",
    "text": "The core reads ~/.config/rizin/rizinrc while starting. You can add e commands to this file to tune the rizin configuration to your taste.\nTo prevent rizin from parsing this file at startup, pass it the -N option.\nAll the configuration of rizin is done with the eval commands. A typical startup configuration file looks like this:\n$ cat ~/.rizinrc\ne scr.color=1\ne dbg.bep   = loader\nThe configuration can also be changed with -e <config=value> command-line option. This way you can adjust configuration from the command line, keeping the .rizinrc file intact. For example, to start with empty configuration and then adjust scr.color and asm.syntax the following line may be used:\n$ rizin -N -e scr.color=1 -e asm.syntax=intel -d /bin/ls\nInternally, the configuration is stored in a hash table. The variables are grouped in namespaces: cfg., file., dbg., scr. and so on.\nTo get a list of all configuration variables just type e in the command line prompt. To limit the output to a selected namespace, pass it with an ending dot to e. For example, e file. will display all variables defined inside the “file” namespace.\nTo get help about e command type e?:\n[0x00000000]> e?\nUsage: e[?]   # List/get/set config evaluable vars\n| e <key>[=<val|?>] [<key>[=<val|?>] ...]] # Get/Set value of config variable <key>\n| el[j*qlJ] [<key>]      # List config variables with their descriptions\n| e-                     # Reset config variables\n| e! <key>               # Invert the boolean value of config variable <var>\n| ec[?]                  # Set color for given key (prompt, offset, ...)\n| ee <key>               # Open editor to change the value of config variable <var>\n| ed                     # Open editor to change ~/.rizinrc\n| er <key>               # Set config variable <var> as read-only\n| es [<key>]             # List all config variable spaces or sub-keys/sub-spaces if a <key> is provided\n| et <key>               # Show type of given config variable <var>\n| env [<varname>[=<varvalue>]] # Get/set environment variables\nA simpler alternative to the e command is accessible from the visual mode. Type Ve to enter it, use arrows (up, down, left, right) to navigate the configuration, and q to exit it. The start screen for the visual configuration edit looks like this:\n[EvalSpace]\n\n    >  analysis\n       asm\n       bin\n       cfg\n       cmd\n       dbg\n       diff\n       dir\n       emu\n       esil\n       file\n       graph\n       hex\n       http\n       hud\n       io\n       key\n       log\n       magic\n       pdb\n       ...\nFor configuration values that can take one of several values, you can use the =? operator to get a list of valid values:\n[0x00000000]> e scr.nkey=?\nscr.nkey = fun, hit, flag\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/configuration/colors.html#themes",
    "title": "13  Colors",
    "section": "13.1 Themes",
    "text": "You can create your own color theme, but rizin have its own predefined ones. Use the eco command to list or select them.\nAfter selecting one, you can compare between the color scheme of the shell and the current theme by pressing Ctrl-Shift and then right arrow key for the toggle.\nIn visual mode use the R key to randomize colors or choose the next theme in the list."
  },
  {
    "href": "src/configuration/evars.html#assembly-configuration",
    "title": "14  Configuration Variables",
    "section": "14.1 Assembly Configuration",
    "text": "14.1.1 asm.arch: string\nDefines the target CPU architecture used for disassembling (pd, pD commands) and code analysis (a command). You can find the list of possible values by looking at the result of e asm.arch=? or rz-asm -L. It is quite simple to add new architectures for disassembling and analyzing code. There is an interface for that. For x86, it is used to attach a number of third-party disassembler engines, including GNU binutils, Udis86 and a few handmade ones.\n\n\n14.1.2 asm.bits: int\nDetermines width in bits of registers for the current architecture. Supported values:\n\n8\n16\n32\n64\n\nNote that not all target architectures support all combinations for asm.bits.\n\n\n14.1.3 asm.bytes: bool\nShow or hide displaying of raw bytes of instructions. By default, it is turned off, resulting in a disassembly like:\n[0x00005b20]> e asm.bytes\nfalse\n[0x00005b20]> pd 5\n            0x00005b20      endbr64\n            0x00005b24      xor   ebp, ebp\n            0x00005b26      mov   r9, rdx\n            0x00005b29      pop   rsi\n            0x00005b2a      mov   rdx, rsp\nWhen turned on, the raw bytes will be displayed along with the instructions:\n[0x00005b20]> e asm.bytes=true\n[0x00005b20]> pd 5\n            ;-- entry0:\n            ;-- rip:\n            0x00005b20      f30f1efa       endbr64\n            0x00005b24      31ed           xor   ebp, ebp\n            0x00005b26      4989d1         mov   r9, rdx\n            0x00005b29      5e             pop   rsi\n            0x00005b2a      4889e2         mov   rdx, rsp\n\n\n14.1.4 asm.cpu: string\nYou can use this configuration variable to define the CPU type. For example, if you had picked the architecture as AVR, you can choose your CPU type (ATmega1281, ATmega2561, etc) using asm.cpu.\n\n\n14.1.5 asm.platform: string\nYou can use this configuration variable to select the platform and it’ll load up the corresponding platform profile during analysis. See the section about CPU and platform profiles for more information.\n\n\n14.1.6 asm.flags: bool\nWhen set to “true”, the disassembler view will have the flags column.\n\n\n14.1.7 asm.fcn.size: bool\nThis variable is used to display the size of the function in the disassembly. By default, it is set to false and turning it on would result in a disassembly like the one below:\n┌ 44: int main (char **argv);\n│           ; var int32_t var_4h @ ebp-0x4\n│           ; arg char **argv @ esp+0x24\n│           0x000011cd      lea   ecx, [argv]\n│           0x000011d1      and   esp, 0xfffffff0\nHere, 44 is the size of the function.\n\n\n14.1.8 asm.lines.call: bool\nIf set to “true”, draw lines at the left of the disassembly output (pd, pD commands) to graphically represent control flow changes (jumps and calls) that are targeted inside the current block. Also, see asm.lines.out.\n\n\n14.1.9 asm.lines.out: bool\nWhen set to “true”, the disassembly view will also draw control flow lines that go outside of the block.\n\n\n14.1.10 asm.offset: bool\nShow or hide offsets for individual disassembled instructions.\n\n\n14.1.11 asm.os: string\nSelects a target operating system for the currently loaded binary. Usually, OS is automatically detected by Rizin (rz-bin -rI). Yet, asm.os can be used to switch to a different syscall table employed by another OS.\n\n\n14.1.12 asm.pseudo: bool\nA boolean value to set the pseudo syntax in the disassembly. “False” indicates a native one, defined by the current architecture, “true” activates a pseudocode strings format. For example, it’ll transform :\n│           0x080483ff      e832000000     call 0x8048436\n│           0x08048404      31c0           xor eax, eax\n│           0x08048406      0205849a0408   add al, byte [0x8049a84]\n│           0x0804840c      83f800         cmp eax, 0\n│           0x0804840f      7405           je 0x8048416\nto\n│           0x080483ff      e832000000     0x8048436 ()\n│           0x08048404      31c0           eax = 0\n│           0x08048406      0205849a0408   al += byte [0x8049a84]\n│           0x0804840c      83f800         var = eax - 0\n│           0x0804840f      7405           if (!var) goto 0x8048416\nIt can be useful while disassembling obscure architectures.\n\n\n14.1.13 asm.sub.jmp: bool\nSubstitute jump, call and branch targets with function names in the disassembly.\nFor example, when turned on, it’d display jal 0x80001a40 as jal fcn.80001a40 in the disassembly.\n\n\n14.1.14 asm.sub.reg: bool\nReplace register names with arguments or their associated role alias.\nFor example, if you have something like this:\n│           0x080483ea      83c404         add esp, 4\n│           0x080483ed      68989a0408     push 0x8049a98\n│           0x080483f7      e870060000     call sym.imp.scanf\n│           0x080483fc      83c408         add esp, 8\n│           0x08048404      31c0           xor eax, eax\nThis variable changes it to:\n│           0x080483ea      83c404         add SP, 4\n│           0x080483ed      68989a0408     push 0x8049a98\n│           0x080483f7      e870060000     call sym.imp.scanf\n│           0x080483fc      83c408         add SP, 8\n│           0x08048404      31c0           xor A0, A0\n\n\n14.1.15 asm.sub.rel: bool\nA boolean value that substitutes expressions relative to the Program Counter in the disassembly. When turned on, it shows the references as string references.\nFor example:\n0x5563844a0181      488d3d7c0e00.  lea rdi, [rip + 0xe7c]    ; str.argv__2d_:__s\nWhen turned on, this variable lets you display the above instruction as:\n0x5563844a0181      488d3d7c0e00.  lea rdi, str.argv__2d_:__s    ; 0x5563844a1004 ; \"argv[%2d]: %s\\n\"\n\n\n14.1.16 asm.sub.section: bool\nPrefix offsets in the disassembly with the name of the section or map.\nThat means, from something like:\n0x000067ea      488d0def0c01.  lea rcx, [0x000174e0]\nto the one below, when toggled on.\n0x000067ea      488d0def0c01.  lea rcx, [fmap.LOAD1.0x000174e0]\n\n\n14.1.17 asm.sub.varonly: bool\nSubstitutes the variable expression with the local variable name.\nFor example: var_14h as rbp - var_14h, in the disassembly.\n\n\n14.1.18 asm.syntax: string\nChanges syntax flavor for disassembler between Intel and AT&T. At the moment, this setting affects Udis86 disassembler for Intel 32/Intel 64 targets only. Supported values are intel and att.\n\n\n14.1.19 asm.tabs: int\nIf your disassembly doesn’t fit in your screen or aligns clumsily, asm.tabs might be of help. You can use this variable to control the distance between the operands, by setting the number of spaces, while displaying your disassembly.\nFor example, this is the disassembly with the variable set to 0:\n[0x000040a7]> e asm.tabs=0\n[0x000040a7]> pd 6\n│           0x000040a7      push rsp\n│           0x000040a8      mov r12d, edi                              ; argc\n│           0x000040ab      push rbp\n│           0x000040ac      mov rbp, rsi                               ; argv\n│           0x000040af      push rbx\n│           0x000040b0      sub rsp, 0x48\nAnd here’s what it would look like after setting it to 6:\n[0x000040a7]> e asm.tabs=6\n[0x000040a7]> pd 6\n│           0x000040a7      push  rsp\n│           0x000040a8      mov   r12d, edi                            ; argc\n│           0x000040ab      push  rbp\n│           0x000040ac      mov   rbp,  rsi                            ; argv\n│           0x000040af      push  rbx\n│           0x000040b0      sub   rsp,  0x48\n\n\n14.1.20 asm.tabs.once: bool\nThis is a boolean variable that can be set to true if you want to align only the opcodes, excluding the arguments. This makes sense only if you have set asm.tabs on.\n[0x00008290]> e asm.tabs=6\n[0x00008290]> e asm.tabs.once=false\n[0x00008290]> pd 10\n│           0x00008290      mov   ip,   sp\n│           0x00008294      push  {r4,  fp,   ip,   lr,   pc}\n│           0x00008298      sub   fp,   ip,   4\n│           0x0000829c      sub   sp,   sp,   0x24\n│           0x000082a0      str   r0,   [fp,  -0x28]\n│           0x000082a4      str   r1,   [fp,  -0x2c]\n│           0x000082a8      ldr   r3,   [fp,  -0x28]\n│           0x000082ac      cmp   r3,   1\n│       ┌─< 0x000082b0      bgt   0x82c0\n│       │   0x000082b4      mvn   r3,   0\nIn the above example, the opcodes and the operands are aligned. Now, turning it on would align only the opcodes.\n[0x00008290]> e asm.tabs.once=true\n[0x00008290]> pd 10\n│           0x00008290      mov   ip, sp\n│           0x00008294      push  {r4, fp, ip, lr, pc}\n│           0x00008298      sub   fp, ip, 4\n│           0x0000829c      sub   sp, sp, 0x24\n│           0x000082a0      str   r0, [var_28h]\n│           0x000082a4      str   r1, [var_2ch]\n│           0x000082a8      ldr   r3, [var_28h]\n│           0x000082ac      cmp   r3, 1\n│       ┌─< 0x000082b0      bgt   0x82c0\n│       │   0x000082b4      mvn   r3, 0\n\n\n14.1.21 asm.trace: bool\nA boolean value that controls displaying of tracing information (sequence number and counter) at the left of each opcode. It is used to assist with programs trace analysis."
  },
  {
    "href": "src/configuration/evars.html#debug-configuration",
    "title": "14  Configuration Variables",
    "section": "14.2 Debug Configuration",
    "text": "14.2.1 dbg.follow.child: bool\nThis variable lets you follow the child process, when a fork (system call) is encountered during debugging. By default, it is set to false and the parent process is traced."
  },
  {
    "href": "src/configuration/evars.html#screen-configuration",
    "title": "14  Configuration Variables",
    "section": "14.3 Screen Configuration",
    "text": "14.3.1 scr.color: int\nThis variable specifies the mode for colorized screen output.\n\n0 means no colors.\n1 means 16-colors mode.\n2 means 256-colors mode.\n3 means 16 million-colors mode.\n\nIf your favorite theme looks weird, try to bump this up.\n\n\n14.3.2 scr.seek: string\nThis variable accepts a full-featured expression or a pointer/flag (eg. eip). If set, rizin will set seek position to its value on startup.\n\n\n14.3.3 scr.scrollbar: bool\nIf you have set up any flagzones (fz?), this variable will let you display the scrollbar with the flagzones, in Visual mode. Set it to 1 to display the scrollbar at the right end, 2 for the top and 3 to display it at the bottom.\n\n\n14.3.4 scr.utf8: bool\nShow UTF-8 characters instead of ANSI.\n\n\n14.3.5 scr.utf8.curvy: bool\nThis variable lets you display curved corners in places like function graphs. This variable requires scr.utf8 to be turned on.\n[0x0000415c]> pd 4\n│           0x0000415c      cmp   eax, 2\n│       ┌─< 0x0000415f      je    0x5001\n│       │   0x00004165      cmp   eax, 3\n│      ┌──< 0x00004168      jne   0x4348\n[0x0000415c]> e scr.utf8.curvy=1\n[0x0000415c]> pd 4\n│           0x0000415c      cmp   eax, 2\n│       ╭─< 0x0000415f      je    0x5001\n│       │   0x00004165      cmp   eax, 3\n│      ╭──< 0x00004168      jne   0x4348\n\n\n14.3.6 scr.wheel: bool\nThis variable lets you enable the mouse in Visual mode. Turning this variable on will be useful when you want to use your mouse to scroll through your disassembly or copy something in the Visual mode."
  },
  {
    "href": "src/configuration/evars.html#general-configuration",
    "title": "14  Configuration Variables",
    "section": "14.4 General Configuration",
    "text": "14.4.1 cfg.bigendian: bool\nChange endianness. “true” means big-endian, “false” is for little-endian. “file.id” and “file.flag” both to be true.\n\n\n14.4.2 cfg.fortunes: bool\nEnables or disables “fortune” messages displayed at each rizin start.\n\n\n14.4.3 cfg.fortunes.file: string\nRizin has two types for fortunes: tips and fun. Fortunes of the type ‘tips’ are general tips to help you use Rizin better, whereas the other one prints some lighthearted jokes. You can choose which type of fortune to display, using this variable.\n[0x00000000]> e cfg.fortunes.file=tips\n[0x00000000]> fo\n -- Bindiff two files with '$ rz_diff /bin/true /bin/false'\n[0x00000000]> e cfg.fortunes.file=fun\n[0x00000000]> fo\n -- Welcome to \"IDA - the roguelike\"\n[0x00000000]>\nRizin also supports custom fortunes. You can save your fortunes in a file and provide the relative or absolute path to the same variable, to have them displayed at the startup.\n[0x00000000]> e cfg.fortunes.file=/path/to/my/fortunes.txt\nPlease make sure that you add these in your ~/.rizinrc to preserve the changes when you reopen rizin.\n\n\n14.4.4 cfg.newtab: bool\nIf this variable is enabled, help messages will be displayed along with command names in tab completion for commands."
  },
  {
    "href": "src/configuration/evars.html#stack-configuration",
    "title": "14  Configuration Variables",
    "section": "14.5 Stack Configuration",
    "text": "14.5.1 stack.size: int\nThis variable lets you set the size of stack in bytes."
  },
  {
    "href": "src/configuration/evars.html#command-configuration",
    "title": "14  Configuration Variables",
    "section": "14.6 Command Configuration",
    "text": ""
  },
  {
    "href": "src/configuration/evars.html#cmd.repeat-bool",
    "title": "14  Configuration Variables",
    "section": "14.7 cmd.repeat: bool",
    "text": "Sometimes, you may need to run the same command repeatedly and that is what cmd.repeat is for. When set to true, pressing Return key (Enter key) will run the previous command again.\nFor example:\n[0x00005bc0]> e cmd.repeat=true\n[0x00005bc0]> pd 2\n            ;-- entry.fini0:\n            0x00005bc0      endbr64\n            0x00005bc4      cmp   byte [0x000232c8], 0\nWhen turned on, you’d just need to press Enter key to run pd 2\n[0x00005bc0]>\n            0x00005bce      cmp   qword [reloc.__cxa_finalize], 0\n            0x00005bd6      mov   rbp, rsp"
  },
  {
    "href": "src/configuration/files.html#rc-files",
    "title": "15  Files",
    "section": "15.1 RC Files",
    "text": "RC files are rizin scripts that are loaded at startup time. Those files must be in 3 different places:\n\n15.1.1 System\nrizin will first try to load /usr/share/rizin/rizinrc\n\n\n15.1.2 Your Home\nEach user in the system can have its own rizin scripts to run on startup to select the color scheme, and other custom options by having rizin commands in there.\n\n~/.rizinrc\n~/.config/rizin/rizinrc\n~/.config/rizin/rizinrc.d/\n\n\n\n15.1.3 Target file\nIf you want to run a script every time you open a file, just create a file with the same name of the file but appending .rz to it."
  },
  {
    "href": "src/visual_mode/intro.html#navigation",
    "title": "17  Visual Mode",
    "section": "17.1 Navigation",
    "text": "Navigation can be done using HJKL or arrow keys and PgUp/PgDown keys. It also understands usual Home/End keys. Like in Vim the movements can be repeated by preceding the navigation key with the number, for example 5j will move down for 5 lines, or 2l will move 2 characters right.\n\n\n\nVisual Mode"
  },
  {
    "href": "src/visual_mode/intro.html#print-modes-aka-panels",
    "title": "17  Visual Mode",
    "section": "17.2 print modes aka panels",
    "text": "The Visual mode uses “print modes” which are basically different panel that you can rotate. By default those are:\n↻ Hexdump panel -> Disassembly panel → Debugger panel → Hexadecimal words dump panel → Hex-less hexdump panel → Op analysis color map panel → Annotated hexdump panel ↺.\nNotice that the top of the panel contains the command which is used, for example for the disassembly panel:\n[0x00404890 16% 120 /bin/ls]> pd $r @ entry0"
  },
  {
    "href": "src/visual_mode/intro.html#getting-help",
    "title": "17  Visual Mode",
    "section": "17.3 Getting Help",
    "text": "To see help on all key bindings defined for visual mode, press ?:\nVisual mode help:\n ?        show this help\n ??       show the user-friendly hud\n %        in cursor mode finds matching pair, or toggle autoblocksz\n @        redraw screen every 1s (multi-user view)\n ^        seek to the beginning of the function\n !        enter into the visual panels mode\n _        enter the flag/comment/functions/.. hud (same as VF_)\n =        set cmd.vprompt (top row)\n |        set cmd.cprompt (right column)\n .        seek to program counter\n \\        toggle visual split mode\n \"        toggle the column mode (uses pC..)\n /        in cursor mode search in current block\n :cmd     run rizin command\n ;[-]cmt  add/remove comment\n 0        seek to beginning of current function\n [1-9]    follow jmp/call identified by shortcut (like ;[1])\n ,file    add a link to the text file\n /*+-[]   change block size, [] = resize hex.cols\n </>      seek aligned to block size (seek cursor in cursor mode)\n a/A      (a)ssemble code, visual (A)ssembler\n b        browse symbols, flags, configurations, classes, ...\n B        toggle breakpoint\n c/C      toggle (c)ursor and (C)olors\n d[f?]    define function, data, code, ..\n D        enter visual diff mode (set diff.from/to\n e        edit eval configuration variables\n f/F      set/unset or browse flags. f- to unset, F to browse, ..\n gG       go seek to begin and end of file (0-$s)\n hjkl     move around (or HJKL) (left-down-up-right)\n i        insert hex or string (in hexdump) use tab to toggle\n mK/'K    mark/go to Key (any key)\n n/N      seek next/prev function/flag/hit (scr.nkey)\n g        go/seek to given offset\n O        toggle asm.pseudo and asm.esil\n p/P      rotate print modes (hex, disasm, debug, words, buf)\n q        back to rizin shell\n r        refresh screen / in cursor mode browse comments\n R        randomize color palette (ecr)\n sS       step / step over\n t        browse types\n uU       undo/redo seek\n v        visual function/vars code analysis menu\n V        (V)iew graph using cmd.graph (agv?)\n wW       seek cursor to next/prev word\n xX       show xrefs/refs of current function from/to data/code\n yY       copy and paste selection\n z        fold/unfold comments in disassembly\n Z        toggle zoom mode\n Enter    follow address of jump/call\nFunction Keys: (See 'e key.'), defaults to:\n  F2      toggle breakpoint\n  F4      run to cursor\n  F7      single step\n  F8      step over\n  F9      continue"
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#navigation",
    "title": "18  Visual Disassembly",
    "section": "18.1 Navigation",
    "text": "Move within the Disassembly using arrow keys or hjkl. Use g to seek directly to a flag or an offset, type it when requested by the prompt: [offset]>. Follow a jump or a call using the number of your keyboard [0-9] and the number on the right in disassembly to follow a call or a jump. In this example typing 1 on the keyboard would follow the call to sym.imp.__libc_start_main and therefore, seek at the offset of this symbol.\n0x00404894      e857dcffff     call sym.imp.__libc_start_main ;[1]\nSeek back to the previous location using u, U will allow you to redo the seek."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#d-as-define",
    "title": "18  Visual Disassembly",
    "section": "18.2 d as define",
    "text": "d can be used to change the type of data of the current block, several basic types/structures are available as well as more advanced one using pf template:\nd → ...\n0x004048f7      48c1e83f       shr rax, 0x3f\nd → b\n0x004048f7 .byte 0x48\nd → B\n0x004048f7 .word 0xc148\nd → d\n0x004048f7 hex length=165 delta=0\n0x004048f7  48c1 e83f 4801 c648 d1fe 7415 b800 0000\n...\nTo improve code readability you can change how rizin presents numerical values in disassembly, by default most of disassembly display numerical value as hexadecimal. Sometimes you would like to view it as a decimal, binary or even custom defined constant. To change value format you can use d following by i then choose what base to work in, this is the equivalent to ahi:\nd → i → ...\n0x004048f7      48c1e83f       shr rax, 0x3f\nd → i →  10\n0x004048f7      48c1e83f       shr rax, 63\nd → i →  2\n0x004048f7      48c1e83f       shr rax, '?'\n\n18.2.1 Usage of the Cursor for Inserting/Patching…\nRemember that, to be able to actually edit files loaded in rizin, you have to start it with the -w option. Otherwise a file is opened in read-only mode.\nPressing lowercase c toggles the cursor mode. When this mode is active, the currently selected byte (or byte range) is highlighted.\n\n\n\nCursor at 0x00404896\n\n\nThe cursor is used to select a range of bytes or simply to point to a byte. You can use the cursor to create a named flag at specific location. To do so, seek to the required position, then press f and enter a name for a flag. If the file was opened in write mode using the -w flag or the o+ command, you can also use the cursor to overwrite a selected range with new values. To do so, select a range of bytes (with HJKL and SHIFT key pressed), then press i and enter the hexpair values for the new data. The data will be repeated as needed to fill the range selected. For example:\n<select 10 bytes in visual mode using SHIFT+HJKL>\n<press 'i' and then enter '12 34'>\nThe 10 bytes you have selected will be changed to “12 34 12 34 12 …”.\nThe Visual Assembler is a feature that provides a live-preview while you type in new instructions to patch into the disassembly. To use it, seek or place the cursor at the wanted location and hit the ‘A’ key. To provide multiple instructions, separate them with semicolons, ;."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#xref",
    "title": "18  Visual Disassembly",
    "section": "18.3 XREF",
    "text": "When rizin has discovered a XREF during the analysis, it will show you the information in the Visual Disassembly using XREF tag:\n; DATA XREF from 0x00402e0e (unk)\nstr.David_MacKenzie:\nTo see where this string is called, press x, if you want to jump to the location where the data is used then press the corresponding number [0-9] on your keyboard. (This functionality is similar to axt)\nX corresponds to the reverse operation aka axf."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#function-argument-display",
    "title": "18  Visual Disassembly",
    "section": "18.4 Function Argument display",
    "text": "To enable this view use this config var e dbg.funcarg=true\n\n\n\nfuncarg"
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#add-a-comment",
    "title": "18  Visual Disassembly",
    "section": "18.5 Add a comment",
    "text": "To add a comment press ;."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#type-other-commands",
    "title": "18  Visual Disassembly",
    "section": "18.6 Type other commands",
    "text": "Quickly type commands using :."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#search",
    "title": "18  Visual Disassembly",
    "section": "18.7 Search",
    "text": "/: allows highlighting of strings in the current display. :cmd allows you to use one of the “/?” commands that perform more specialized searches."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#the-huds",
    "title": "18  Visual Disassembly",
    "section": "18.8 The HUDS",
    "text": "18.8.1 The “UserFriendly HUD”\nThe “UserFriendly HUD” can be accessed using the ?? key-combination. This HUD acts as an interactive Cheat Sheet that one can use to more easily find and execute commands. This HUD is particularly useful for new-comers. For experienced users, the other HUDS which are more activity-specific may be more useful.\n\n\n18.8.2 The “flag/comment/functions/.. HUD”\nThis HUD can be displayed using the _ key, it shows a list of all the flags defined and lets you jump to them. Using the keyboard you can quickly filter the list down to a flag that contains a specific pattern.\nHud input mode can be closed using ^C. It will also exit when backspace is pressed when the user input string is empty."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#tweaking-the-disassembly",
    "title": "18  Visual Disassembly",
    "section": "18.9 Tweaking the Disassembly",
    "text": "The disassembly’s look-and-feel is controlled using the “asm.* configuration keys, which can be changed using the e command. All configuration keys can also be edited through the Visual Configuration Editor."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#visual-configuration-editor",
    "title": "18  Visual Disassembly",
    "section": "18.10 Visual Configuration Editor",
    "text": "This HUD can be accessed using the e key in visual mode. The editor allows you to easily examine and change rizin’s configuration. For example, if you want to change something about the disassembly display, select asm from the list, navigate to the item you wish to modify it, then select it by hitting Enter. If the item is a boolean variable, it will toggle, otherwise you will be prompted to provide a new value.\n\n\n\nFirst Select asm\n\n\nExample switch to pseudo disassembly:\n\n\n\nPseudo disassembly disabled\n\n\n\n\n\nPseudo disassembly enabled\n\n\nFollowing are some example of eval variable related to disassembly."
  },
  {
    "href": "src/visual_mode/visual_disassembly.html#examples",
    "title": "18  Visual Disassembly",
    "section": "18.11 Examples",
    "text": "18.11.0.1 asm.arch: Change Architecture && asm.bits: Word size in bits at assembler\nYou can view the list of all arch using e asm.arch=?\ne asm.arch=dalvik\n0x00404870      31ed4989       cmp-long v237, v73, v137\n0x00404874      d15e4889       rsub-int v14, v5, 0x8948\n0x00404878      e24883e4       ushr-int/lit8 v72, v131, 0xe4\n0x0040487c      f0505449c7c0   +invoke-object-init-range {}, method+18772 ;[0]\n0x00404882      90244100       add-int v36, v65, v0\ne asm.bits=16\n0000:4870      31ed           xor bp, bp\n0000:4872      49             dec cx\n0000:4873      89d1           mov cx, dx\n0000:4875      5e             pop si\n0000:4876      48             dec ax\n0000:4877      89e2           mov dx, sp\nThis latest operation can also be done using & in Visual mode.\n\n\n18.11.0.2 asm.pseudo: Enable pseudo syntax\ne asm.pseudo=true\n0x00404870      31ed           ebp = 0\n0x00404872      4989d1         r9 = rdx\n0x00404875      5e             pop rsi\n0x00404876      4889e2         rdx = rsp\n0x00404879      4883e4f0       rsp &= 0xfffffffffffffff0\n\n\n18.11.0.3 asm.syntax: Select assembly syntax (intel, att, masm…)\ne asm.syntax=att\n0x00404870      31ed           xor %ebp, %ebp\n0x00404872      4989d1         mov %rdx, %r9\n0x00404875      5e             pop %rsi\n0x00404876      4889e2         mov %rsp, %rdx\n0x00404879      4883e4f0       and $0xfffffffffffffff0, %rsp\n\n\n18.11.0.4 asm.describe: Show opcode description\ne asm.describe=true\n0x00404870  xor ebp, ebp   ; logical exclusive or\n0x00404872  mov r9, rdx    ; moves data from src to dst\n0x00404875  pop rsi        ; pops last element of stack and stores the result in argument\n0x00404876  mov rdx, rsp   ; moves data from src to dst\n0x00404879  and rsp, -0xf  ; binary and operation between src and dst, stores result on dst"
  },
  {
    "href": "src/visual_mode/visual_assembler.html",
    "title": "19  Visual Assembler",
    "section": "",
    "text": "You can use Visual Mode to assemble code (patch) using A. For example, let’s xor the EAX register instead of EBP register, here. To assemble, seek to the location you want to patch and press A.\n\n\n\nBefore\n\n\nNotice the preview of the disassembly and arrows. After assembling the instruction, you can see that the branch reference lines have been changed, and it is now pointing to the offset of the newly assembled jne instruction:\n\n\n\nAfter\n\n\nYou need to open the file in writing mode (rizin -w or oo+) in order to patch the file. You can also use the cache mode: e io.cache=true and wc?.\nRemember that patching files in debug mode only patches the memory, not the file.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/visual_mode/visual_configuration_editor.html",
    "title": "20  Visual Configuration Editor",
    "section": "",
    "text": "Ve or e in visual mode allows you to edit rizin configuration visually. For example, if you want to change the assembly display just select asm in the list and choose your assembly display flavor.\n\n\n\nFirst Select asm\n\n\nExample switch to pseudo disassembly:\n\n\n\nPseudo disassembly disabled\n\n\n\n\n\nPseudo disassembly enabled\n\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/visual_mode/visual_panels.html#concept",
    "title": "21  Visual Panels",
    "section": "21.1 Concept",
    "text": "Visual Panels is characterized by the following core functionalities:\n\nSplit Screen\nDisplay multiple screens such as Symbols, Registers, Stack, as well as custom panels\nMenu will cover all those commonly used commands for you so that you don’t have to memorize any of them\n\nCUI met some useful GUI as the menu, that is Visual Panels.\nPanels can be accessed by using v or by using ! from the visual mode."
  },
  {
    "href": "src/visual_mode/visual_panels.html#overview",
    "title": "21  Visual Panels",
    "section": "21.2 Overview",
    "text": "Panels Overview"
  },
  {
    "href": "src/visual_mode/visual_panels.html#commands",
    "title": "21  Visual Panels",
    "section": "21.3 Commands",
    "text": "|Visual Ascii Art Panels:\n| |      split the current panel vertically\n| -      split the current panel horizontally\n| :      run rizin command in prompt\n| ;      add/remove comment\n| _      start the hud input mode\n| \\      show the user-friendly hud\n| ?      show this help\n| .      seek to PC or entrypoint\n| *      show decompiler in the current panel\n| \"      create a panel from the list and replace the current one\n| /      highlight the keyword\n| (      toggle snow\n| &      toggle cache\n| [1-9]  follow jmp/call identified by shortcut (like ;[1])\n| ' '    (space) toggle graph / panels\n| tab    go to the next panel\n| Enter  start Zoom mode\n| a      toggle auto update for decompiler\n| b      browse symbols, flags, configurations, classes, ...\n| c      toggle cursor\n| C      toggle color\n| d      define in the current address. Same as Vd\n| D      show disassembly in the current panel\n| e      change title and command of current panel\n| f      set/add filter keywords\n| F      remove all the filters\n| g      go/seek to given offset\n| G      go/seek to highlight\n| i      insert hex\n| hjkl   move around (left-down-up-right)\n| HJKL   move around (left-down-up-right) by page\n| m      select the menu panel\n| M      open new custom frame\n| n/N    seek next/prev function/flag/hit (scr.nkey)\n| p/P    rotate panel layout\n| q      quit, or close a tab\n| Q      close all the tabs and quit\n| r      toggle callhints/jmphints/leahints\n| R      randomize color palette (ecr)\n| s/S    step in / step over\n| t/T    tab prompt / close a tab\n| u/U    undo / redo seek\n| w      start Window mode\n| V      go to the graph mode\n| xX     show xrefs/refs of current function from/to data/code\n| z      swap current panel with the first one"
  },
  {
    "href": "src/visual_mode/visual_panels.html#basic-usage",
    "title": "21  Visual Panels",
    "section": "21.4 Basic Usage",
    "text": "Use tab to move around the panels until you get to the targeted panel. Then, use hjkl, just like in vim, to scroll the panel you are currently on. Use S and s to step over/in, and all the panels should be updated dynamically while you are debugging. Either in the Registers or Stack panels, you can edit the values by inserting hex. This will be explained later. While hitting tab can help you moving between panels, it is highly recommended to use m to open the menu. As usual, you can use hjkl to move around the menu and will find tons of useful stuff there. You can also press \" to quickly browse through the different options View offers and change the contents of the selected panel."
  },
  {
    "href": "src/visual_mode/visual_panels.html#split-screen",
    "title": "21  Visual Panels",
    "section": "21.5 Split Screen",
    "text": "| is for the vertical and - is for the horizontal split. You can delete any panel by pressing X.\nSplit panels can be resized from Window Mode, which is accessed with w."
  },
  {
    "href": "src/visual_mode/visual_panels.html#window-mode-commands",
    "title": "21  Visual Panels",
    "section": "21.6 Window Mode Commands",
    "text": "|Panels Window mode help:\n| ?      show this help\n| ??     show the user-friendly hud\n| Enter  start Zoom mode\n| c      toggle cursor\n| hjkl   move around (left-down-up-right)\n| JK     resize panels vertically\n| HL     resize panels horizontally\n| q      quit Window mode"
  },
  {
    "href": "src/visual_mode/visual_panels.html#edit-values",
    "title": "21  Visual Panels",
    "section": "21.7 Edit Values",
    "text": "Either in the Register or Stack panel, you can edit the values. Use c to activate cursor mode and you can move the cursor by pressing hjkl, as usual. Then, hit i, just like the insert mode of vim, to insert a value."
  },
  {
    "href": "src/visual_mode/visual_panels.html#tabs",
    "title": "21  Visual Panels",
    "section": "21.8 Tabs",
    "text": "Visual Panels also offer tabs to quickly access multiple forms of information easily. Press t to enter Tab Mode. All the tabs numbers will be visible in the top right corner.\nBy default you will have one tab and you can press t to create a new tab with the same panels and T to create a new panel from scratch.\nFor traversing through the tabs, you can type in the tab number while in Tab Mode.\nAnd pressing - deletes the tab you are in."
  },
  {
    "href": "src/visual_mode/visual_panels.html#saving-layouts",
    "title": "21  Visual Panels",
    "section": "21.9 Saving layouts",
    "text": "You can save your custom layout of your visual panels either by picking the option ‘Save Layout’ from the File menu of the menu bar or by running:\nv= test\nWhere test is the name with which you’d like to save it.\nYou can open a saved layout by passing the name as the parameter to v:\nv test\nMore about that can be found under v?."
  },
  {
    "href": "src/search_bytes/intro.html",
    "title": "22  Searching for Bytes",
    "section": "",
    "text": "The rizin search engine is based on work done by esteve, plus multiple features implemented on top of it. It supports multiple keyword searches, binary masks, and hexadecimal values. It automatically creates flags for search hit locations ease future referencing.\nSearch is initiated by / command.\n[0x00000000]> /?\n|Usage: /[!bf] [arg]Search stuff (see 'el search' for options)\n|Use io.va for searching in non virtual addressing spaces\n| / foo\\x00               search for string 'foo\\0'\n| /j foo\\x00              search for string 'foo\\0' (json output)\n| /! ff                   search for first occurrence not matching, command modifier\n| /!x 00                  inverse hexa search (find first byte != 0x00)\n| /+ /bin/sh              construct the string with chunks\n| //                      repeat last search\n| /a jmp eax              assemble opcode and search its bytes\n| /A jmp                  find analyzed instructions of this type (/A? for help)\n| /b                      search backwards, command modifier, followed by other command\n| /B                      search recognized RzBin headers\n| /c jmp [esp]            search for asm code matching the given string\n| /ce rsp,rbp             search for esil expressions matching\n| /C[ar]                  search for crypto materials\n| /d 101112               search for a deltified sequence of bytes\n| /e /E.F/i               match regular expression\n| /E esil-expr            offset matching given esil expressions %%= here\n| /f                      search forwards, command modifier, followed by other command\n| /F file [off] [sz]      search contents of file with offset and size\n| /g[g] [from]            find all graph paths A to B (/gg follow jumps, see search.count and\nanalysis.depth)\n| /h[t] [hash] [len]      find block matching this hash. See ph\n| /i foo                  search for string 'foo' ignoring case\n| /m magicfile            search for matching magic file (use blocksize)\n| /o [n]                  show offset of n instructions backward\n| /O [n]                  same as /o, but with a different fallback if analysis cannot be used\n| /p patternsize          search for pattern of given size\n| /P patternsize          search similar blocks\n| /r[erwx][?] sym.printf  analyze opcode reference an offset (/re for esil)\n| /R [grepopcode]         search for matching ROP gadgets, semicolon-separated\n| /s                      search for all syscalls in a region (EXPERIMENTAL)\n| /v[1248] value          look for an `cfg.bigendian` 32bit value\n| /V[1248] min max        look for an `cfg.bigendian` 32bit value in range\n| /w foo                  search for wide string 'f\\0o\\0o\\0'\n| /wi foo                 search for wide string ignoring case 'f\\0o\\0o\\0'\n| /x ff..33               search for hex string ignoring some nibbles\n| /x ff0033               search for hex string\n| /x ff43:ffd0            search for hexpair with mask\n| /z min max              search for strings of given size\nBecause everything is treated as a file in rizin, it does not matter whether you search in a socket, a remote device, in process memory, or a file.\nnote that ‘/’ starts multiline comment. It’s not for searching. type ’/’ to end comment.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/search_bytes/basic_searches.html",
    "title": "23  Basic Search",
    "section": "",
    "text": "A basic search for a plain text string in a file would be something like:\n$ rizin -q -c \"/ lib\" /bin/ls\nSearching 3 bytes from 0x00400000 to 0x0041ae08: 6c 69 62 \nhits: 9\n0x00400239 hit0_0 \"lib64/ld-linux-x86-64.so.2\"\n0x00400f19 hit0_1 \"libselinux.so.1\"\n0x00400fae hit0_2 \"librt.so.1\"\n0x00400fc7 hit0_3 \"libacl.so.1\"\n0x00401004 hit0_4 \"libc.so.6\"\n0x004013ce hit0_5 \"libc_start_main\"\n0x00416542 hit0_6 \"libs/\"\n0x00417160 hit0_7 \"lib/xstrtol.c\"\n0x00417578 hit0_8 \"lib\"\nAs can be seen from the output above, rizin generates a “hit” flag for every entry found. You can then use the ps command to see the strings stored at the offsets marked by the flags in this group, and they will have names of the form hit0_<index>:\n[0x00404888]> / ls\n...\n[0x00404888]> ps @ hit0_0\nlseek\nYou can search for wide-char strings (e.g., unicode letters) using the /w command:\n[0x00000000]> /w Hello\n0 results found.\nUsing Rizin, you can also automatically search for magic signatures in the file. This can be done using /m. The offset and the file format will be displayed after the search.\n[0x00000000]> /m\n-- 0 b1606\n0x00000000 1 JPEG image , EXIF standard\n0x0000000c 1 TIFF image data, big-endian\n0x000b1510 1 7-zip archive data, version 0.3\nTo perform a case-insensitive search for strings use /i:\n[0x0040488f]> /i Stallman\nSearching 8 bytes from 0x00400238 to 0x0040488f: 53 74 61 6c 6c 6d 61 6e\n[# ]hits: 004138 < 0x0040488f  hits = 0\nIt is possible to specify hexadecimal escape sequences in the search string by prepending them with “”:\n[0x00000000]> / \\x7FELF\nif, instead, you are searching for a string of hexadecimal values, you’re probably better of using the /x command:\n[0x00000000]> /x 7F454C46\nOnce the search is done, the results are stored in the searches flag space.\n[0x00000000]> fs\n0    0 . strings\n1    0 . symbols\n2    6 . searches\n\n[0x00000000]> f\n0x00000135 512 hit0_0\n0x00000b71 512 hit0_1\n0x00000bad 512 hit0_2\n0x00000bdd 512 hit0_3\n0x00000bfb 512 hit0_4\n0x00000f2a 512 hit0_5\nTo remove “hit” flags after you do not need them anymore, use the f- hit* command.\nOften, during long search sessions, you will need to launch the latest search more than once. You can use the // command to repeat the last search.\n[0x00000f2a]> //     ; repeat last search\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/search_bytes/configurating_the_search.html",
    "title": "24  Configuring Search Options",
    "section": "",
    "text": "The rizin search engine can be configured through several configuration variables, modifiable with the e command.\ne cmd.hit=x         ; rizin command to execute on every search hit\ne search.distance=0 ; search string distance\ne search.in=foo     ; specify search boundarie. Supported values are listed under e search.in=??\ne search.align=4    ; only show search results aligned by specified boundary.\ne search.from=0     ; start address\ne search.to=0       ; end address\ne search.asmstr=0   ; search for string instead of assembly\ne search.flags=true ; if enabled, create flags on hits\nThe search.align variable is used to limit valid search hits to certain alignment. For example, with e search.align=4 you will see only hits found at 4-bytes aligned offsets.\nThe search.flags boolean variable instructs the search engine to flag hits so that they can be referenced later. If a currently running search is interrupted with Ctrl-C keyboard sequence, current search position is flagged with search_stop.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/search_bytes/pattern_search.html",
    "title": "25  Pattern Matching Search",
    "section": "",
    "text": "The /p command allows you to apply repeated pattern searches on IO backend storage. It is possible to identify repeated byte sequences without explicitly specifying them. The only command’s parameter sets minimum detectable pattern length. Here is an example:\n[0x00000000]> /p 10\nThis command output will show different patterns found and how many times each of them is encountered.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/search_bytes/automation.html",
    "title": "26  Search Automation",
    "section": "",
    "text": "The cmd.hit configuration variable is used to define a rizin command to be executed when a matching entry is found by the search engine. If you want to run several commands, separate them with ;. Alternatively, you can arrange them in a separate script, and then invoke it as a whole with . script-file-name command. For example:\n[0x00404888]> e cmd.hit=\"p8 8\"\n[0x00404888]> / lib\nSearching 3 bytes from 0x00400000 to 0x0041ae08: 6c 69 62\nhits: 9\n0x00400239 hit4_0 \"lib64/ld-linux-x86-64.so.2\"\n31ed4989d15e4889\n0x00400f19 hit4_1 \"libselinux.so.1\"\n31ed4989d15e4889\n0x00400fae hit4_2 \"librt.so.1\"\n31ed4989d15e4889\n0x00400fc7 hit4_3 \"libacl.so.1\"\n31ed4989d15e4889\n0x00401004 hit4_4 \"libc.so.6\"\n31ed4989d15e4889\n0x004013ce hit4_5 \"libc_start_main\"\n31ed4989d15e4889\n0x00416542 hit4_6 \"libs/\"\n31ed4989d15e4889\n0x00417160 hit4_7 \"lib/xstrtol.c\"\n31ed4989d15e4889\n0x00417578 hit4_8 \"lib\"\n31ed4989d15e4889\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/search_bytes/backward_search.html",
    "title": "27  Searching Backwards",
    "section": "",
    "text": "Sometimes you want to find a keyword backwards. This is, before the current offset, to do this you can seek back and search forward by adding some search.from/to restrictions, or use the /b command.\n[0x100001200]> / nop\n0x100004b15 hit0_0 .STUWabcdefghiklmnopqrstuvwxbin/ls.\n0x100004f50 hit0_1 .STUWabcdefghiklmnopqrstuwx1] [file .\n[0x100001200]> /b nop\n[0x100001200]> s 0x100004f50p\n[0x100004f50]> /b nop\n0x100004b15 hit2_0 .STUWabcdefghiklmnopqrstuvwxbin/ls.\n[0x100004f50]>\nNote that /b is doing the same as /, but backward, so what if we want to use /x backward? We can use /bx, and the same goes for other search subcommands:\n[0x100001200]> /x 90\n0x100001a23 hit1_0 90\n0x10000248f hit1_1 90\n0x1000027b2 hit1_2 90\n0x100002b2e hit1_3 90\n0x1000032b8 hit1_4 90\n0x100003454 hit1_5 90\n0x100003468 hit1_6 90\n0x10000355b hit1_7 90\n0x100003647 hit1_8 90\n0x1000037ac hit1_9 90\n0x10000389c hit1_10 90\n0x100003c5c hit1_11 90\n\n[0x100001200]> /bx 90\n[0x100001200]> s 0x10000355b\n[0x10000355b]> /bx 90\n0x100003468 hit3_0 90\n0x100003454 hit3_1 90\n0x1000032b8 hit3_2 90\n0x100002b2e hit3_3 90\n0x1000027b2 hit3_4 90\n0x10000248f hit3_5 90\n0x100001a23 hit3_6 90\n[0x10000355b]>\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/search_bytes/search_in_assembly.html",
    "title": "28  Assembler Search",
    "section": "",
    "text": "If you want to search for a certain assembler opcodes, you can use /a commands.\nThe command /ad/ jmp [esp] searches for the specified category of assembly mnemonic:\n[0x00404888]> /ad/ jmp qword [rdx]\nf hit_0 @ 0x0040e50d   # 2: jmp qword [rdx]\nf hit_1 @ 0x00418dbb   # 2: jmp qword [rdx]\nf hit_2 @ 0x00418fcb   # 3: jmp qword [rdx]\nf hit_3 @ 0x004196ab   # 6: jmp qword [rdx]\nf hit_4 @ 0x00419bf3   # 3: jmp qword [rdx]\nf hit_5 @ 0x00419c1b   # 3: jmp qword [rdx]\nf hit_6 @ 0x00419c43   # 3: jmp qword [rdx]\nThe command /a jmp eax assembles a string to machine code, and then searches for the resulting bytes:\n[0x00404888]> /a jmp eax\nhits: 1\n0x004048e7 hit3_0 ffe00f1f8000000000b8\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/search_bytes/searching_aes_keys.html",
    "title": "29  Searching for AES Keys",
    "section": "",
    "text": "Thanks to Victor Muñoz, rizin now has support of the algorithm he developed, capable of finding expanded AES keys with /Ca command. It searches from current seek position up to the search.distance limit, or until end of file is reached. You can interrupt current search by pressing Ctrl-C. For example, to look for AES keys in physical memory of your system:\n$ sudo rizin /dev/mem\n[0x00000000]> /ca\n0 AES keys found\nIf you are simply looking for plaintext AES keys in your binary, /Ca will not find them, but you might want to search with is~AES instead if the programmer left those hints for you:\n[0x00000000]> /Ca\nSearching 0 byte in [0x100000-0x1f0000]\nhits: 0\nSearching 0 byte in [0x196e4-0x1b91c]\nhits: 0\nSearching 0 byte in [0x194b4-0x196e4]\nhits: 0\nSearching 0 byte in [0x8000-0x114b4]\nhits: 0\n[0x00000000]> is~AES\n010 0x000096d4 0x000196d4 GLOBAL    OBJ   16 AES_KEY\nOther than that, AES keys might show up in different ways in the binary: encrypted, hidden by another encrypting routine, so there’s no absolute way other than understanding the binary being analyzed. For instance, p=e might give some hints if high(er) entropy sections are found trying to cover up a hardcoded secret. As an example on entropy searching, since rizin 3.2.0, there’s the possibility to delimit entropy sections for later use like so:\n[0x00000000]> b\n0x100\n[0x00000000]> b 4096\n[0x00000000]> /s\n0x00100000 - 0x00101000 ~ 5.556094\n0x014e2c88 - 0x014e3c88 ~ 0.000000\n0x01434374 - 0x01435374 ~ 6.332087\n0x01435374 - 0x0144c374 ~ 3.664636\n0x0144c374 - 0x0144d374 ~ 1.664368\n0x0144d374 - 0x0144f374 ~ 4.229199\n0x0144f374 - 0x01451374 ~ 2.000000\n(...)\n[0x00000000]> /s*\nf entropy_section_0 0x00001000 0x00100000\nf entropy_section_1 0x00001000 0x014e2c88\nf entropy_section_2 0x00001000 0x01434374\nf entropy_section_3 0x00017000 0x01435374\nf entropy_section_4 0x00001000 0x0144c374\nf entropy_section_5 0x00002000 0x0144d374\nf entropy_section_6 0x00002000 0x0144f374\nThe blocksize is increased to 4096 bytes from the default 100 bytes so that the entropy search /s can work on reasonably sized chunks for entropy analysis. The sections flags can be applied with the dot operator, ./s* and then looped through px 32 @@f:entropy*.\nMoreover AES keys might be referenced from strings or pointed from the imports, for instance, so the / and other search-related commands can come in handy in this regard.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/disassembling/intro.html",
    "title": "30  Disassembling",
    "section": "",
    "text": "Disassembling in rizin is just a way to represent an array of bytes. It is handled as a special print mode within p command.\nIn the old times, when the rizin core was smaller, the disassembler was handled by an external rsc file. That is, rizin first dumped current block into a file, and then simply called objdump configured to disassemble for Intel, ARM or other supported architectures.\nIt was a working and unix friendly solution, but it was inefficient as it repeated the same expensive actions over and over, because there were no caches. As a result, scrolling was terribly slow.\nSo there was a need to create a generic disassembler library to support multiple plugins for different architectures. We can list the current loaded plugins with\n$ rz-asm -L\nOr from inside rizin:\n> e asm.arch=??\nThis was many years before capstone appeared. So rizin was using udis86 and olly disassemblers, many gnu (from binutils).\nNowadays, the disassembler support is one of the basic features of rizin. It now has many options, endianness, including target architecture flavor and disassembler variants, among other things.\nTo see the disassembly, use the pd command. It accepts a numeric argument to specify how many opcodes of current block you want to see. Most of the commands in rizin consider the current block size as the default limit for data input. If you want to disassemble more bytes, set a new block size using the b command.\n[0x00000000]> b 100    ; set block size to 100\n[0x00000000]> pd       ; disassemble 100 bytes\n[0x00000000]> pd 3     ; disassemble 3 opcodes\n[0x00000000]> pD 30    ; disassemble 30 bytes\nYou can also pass negative numbers as the numeric argument, if you want to disassemble something that lies before the current offset:\n[0x00005bc0]> pd -2\n            0x00005bb8      ret\n            0x00005bb9      nop dword [rax]\n[0x00005bc0]> pd 2\n            ;-- entry.fini0:\n            0x00005bc0      endbr64\n            0x00005bc4      cmp byte [0x000232c8], 0\nThe pD command works like pd but accepts the number of input bytes as its argument, instead of the number of opcodes.\nYou can also get information about the pointer chains using the command pdp. This can be helpful while dealing with ROP chains.\nThe “pseudo” syntax may be somewhat easier for a human to understand than the default assembler notations. But it can become annoying if you read lots of code. To play with it:\n[0x00405e1c]> e asm.pseudo=true\n[0x00405e1c]> pd 3\n          ; JMP XREF from 0x00405dfa (fcn.00404531)\n          0x00405e1c    488b9424a80. rdx = [rsp+0x2a8]\n          0x00405e24    64483314252. rdx ^= [fs:0x28]\n          0x00405e2d    4889d8       rax = rbx\n\n[0x00405e1c]> e asm.syntax=intel\n[0x00405e1c]> pd 3\n          ; JMP XREF from 0x00405dfa (fcn.00404531)\n          0x00405e1c    488b9424a80. mov rdx, [rsp+0x2a8]\n          0x00405e24    64483314252. xor rdx, [fs:0x28]\n          0x00405e2d    4889d8       mov rax, rbx\n\n[0x00405e1c]> e asm.syntax=att\n[0x00405e1c]> pd 3\n          ; JMP XREF from 0x00405dfa (fcn.00404531)\n          0x00405e1c    488b9424a80. mov 0x2a8(%rsp), %rdx\n          0x00405e24    64483314252. xor %fs:0x28, %rdx\n          0x00405e2d    4889d8       mov %rbx, %rax\nAnd as always, you can print the disassembly in JSON using pdj and get more information about the other associated commands by running pd?.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/disassembling/adding_metadata.html",
    "title": "31  Adding Metadata to Disassembly",
    "section": "",
    "text": "The typical work involved in reversing binary files makes powerful annotation capabilities essential. Rizin offers multiple ways to store and retrieve such metadata.\nBy following common basic UNIX principles, it is easy to write a small utility in a scripting language which uses objdump, otool or any other existing utility to obtain information from a binary and to import it into rizin. For example, take a look at python-idb-based ida2rz.py which opens IDB files directly without IDA Pro installed. You can load the resulting file with the . (dot) command into the rizin:\n[0x00000000]> . file.rz\nThe C command is used to manage comments and data conversions. You can define a range of program’s bytes to be interpreted as either code, binary data or string. It is also possible to execute external code at every specified flag location in order to fetch some metadata, such as a comment, from an external file or database.\nThere are many different metadata manipulation commands, here is the glimpse of all of them:\n[0x00404cc0]> C?\n| Usage: C[-LCvsdfm*?][*?] [...]   # Metadata management\n| C                                              list meta info in human friendly form\n| C*                                             list meta info in rizin commands\n| C*.                                            list meta info of current offset in rizin commands\n| C- [len] [[@]addr]                             delete metadata at given address range\n| C.                                             list meta info of current offset in human friendly form\n| CC! [@addr]                                    edit comment with $EDITOR\n| CC[?] [-] [comment-text] [@addr]               add/remove comment\n| CC.[addr]                                      show comment in current address\n| CCa[-at]|[at] [text] [@addr]                   add/remove comment at given address\n| CCu [comment-text] [@addr]                     add unique comment\n| CF[sz] [fcn-sign..] [@addr]                    function signature\n| CL[-][*] [file:line] [addr]                    show or add 'code line' information (bininfo)\n| CS[-][space]                                   manage meta-spaces to filter comments, etc..\n| C[Cthsdmf]                                     list comments/types/hidden/strings/data/magic/formatted in human friendly form\n| C[Cthsdmf]*                                    list comments/types/hidden/strings/data/magic/formatted in rizin commands\n| Cd[-] [size] [repeat] [@addr]                  hexdump data array (Cd 4 10 == dword [10])\n| Cd. [@addr]                                    show size of data at current address\n| Cf[?][-] [sz] [0|cnt][fmt] [a0 a1...] [@addr]  format memory (see pf?)\n| Ch[-] [size] [@addr]                           hide data\n| Cm[-] [sz] [fmt..] [@addr]                     magic parse (see pm?)\n| Cs[?] [-] [size] [@addr]                       add string\n| Ct[?] [-] [comment-text] [@addr]               add/remove type analysis comment\n| Ct.[@addr]                                     show comment at current or specified address\n| Cv[bsr][?]                                     add comments to args\n| Cz[@addr]                                      add string (see Cs?)\nSimply to add the comment to a particular line/address you can use Ca command:\n[0x00000000]> CCa 0x0000002 this guy seems legit\n[0x00000000]> pd 2\n0x00000000    0000         add [rax], al\n;      this guy seems legit\n0x00000002    0000         add [rax], al\nThe C? family of commands lets you mark a range as one of several kinds of types. Three basic types are: code (disassembly is done using asm.arch), data (an array of data elements) or string. Use the Cs command to define a string, use the Cd command for defining an array of data elements, and use the Cf command to define more complex data structures like structs.\nAnnotating data types is most easily done in visual mode, using the “d” key, short for “data type change”. First, use the cursor to select a range of bytes (press c key to toggle cursor mode and use HJKL keys to expand selection), then press ‘d’ to get a menu of possible actions/types. For example, to mark the range as a string, use the ‘s’ option from the menu. You can achieve the same result from the shell using the Cs command:\n[0x00000000]> f string_foo @ 0x800\n[0x00000000]> Cs 10 @ string_foo\nThe Cf command is used to define a memory format string (the same syntax used by the pf command). Here’s an example:\n[0x7fd9f13ae630]> Cf 16 2xi foo bar\n[0x7fd9f13ae630]> pd\n;-- rip:\n0x7fd9f13ae630 format 2xi foo bar {\n0x7fd9f13ae630 [0] {\n foo : 0x7fd9f13ae630 = 0xe8e78948\n bar : 0x7fd9f13ae634 = 14696\n}\n0x7fd9f13ae638 [1] {\n foo : 0x7fd9f13ae638 = 0x8bc48949\n bar : 0x7fd9f13ae63c = 571928325\n}\n} 16\n0x7fd9f13ae633    e868390000   call 0x7fd9f13b1fa0\n0x7fd9f13ae638    4989c4       mov r12, rax\nThe [sz] argument to Cf is used to define how many bytes the struct should take up in the disassembly, and is completely independent from the size of the data structure defined by the format string. This may seem confusing, but has several uses. For example, you may want to see the formatted structure displayed in the disassembly, but still have those locations be visible as offsets and with raw bytes. Sometimes, you find large structures, but only identified a few fields, or only interested in specific fields. Then, you can tell rizin to display only those fields, using the format string and using ‘skip’ fields, and also have the disassembly continue after the entire structure, by giving it full size using the sz argument.\nUsing Cf, it’s easy to define complex structures with simple one-liners. See pf? for more information. Remember that all these C commands can also be accessed from the visual mode by pressing the d (data conversion) key. Note that unlike t commands Cf doesn’t change analysis results. It is only a visual boon.\nSometimes just adding a single line of comments is not enough, in this case rizin allows you to create a link for a particular text file. You can use it with CC, command or by pressing , key in the visual mode. This will open an $EDITOR to create a new file, or if filename does exist, just will create a link. It will be shown in the disassembly comments:\n[0x00003af7 11% 290 /bin/ls]> pd $r @ main+55 # 0x3af7\n│0x00003af7  call sym.imp.setlocale        ;[1] ; ,(locale-help.txt) ; char *setlocale(int category, const char *locale)\n│0x00003afc  lea rsi, str.usr_share_locale ; 0x179cc ; \"/usr/share/locale\"\n│0x00003b03  lea rdi, [0x000179b2]         ; \"coreutils\"\n│0x00003b0a  call sym.imp.bindtextdomain   ;[2] ; char *bindtextdomain(char *domainname, char *dirname)\nNote ,(locale-help.txt) appeared in the comments, if we press , again in the visual mode, it will open the file. Using this mechanism we can create a long descriptions of some particular places in disassembly, link datasheets or related articles.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/disassembling/esil.html#using-esil",
    "title": "32  ESIL",
    "section": "32.1 Using ESIL",
    "text": "rizin’s visual mode is great to inspect the ESIL evaluations.\nThere are 3 environment variables that are important for watching what a program does:\n[0x00000000]> e emu.str=true\nasm.emu tells rizin if you want ESIL information to be displayed. If it is set to true, you will see comments appear to the right of your disassembly that tell you how the contents of registers and memory addresses are changed by the current instruction. For example, if you have an instruction that subtracts a value from a register it tells you what the value was before and what it becomes after. This is super useful so you don’t have to sit there yourself and track which value goes where.\nOne problem with this is that it is a lot of information to take in at once and sometimes you simply don’t need it. rizin has a nice compromise for this. That is what the emu.str variable is for (asm.emustr on <= 2.2). Instead of this super verbose output with every register value, this only adds really useful information to the output, e.g., strings that are found at addresses a program uses or whether a jump is likely to be taken or not.\nThe third important variable is asm.esil. This switches your disassembly to no longer show you the actual disassembled instructions, but instead now shows you corresponding ESIL expressions that describe what the instruction does. So if you want to take a look at how instructions are expressed in ESIL simply set “asm.esil” to true.\n[0x00000000]> e asm.esil=true\nIn visual mode you can also toggle this by simply typing O."
  },
  {
    "href": "src/disassembling/esil.html#esil-commands",
    "title": "32  ESIL",
    "section": "32.2 ESIL Commands",
    "text": "“ae” : Evaluate ESIL expression.\n\n[0x00000000]> \"ae 1,1,+\"\n0x2\n[0x00000000]>\n\n“aes” : ESIL Step.\n\n[0x00000000]> aes\n[0x00000000]>10aes\n\n“aeso” : ESIL Step Over.\n\n[0x00000000]> aeso\n[0x00000000]>10aeso\n\n“aesu” : ESIL Step Until.\n\n[0x00001000]> aesu 0x1035\nADDR BREAK\n[0x00001019]>\n\n“ar” : Show/modify ESIL registry.\n\n[0x00001ec7]> ar r_00 = 0x1035\n[0x00001ec7]> ar r_00\n0x00001035\n[0x00001019]>\n\n32.2.1 ESIL Instruction Set\nHere is the complete instruction set used by the ESIL VM:\n\n\n\n\n\n\n\n\n\n\nESIL Opcode\nOperands\nName\nOperation\nexample\n\n\n\n\nTRAP\nsrc\nTrap\nTrap signal\n\n\n\n\\(** | src | Syscall | syscall | **\\)$\nsrc\nInstruction address\nGet address of current instructionstack=instruction address\n\n\n\n==\nsrc,dst\nCompare\nstack = (dst == src) ;  update_eflags(dst - src)\n\n\n\n<\nsrc,dst\nSmaller (signed comparison)\nstack = (dst < src) ;  update_eflags(dst - src)\n[0x0000000]> “ae 1,5,<” 0x0> “ae 5,5”0x0”\n\n\n<=\nsrc,dst\nSmaller or Equal (signed comparison)\nstack = (dst <= src) ;  update_eflags(dst - src)\n[0x0000000]> “ae 1,5,<” 0x0> “ae 5,5”0x1”\n\n\n>\nsrc,dst\nBigger (signed comparison)\nstack = (dst > src) ;  update_eflags(dst - src)\n> “ae 1,5,>”0x1> “ae 5,5,>”0x0\n\n\n>=\nsrc,dst\nBigger or Equal (signed comparison)\nstack = (dst >= src) ;  update_eflags(dst - src)\n> “ae 1,5,>=”0x1> “ae 5,5,>=”0x1\n\n\n<<\nsrc,dst\nShift Left\nstack = dst << src\n> “ae 1,1,<<”0x2> “ae 2,1,<<”0x4\n\n\n>>\nsrc,dst\nShift Right\nstack = dst >> src\n> “ae 1,4,>>”0x2> “ae 2,4,>>”0x1\n\n\n<<<\nsrc,dst\nRotate Left\nstack=dst ROL src\n> “ae 31,1,<<<”0x80000000> “ae 32,1,<<<”0x1\n\n\n>>>\nsrc,dst\nRotate Right\nstack=dst ROR src\n> “ae 1,1,>>>”0x80000000> “ae 32,1,>>>”0x1\n\n\n&\nsrc,dst\nAND\nstack = dst & src\n> “ae 1,1,&”0x1> “ae 1,0,&”0x0> “ae 0,1,&”0x0> “ae 0,0,&”0x0\n\n\n|\nsrc,dst\nOR\nstack = dst | src\n> “ae 1,1,|”0x1> “ae 1,0,|”0x1> “ae 0,1,|”0x1> “ae 0,0,|”0x0\n\n\n^\nsrc,dst\nXOR\nstack = dst ^src\n> “ae 1,1,^”0x0> “ae 1,0,^”0x1> “ae 0,1,^”0x1> “ae 0,0,^”0x0\n\n\n+\nsrc,dst\nADD\nstack = dst + src\n> “ae 3,4,+”0x7> “ae 5,5,+”0xa\n\n\n-\nsrc,dst\nSUB\nstack = dst - src\n> “ae 3,4,-”0x1> “ae 5,5,-”0x0> “ae 4,3,-”0xffffffffffffffff\n\n\n*\nsrc,dst\nMUL\nstack = dst * src\n> “ae 3,4,*”0xc> “ae 5,5,*”0x19\n\n\n/\nsrc,dst\nDIV\nstack = dst / src\n> “ae 2,4,/”0x2> “ae 5,5,/”0x1> “ae 5,9,/”0x1\n\n\n%\nsrc,dst\nMOD\nstack = dst % src\n> “ae 2,4,%”0x0> “ae 5,5,%”0x0> “ae 5,9,%”0x4\n\n\n~\nbits,src\nSIGNEXT\nstack = src sign extended\n> “ae 8,0x80,~”0xffffffffffffff80\n\n\n~/\nsrc,dst\nSIGNED DIV\nstack = dst / src (signed)\n> “ae 2,-4,~/”0xfffffffffffffffe\n\n\n~%\nsrc,dst\nSIGNED MOD\nstack = dst % src (signed)\n> “ae 2,-5,~%”0xffffffffffffffff\n\n\n!\nsrc\nNEG\nstack = !!!src\n> “ae 1,!”0x0> “ae 4,!”0x0> “ae 0,!”0x1\n\n\n++\nsrc\nINC\nstack = src++\n> ar r_00=0;ar r_000x00000000> “ae r_00,++”0x1> ar r_000x00000000> “ae 1,++”0x2\n\n\n–\nsrc\nDEC\nstack = src–\n> ar r_00=5;ar r_000x00000005> “ae r_00,–”0x4> ar r_000x00000005> “ae 5,–”0x4\n\n\n=\nsrc,reg\nEQU\nreg = src\n> “ae 3,r_00,=”> aer r_000x00000003> “ae r_00,r_01,=”> aer r_010x00000003\n\n\n+=\nsrc,reg\nADD eq\nreg = reg + src\n> ar r_01=5;ar r_00=0;ar r_000x00000000> “ae r_01,r_00,+=”> ar r_000x00000005> “ae 5,r_00,+=”> ar r_000x0000000a\n\n\n-=\nsrc,reg\nSUB eq\nreg = reg - src\n> “ae r_01,r_00,-=”> ar r_000x00000004> “ae 3,r_00,-=”> ar r_000x00000001\n\n\n*=\nsrc,reg\nMUL eq\nreg = reg * src\n> ar r_01=3;ar r_00=5;ar r_000x00000005> “ae r_01,r_00,*=”> ar r_000x0000000f> “ae 2,r_00,*=”> ar r_000x0000001e\n\n\n/=\nsrc,reg\nDIV eq\nreg = reg / src\n> ar r_01=3;ar r_00=6;ar r_000x00000006> “ae r_01,r_00,/=”> ar r_000x00000002> “ae 1,r_00,/=”> ar r_000x00000002\n\n\n%=\nsrc,reg\nMOD eq\nreg = reg % src\n> ar r_01=3;ar r_00=7;ar r_00 0x00000007 > “ae r_01,r_00,%=” > ar r_00 0x00000001 > ar r_00=9;ar r_00 0x00000009 > “ae 5,r_00,%=” > ar r_00 0x00000004\n\n\n<<=\nsrc,reg\nShift Left eq\nreg = reg << src\n> ar r_00=1;ar r_01=1;ar r_010x00000001> “ae r_00,r_01,<<=”> ar r_010x00000002> “ae 2,r_01,<<=”> ar r_010x00000008\n\n\n>>=\nsrc,reg\nShift Right eq\nreg = reg << src\n> ar r_00=1;ar r_01=8;ar r_010x00000008> “ae r_00,r_01,>>=”> ar r_010x00000004> “ae 2,r_01,>>=”> ar r_010x00000001\n\n\n&=\nsrc,reg\nAND eq\nreg = reg & src\n> ar r_00=2;ar r_01=6;ar r_010x00000006> “ae r_00,r_01,&=”> ar r_010x00000002> “ae 2,r_01,&=”> ar r_010x00000002> “ae 1,r_01,&=”> ar r_010x00000000\n\n\n|=\nsrc,reg\nOR eq\nreg = reg | src\n> ar r_00=2;ar r_01=1;ar r_010x00000001> “ae r_00,r_01,|=”> ar r_010x00000003> “ae 4,r_01,|=”> ar r_010x00000007\n\n\n^=\nsrc,reg\nXOR eq\nreg = reg ^ src\n> ar r_00=2;ar r_01=0xab;ar r_010x000000ab> “ae r_00,r_01,^=”> ar r_010x000000a9> “ae 2,r_01,^=”> ar r_010x000000ab\n\n\n++=\nreg\nINC eq\nreg = reg + 1\n> ar r_00=4;ar r_000x00000004> “ae r_00,++=”> ar r_000x00000005\n\n\n–=\nreg\nDEC eq\nreg = reg - 1\n> ar r_00=4;ar r_000x00000004> “ae r_00,–=”> ar r_000x00000003\n\n\n!=\nreg\nNOT eq\nreg = !reg\n> ar r_00=4;ar r_000x00000004> “ae r_00,!=”> ar r_000x00000000> “ae r_00,!=”> ar r_000x00000001\n\n\n—\n—\n—\n—\n———————————————-\n\n\n=[]=[*]=[1]=[2]=[4]=[8]\nsrc,dst\npoke\n*dst=src\n> “ae 0xdeadbeef,0x10000,=[4],”> pxw 4@0x100000x00010000 0xdeadbeef ….> “ae 0x0,0x10000,=[4],”> pxw 4@0x100000x00010000 0x00000000\n\n\n[][*][1][2][4][8]\nsrc\npeek\nstack=*src\n> w test@0x10000> “ae 0x10000,[4],”0x74736574> ar r_00=0x10000> “ae r_00,[4],”0x74736574\n\n\n|=[]|=[1]|=[2]|=[4]|=[8]\nreg\nnombre\ncode\n> >\n\n\nSWAP\n\nSwap\nSwap two top elements\nSWAP\n\n\nPICK\nn\nPick\nPick nth element from the top of the stack\n2,PICK\n\n\nRPICK\nm\nReverse Pick\nPick nth element from the base of the stack\n0,RPICK\n\n\nDUP\n\nDuplicate\nDuplicate top element in stack\nDUP\n\n\nNUM\n\nNumeric\nIf top element is a reference  (register name, label, etc), dereference it and push its real value\nNUM\n\n\nCLEAR\n\nClear\nClear stack\nCLEAR\n\n\nBREAK\n\nBreak\nStops ESIL emulation\nBREAK\n\n\nGOTO\nn\nGoto\nJumps to Nth ESIL word\nGOTO 5\n\n\nTODO\n\nTo Do\nStops execution (reason: ESIL expression not completed)\nTODO\n\n\n\n\n\n32.2.2 ESIL Flags\nESIL VM has an internal state flags that are read-only and can be used to export those values to the underlying target CPU flags. It is because the ESIL VM always calculates all flag changes, while target CPUs only update flags under certain conditions or at specific instructions.\nInternal flags are prefixed with $ character.\nz      - zero flag, only set if the result of an operation is 0\nb      - borrow, this requires to specify from which bit (example: $b4 - checks if borrow from bit 4)\nc      - carry, same like above (example: $c7 - checks if carry from bit 7)\no      - overflow\np      - parity\nr      - regsize ( asm.bits/8 )\ns      - sign\nds     - delay slot state\njt     - jump target\njs     - jump target set\n[0-9]* - Used to set flags and registers without having any side effects,\n         i.e. setting esil_cur, esil_old and esil_lastsz.\n         (example: \"$0,of,=\" to reset the overflow flag)"
  },
  {
    "href": "src/disassembling/esil.html#syntax-and-commands",
    "title": "32  ESIL",
    "section": "32.3 Syntax and Commands",
    "text": "A target opcode is translated into a comma separated list of ESIL expressions.\nxor eax, eax    ->    0,eax,=,1,zf,=\nMemory access is defined by brackets operation:\nmov eax, [0x80480]   ->   0x80480,[],eax,=\nDefault operand size is determined by size of operation destination.\nmovb $0, 0x80480     ->   0,0x80480,=[1]\nThe ? operator uses the value of its argument to decide whether to evaluate the expression in curly braces.\n\nIs the value zero? -> Skip it.\nIs the value non-zero? -> Evaluate it.\n\ncmp eax, 123  ->   123,eax,==,$z,zf,=\njz eax        ->   zf,?{,eax,eip,=,}\nIf you want to run several expressions under a conditional, put them in curly braces:\nzf,?{,eip,esp,=[],eax,eip,=,$r,esp,-=,}\nWhitespaces, newlines and other chars are ignored. So the first thing when processing a ESIL program is to remove spaces:\nesil = r_str_replace (esil, \" \", \"\", R_TRUE);\nSyscalls need special treatment. They are indicated by ‘$’ at the beginning of an expression. You can pass an optional numeric value to specify a number of syscall. An ESIL emulator must handle syscalls. See (r_esil_syscall)."
  },
  {
    "href": "src/disassembling/esil.html#arguments-order-for-non-associative-operations",
    "title": "32  ESIL",
    "section": "32.4 Arguments Order for Non-associative Operations",
    "text": "As discussed on IRC, the current implementation works like this:\na,b,-      b - a\na,b,/=     b /= a\nThis approach is more readable, but it is less stack-friendly.\n\n32.4.1 Special Instructions\nNOPs are represented as empty strings. As it was said previously, syscalls are marked by ‘\\(' command. For example, '0x80,\\)’. It delegates emulation from the ESIL machine to a callback which implements syscalls for a specific OS/kernel.\nTraps are implemented with the TRAP command. They are used to throw exceptions for invalid instructions, division by zero, memory read error, or any other needed by specific architectures.\n\n\n32.4.2 Quick Analysis\nHere is a list of some quick checks to retrieve information from an ESIL string. Relevant information will be probably found in the first expression of the list.\nindexOf('[')    -> have memory references\nindexOf(\"=[\")   -> write in memory\nindexOf(\"pc,=\") -> modifies program counter (branch, jump, call)\nindexOf(\"sp,=\") -> modifies the stack (what if we found sp+= or sp-=?)\nindexOf(\"=\")    -> retrieve src and dst\nindexOf(\":\")    -> unknown esil, raw opcode ahead\nindexOf(\"$\")    -> accesses internal esil vm flags ex: $z\nindexOf(\"$\")    -> syscall ex: 1,$\nindexOf(\"TRAP\") -> can trap\nindexOf('++')   -> has iterator\nindexOf('--')   -> count to zero\nindexOf(\"?{\")   -> conditional\nequalsTo(\"\")    -> empty string, aka nop (wrong, if we append pc+=x)\nCommon operations: * Check dstreg * Check srcreg * Get destination * Is jump * Is conditional * Evaluate * Is syscall\n\n\n32.4.3 CPU Flags\nCPU flags are usually defined as single bit registers in the RReg profile. They are sometimes found under the ‘flg’ register type.\n\n\n32.4.4 Variables\nProperties of the VM variables:\n\nThey have no predefined bit width. This way it should be easy to extend them to 128, 256 and 512 bits later, e.g. for MMX, SSE, AVX, Neon SIMD.\nThere can be unbound number of variables. It is done for SSA-form compatibility.\nRegister names have no specific syntax. They are just strings.\nNumbers can be specified in any base supported by RNum (dec, hex, oct, binary …).\nEach ESIL backend should have an associated RReg profile to describe the ESIL register specs.\n\n\n\n32.4.5 Bit Arrays\nWhat to do with them? What about bit arithmetic if use variables instead of registers?\n\n\n32.4.6 Arithmetic\n\nADD (“+”)\nMUL (“*”)\nSUB (“-”)\nDIV (“/”)\nMOD (“%”)\n\n\n\n32.4.7 Bit Arithmetic\n\nAND “&”\nOR “|”\nXOR “^”\nSHL “<<”\nSHR “>>”\nROL “<<<”\nROR “>>>”\nNEG “!”\n\n\n\n32.4.8 Floating Point Unit Support\nAt the moment of this writing, ESIL does not yet support FPU. But you can implement support for unsupported instructions using rz-pipe. Eventually we will get proper support for multimedia and floating point.\n\n\n32.4.9 Handling x86 REP Prefix in ESIL\nESIL specifies that the parsing control-flow commands must be uppercase. Bear in mind that some architectures have uppercase register names. The corresponding register profile should take care not to reuse any of the following:\n3,SKIP   - skip N instructions. used to make relative forward GOTOs\n3,GOTO   - goto instruction 3\nLOOP     - alias for 0,GOTO\nBREAK    - stop evaluating the expression\nSTACK    - dump stack contents to screen\nCLEAR    - clear stack\n\n32.4.9.1 Usage Example:\nrep cmpsb\ncx,!,?{,BREAK,},esi,[1],edi,[1],==,?{,BREAK,},esi,++,edi,++,cx,--,0,GOTO\n\n\n\n32.4.10 Unimplemented/Unhandled Instructions\nThose are expressed with the ‘TODO’ command. They act as a ‘BREAK’, but displays a warning message describing that an instruction is not implemented and will not be emulated. For example:\nfmulp ST(1), ST(0)      =>      TODO,fmulp ST(1),ST(0)\n\n\n32.4.11 ESIL Disassembly Example:\n[0x1000010f8]> e asm.esil=true\n[0x1000010f8]> pd $r @ entry0\n0x1000010f8    55           8,rsp,-=,rbp,rsp,=[8]\n0x1000010f9    4889e5       rsp,rbp,=\n0x1000010fc    4883c768     104,rdi,+=\n0x100001100    4883c668     104,rsi,+=\n0x100001104    5d           rsp,[8],rbp,=,8,rsp,+=\n0x100001105    e950350000   0x465a,rip,= ;[1]\n0x10000110a    55           8,rsp,-=,rbp,rsp,=[8]\n0x10000110b    4889e5       rsp,rbp,=\n0x10000110e    488d4668     rsi,104,+,rax,=\n0x100001112    488d7768     rdi,104,+,rsi,=\n0x100001116    4889c7       rax,rdi,=\n0x100001119    5d           rsp,[8],rbp,=,8,rsp,+=\n0x10000111a    e93b350000   0x465a,rip,= ;[1]\n0x10000111f    55           8,rsp,-=,rbp,rsp,=[8]\n0x100001120    4889e5       rsp,rbp,=\n0x100001123    488b4f60     rdi,96,+,[8],rcx,=\n0x100001127    4c8b4130     rcx,48,+,[8],r8,=\n0x10000112b    488b5660     rsi,96,+,[8],rdx,=\n0x10000112f    b801000000   1,eax,=\n0x100001134    4c394230     rdx,48,+,[8],r8,==,cz,?=\n0x100001138    7f1a         sf,of,!,^,zf,!,&,?{,0x1154,rip,=,} ;[2]\n0x10000113a    7d07         of,!,sf,^,?{,0x1143,rip,} ;[3]\n0x10000113c    b8ffffffff   0xffffffff,eax,= ;  0xffffffff\n0x100001141    eb11         0x1154,rip,= ;[2]\n0x100001143    488b4938     rcx,56,+,[8],rcx,=\n0x100001147    48394a38     rdx,56,+,[8],rcx,==,cz,?=\n\n\n32.4.12 Introspection\nTo ease ESIL parsing we should have a way to express introspection expressions to extract the data that we want. For example, we may want to get the target address of a jump. The parser for ESIL expressions should offer an API to make it possible to extract information by analyzing the expressions easily.\n>  ao~esil,opcode\nopcode: jmp 0x10000465a\nesil: 0x10000465a,rip,=\nWe need a way to retrieve the numeric value of ‘rip’. This is a very simple example, but there are more complex, like conditional ones. We need expressions to be able to get:\n\nopcode type\ndestination of a jump\ncondition depends on\nall regs modified (write)\nall regs accessed (read)\n\n\n\n32.4.13 API HOOKS\nIt is important for emulation to be able to setup hooks in the parser, so we can extend it to implement analysis without having to change it again and again. That is, every time an operation is about to be executed, a user hook is called. It can be used for example to determine if RIP is going to change, or if the instruction updates the stack. Later, we can split that callback into several ones to have an event-based analysis API that may be extended in JavaScript like this:\nesil.on('regset', function(){..\nesil.on('syscall', function(){esil.regset('rip'\nFor the API, see the functions hook_flag_read(), hook_execute() and hook_mem_read(). A callback should return true or 1 if you want to override the action that it takes. For example, to deny memory reads in a region, or voiding memory writes, effectively making it read-only. Return false or 0 if you want to trace ESIL expression parsing.\nOther operations require bindings to external functionalities to work. In this case, rz_ref and rz_io. This must be defined when initializing the ESIL VM.\n\nIo Get/Set\nOut ax, 44\n44,ax,:ou\nSelectors (cs,ds,gs…)\nMov eax, ds:[ebp+8]\nEbp,8,+,:ds,eax,="
  },
  {
    "href": "src/analysis/intro.html",
    "title": "33  Data and Code Analysis",
    "section": "",
    "text": "Rizin has a very rich set of commands and configuration options to perform data and code analysis, to extract useful information from a binary, like pointers, string references, basic blocks, opcode data, jump targets, cross-references, and much more. These operations are handled by the a (analyze) command family:\n|Usage: a[abdefFghoprxstc] [...]\n| aa[?]              analyze all (fcns + bbs) (aa0 to avoid sub renaming)\n| a8 [hexpairs]      analyze bytes\n| ab[b] [addr]       analyze block at given address\n| abb [len]          analyze N basic blocks in [len] (section.size by default)\n| abt [addr]         find paths in the bb function graph from current offset to given address\n| ac [cycles]        analyze which op could be executed in [cycles]\n| ad[?]              analyze data trampoline (wip)\n| ad [from] [to]     analyze data pointers to (from-to)\n| ae[?] [expr]       analyze opcode eval expression (see ao)\n| af[?]              analyze Functions\n| aF                 same as above, but using analysis.depth=1\n| ag[?] [options]    draw graphs in various formats\n| ah[?]              analysis hints (force opcode size, ...)\n| ai [addr]          address information (show perms, stack, heap, ...)\n| an [name] [@addr]  show/rename/create whatever flag/function is used at addr\n| ao[?] [len]        analyze Opcodes (or emulate it)\n| aO[?] [len]        Analyze N instructions in M bytes\n| ap                 find prelude for current offset\n| ar[?]              like 'dr' but for the esil vm. (registers)\n| as[?] [num]        analyze syscall using dbg.reg\n| av[?] [.]          show vtables\n| ax[?]              manage refs/xrefs (see also afx?)\nIn fact, a namespace is one of the biggest in rizin tool and allows to control very different parts of the analysis:\n\nCode flow analysis\nData references analysis\nUsing loaded symbols\nManaging different type of graphs, like CFG and call graph\nManage variables\nManage types\nEmulation using ESIL VM\nOpcode introspection\nObjects information, like virtual tables\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/analysis/code_analysis.html#analyze-functions",
    "title": "34  Code Analysis",
    "section": "34.1 Analyze functions",
    "text": "One of the most important “basic” analysis commands is the set of af subcommands. af means “analyze function”. Using this command you can either allow automatic analysis of the particular function or perform a completely manual one.\n[0x00000000]> af?\nUsage: af\n| af ([name]) ([addr])                  analyze functions (start at addr or $$)\n| afr ([name]) ([addr])                 analyze functions recursively\n| af+ addr name [type] [diff]           hand craft a function (requires afb+)\n| af- [addr]                            clean all function analysis data (or function at addr)\n| afa                                   analyze function arguments in a call (afal honors dbg.funcarg)\n| afb+ fcnA bbA sz [j] [f] ([t]( [d]))  add bb to function @ fcnaddr\n| afb[?] [addr]                         List basic blocks of given function\n| afbF([0|1])                           Toggle the basic-block 'folded' attribute\n| afB 16                                set current function as thumb (change asm.bits)\n| afC[lc] ([addr])@[addr]               calculate the Cycles (afC) or Cyclomatic Complexity (afCc)\n| afc[?] type @[addr]                   set calling convention for function\n| afd[addr]                             show function + delta for given offset\n| afF[1|0|]                             fold/unfold/toggle\n| afi [addr|fcn.name]                   show function(s) information (verbose afl)\n| afj [tableaddr] [count]               analyze function jumptable\n| afl[?] [ls*] [fcn name]               list functions (addr, size, bbs, name) (see afll)\n| afm name                              merge two functions\n| afM name                              print functions map\n| afn[?] name [addr]                    rename name for function at address (change flag too)\n| afna                                  suggest automatic name for current offset\n| afo[?j] [fcn.name]                    show address for the function name or current offset\n| afs[!] ([fcnsign])                    get/set function signature at current address (afs! uses cfg.editor)\n| afS[stack_size]                       set stack frame size for function at current address\n| afsr [function_name] [new_type]       change type for given function\n| aft[?]                                type matching, type propagation\n| afu addr                              resize and analyze function from current address until addr\n| afv[absrx]?                           manipulate args, registers and variables in function\n| afx                                   list function references\nYou can use afl to list the functions found by the analysis.\nThere are a lot of useful commands under afl such as aflj, which lists the function in JSON format and aflm, which lists the functions in the syntax found in makefiles.\nThere’s also afl=, which displays ASCII-art bars with function ranges.\nYou can find the rest of them under afl?.\nSome of the most challenging tasks while performing a function analysis are merge, crop, and resize. As with other analysis commands, you have two modes: semi-automatic and manual. For the semi-automatic, you can use afm <function name> to merge the current function with the one specified by name as an argument, aff to readjust the function after analysis changes or function edits, afu <address> to do the resize and analysis of the current function until the specified address.\nApart from those semi-automatic ways to edit/analyze the function, you can handcraft it in the manual mode with af+ command and edit basic blocks of it using afb commands. Before changing the basic blocks of the function it is recommended to check the already presented ones:\n[0x00003ac0]> afb\n0x00003ac0 0x00003b7f 01:001A 191 f 0x00003b7f\n0x00003b7f 0x00003b84 00:0000 5 j 0x00003b92 f 0x00003b84\n0x00003b84 0x00003b8d 00:0000 9 f 0x00003b8d\n0x00003b8d 0x00003b92 00:0000 5\n0x00003b92 0x00003ba8 01:0030 22 j 0x00003ba8\n0x00003ba8 0x00003bf9 00:0000 81\n\n34.1.1 Handcraft function\nbefore starting, let’s prepare a binary file first, for example:\nint code_block()\n{\n  int result = 0;\n\n  for(int i = 0; i < 10; ++i)\n    result += 1;\n\n  return result;\n}\nthen compile it with gcc -c example.c -m32 -O0 -fno-pie, we will get the object file example.o. open it with rizin.\nsince we haven’t analyzed it yet, the pdf command will not print out the disassembly here:\n$ rizin example.o\n[0x08000034]> pdf\np: Cannot find function at 0x08000034\n[0x08000034]> pd\n            ;-- section..text:\n            ;-- .text:\n            ;-- code_block:\n            ;-- eip:\n            0x08000034      55             push ebp                    ; [01] -r-x section size 41 named .text\n            0x08000035      89e5           mov ebp, esp\n            0x08000037      83ec10         sub esp, 0x10\n            0x0800003a      c745f8000000.  mov dword [ebp - 8], 0\n            0x08000041      c745fc000000.  mov dword [ebp - 4], 0\n        ,=< 0x08000048      eb08           jmp 0x8000052\n       .--> 0x0800004a      8345f801       add dword [ebp - 8], 1\n       :|   0x0800004e      8345fc01       add dword [ebp - 4], 1\n       :`-> 0x08000052      837dfc09       cmp dword [ebp - 4], 9\n       `==< 0x08000056      7ef2           jle 0x800004a\n            0x08000058      8b45f8         mov eax, dword [ebp - 8]\n            0x0800005b      c9             leave\n            0x0800005c      c3             ret\n\nour goal is to handcraft a function with the following structure\n\n\n\nanalyze_one\n\n\ncreate a function at 0x8000034 named code_block:\n[0x8000034]> af+ 0x8000034 code_block\nIn most cases, we use jump or call instructions as code block boundaries. so the range of first block is from 0x08000034 push ebp to 0x08000048 jmp 0x8000052. use afb+ command to add it.\n[0x08000034]> afb+ code_block 0x8000034 0x800004a-0x8000034 0x8000052\nnote that the basic syntax of afb+ is afb+ function_address block_address block_size [jump] [fail]. the final instruction of this block points to a new address(jmp 0x8000052), thus we add the address of jump target (0x8000052) to reflect the jump info.\nthe next block (0x08000052 ~ 0x08000056) is more likely an if conditional statement which has two branches. It will jump to 0x800004a if jle-less or equal, otherwise (the fail condition) jump to next instruction – 0x08000058.:\n[0x08000034]> afb+ code_block 0x8000052 0x8000058-0x8000052 0x800004a 0x8000058\nfollow the control flow and create the remaining two blocks (two branches) :\n[0x08000034]> afb+ code_block 0x800004a 0x8000052-0x800004a 0x8000052\n[0x08000034]> afb+ code_block 0x8000058 0x800005d-0x8000058\ncheck our work:\n[0x08000034]> afb\n0x08000034 0x0800004a 00:0000 22 j 0x08000052\n0x0800004a 0x08000052 00:0000 8 j 0x08000052\n0x08000052 0x08000058 00:0000 6 j 0x0800004a f 0x08000058\n0x08000058 0x0800005d 00:0000 5\n[0x08000034]> VV\n\n\n\nhandcraft_one\n\n\nThere are two very important commands for this: afc and afB. The latter is a must-know command for some platforms like ARM. It provides a way to change the “bitness” of a particular function by allowing to select between ARM and Thumb modes.\nafc on the other side, allows to manually specify function calling convention. You can find more information on its usage in calling_conventions."
  },
  {
    "href": "src/analysis/code_analysis.html#recursive-analysis",
    "title": "34  Code Analysis",
    "section": "34.2 Recursive analysis",
    "text": "There are 5 important program-wide half-automated analysis commands:\n\naab - perform basic-block analysis (“Nucleus” algorithm)\naac - analyze function calls from one (selected or current function)\naaf - analyze all function calls\naar - analyze data references\naad - analyze pointers to pointers references\n\nThose are only generic semi-automated reference searching algorithms. Rizin provides a wide choice of manual references’ creation of any kind. For this fine-grained control, you can use ax commands.\nUsage: ax[?d-l*]   # see also 'afx?'\n| ax              list refs\n| ax*             output rizin commands\n| ax addr [at]    add code ref pointing to addr (from curseek)\n| ax- [at]        clean all refs/refs from addr\n| ax-*            clean all refs/refs\n| axc addr [at]   add generic code ref\n| axC addr [at]   add code call ref\n| axg [addr]      show xrefs graph to reach current function\n| axg* [addr]     show xrefs graph to given address, use .axg*;aggv\n| axgj [addr]     show xrefs graph to reach current function in json format\n| axd addr [at]   add data ref\n| axq             list refs in quiet/human-readable format\n| axj             list refs in json format\n| axF [flg-glob]  find data/code references of flags\n| axm addr [at]   copy data/code references pointing to addr to also point to curseek (or at)\n| axt [addr]      find data/code references to this address\n| axf [addr]      find data/code references from this address\n| axv [addr]      list local variables read-write-exec references\n| ax. [addr]      find data/code references from and to this address\n| axff[j] [addr]  find data/code references from this function\n| axs addr [at]   add string ref\nThe most commonly used ax commands are axt and axf, especially as a part of various rz-pipe scripts. Let’s say we see the string in the data or a code section and want to find all places it was referenced from, we should use axt:\n[0x0001783a]> pd 2\n;-- str.02x:\n; STRING XREF from 0x00005de0 (sub.strlen_d50)\n; CODE XREF from 0x00017838 (str.._s_s_s + 7)\n0x0001783a     .string \"%%%02x\" ; len=7\n;-- str.src_ls.c:\n; STRING XREF from 0x0000541b (sub.free_b04)\n; STRING XREF from 0x0000543a (sub.__assert_fail_41f + 27)\n; STRING XREF from 0x00005459 (sub.__assert_fail_41f + 58)\n; STRING XREF from 0x00005f9e (sub._setjmp_e30)\n; CODE XREF from 0x0001783f (str.02x + 5)\n0x00017841 .string \"src/ls.c\" ; len=9\n[0x0001783a]> axt\nsub.strlen_d50 0x5de0 [STRING] lea rcx, str.02x\n(nofunc) 0x17838 [CODE] jae str.02x\nThere are also some useful commands under axt. Use axtg to generate rizin commands which will help you to create graphs according to the XREFs.\n[0x08048320]> s main\n[0x080483e0]> axtg\nagn 0x8048337 \"entry0 + 23\"\nagn 0x80483e0 \"main\"\nage 0x8048337 0x80483e0\nUse axt* to split the rizin commands and set flags on those corresponding XREFs.\nAlso under ax is axg, which finds the path between two points in the file by showing an XREFs graph to reach the location or function. For example:\n:> axg sym.imp.printf\n- 0x08048a5c fcn 0x08048a5c sym.imp.printf\n  - 0x080483e5 fcn 0x080483e0 main\n  - 0x080483e0 fcn 0x080483e0 main\n    - 0x08048337 fcn 0x08048320 entry0\n  - 0x08048425 fcn 0x080483e0 main\nUse axg* to generate rizin commands which will help you to create graphs using agn and age commands, according to the XREFs.\nApart from predefined algorithms to identify functions there is a way to specify a function prelude with a configuration option analysis.prelude. For example, like e analysis.prelude=0x554889e5 which means\npush rbp\nmov rbp, rsp\non x86_64 platform. It should be specified before any analysis commands."
  },
  {
    "href": "src/analysis/code_analysis.html#configuration",
    "title": "34  Code Analysis",
    "section": "34.3 Configuration",
    "text": "Rizin allows changing the behavior of almost any analysis stages or commands. There are different kinds of configuration options:\n\nFlow control\nBasic blocks control\nReferences control\nIO/Ranges\nJump tables analysis control\nPlatform/target-specific options\n\n\n34.3.1 Control flow configuration\nThe two most commonly used options for changing the behavior of control flow analysis in rizin are analysis.hasnext and analysis.jmp.after. The first one allows forcing rizin to continue the analysis after the end of the function, even if the next chunk of the code wasn’t called anywhere, thus analyzing all of the available functions. The latter one allows forcing rizin to continue the analysis even after unconditional jumps.\nIn addition to those we can also set analysis.jmp.indir to follow the indirect jumps, continuing analysis; analysis.pushret to analyze push ...; ret sequence as a jump; analysis.nopskip to skip the NOP sequences at a function beginning.\nFor now, rizin also allows you to change the maximum basic block size with analysis.bb.maxsize option . The default value just works in most use cases, but it’s useful to increase that for example when dealing with obfuscated code. Beware that some of the basic block control options may disappear in the future in favor of more automated ways to set those.\nFor some unusual binaries or targets, there is an option analysis.noncode. Rizin doesn’t try to analyze data sections as a code by default. But in some cases - malware, packed binaries, binaries for embedded systems, it is often a case. Thus - this option.\n\n\n34.3.2 Reference control\nThe most crucial options that change the analysis results drastically. Sometimes some can be disabled to save time and memory when analyzing big binaries.\n\nanalysis.jmp.ref - to allow references creation for unconditional jumps\nanalysis.jmp.cref - same, but for conditional jumps\nanalysis.datarefs - to follow the data references in code\nanalysis.refstr - search for strings in data references\nanalysis.strings - search for strings and creating references\n\nNote that strings references control is disabled by default because it increases the analysis time.\n\n\n34.3.3 Analysis ranges\nThere are a few options for this:\n\nanalysis.limits - enables the range limits for analysis operations\nanalysis.from - starting address of the limit range\nanalysis.to - the corresponding end of the limit range\nanalysis.in - specify search boundaries for analysis. You can set it to io.maps, io.sections.exec, dbg.maps and many more. For example:\n\nTo analyze a specific memory map with analysis.from and analysis.to, set analysis.in = dbg.maps.\nTo analyze in the boundaries set by analysis.from and analysis.to, set analysis.in=range.\nTo analyze in the current mapped segment or section, you can put analysis.in=bin.segment or analysis.in=bin.section, respectively.\nTo analyze in the current memory map, specify analysis.in=dbg.map.\nTo analyze in the stack or heap, you can set analysis.in=dbg.stack or analysis.in=dbg.heap.\nTo analyze in the current function or basic block, you can specify analysis.in=analysis.fcn or analysis.in=analysis.bb.\n\n\nPlease see e analysis.in=?? for the complete list.\n\n\n34.3.4 Jump tables\nJump tables are one of the trickiest targets in binary reverse engineering. There are hundreds of different types, the end result depending on the compiler/linker and LTO stages of optimization. Thus rizin allows enabling some experimental jump tables detection algorithms using analysis.jmp.tbl option. Eventually, algorithms moved into the default analysis loops once they start to work on every supported platform/target/test-case. Two more options can affect the jump tables analysis results too:\n\nanalysis.jmp.indir - follow the indirect jumps, some jump tables rely on them\nanalysis.datarefs - follow the data references, some jump tables use those\n\n\n\n34.3.5 Platform specific controls\nThere are two common problems when analyzing embedded targets: ARM/Thumb detection and MIPS GP value. In the case of ARM binaries rizin supports some auto-detection of ARM/Thumb mode switches, but beware that it uses partial ESIL emulation, thus slowing the analysis process. If you will not like the results, particular functions’ mode can be overridden with afB command.\nThe MIPS GP problem is even trickier. It is basic knowledge that GP value can be different not only for the whole program but also for some functions. To partially solve that there are options analysis.gp and analysis.gpfixed. The first one sets the GP value for the whole program or particular function. The latter allows to “constantify” the GP value if some code is willing to change its value, always resetting it if the case. Those are heavily experimental and might be changed in the future in favor of more automated analysis."
  },
  {
    "href": "src/analysis/code_analysis.html#visuals",
    "title": "34  Code Analysis",
    "section": "34.4 Visuals",
    "text": "One of the easiest way to see and check the changes of the analysis commands and variables is to perform scrolling in a Vv special visual mode, allowing functions preview:\n\n\n\nvv\n\n\nWhen we want to check how analysis changes affect the result in the case of big functions, we can use minimap instead, allowing us to see a bigger flow graph on the same screen size. To get into the minimap mode type VV then press p twice:\n\n\n\nvv2\n\n\nThis mode allows you to see the disassembly of each node separately, just navigate between them using the Tab key."
  },
  {
    "href": "src/analysis/code_analysis.html#analysis-hints",
    "title": "34  Code Analysis",
    "section": "34.5 Analysis hints",
    "text": "It is not an uncommon case that analysis results are not perfect even after you tried every single configuration option. This is where the “analysis hints” rizin mechanism comes in. It allows to override some basic opcode or meta-information properties, or even to rewrite the whole opcode string. These commands are located under ah namespace:\nUsage: ah[lba-]  Analysis Hints\n| ah?                show this help\n| ah? offset         show hint of given offset\n| ah                 list hints in a human-readable format\n| ah.                list hints in human-readable format from current offset\n| ah-                remove all hints\n| ah- offset [size]  remove hints at the given offset\n| ah* offset         list hints in rizin commands format\n| aha ppc @ 0x42     force arch ppc for all address >= 0x42 or until the next hint\n| aha 0 @ 0x84       disable the effect of arch hints for all address >= 0x84 or until the next hint\n| ahb 16 @ 0x42      force 16bit for all address >= 0x42 or until the next hint\n| ahb 0 @ 0x84       disable the effect of bits hints for all address >= 0x84 or until the next hint\n| ahc 0x804804       override call/jump address\n| ahd foo a0,33      replace opcode string\n| ahe 3,eax,+=       set vm analysis string\n| ahf 0x804840       override fallback address for call\n| ahF 0x10           set stackframe size at the current offset\n| ahh 0x804840       highlight this address offset in disasm\n| ahi[?] 10          define numeric base for immediates (2, 8, 10, 10u, 16, i, p, S, s)\n| ahj                list hints in JSON\n| aho call           change opcode type (see aho?) (deprecated, moved to \"ahd\")\n| ahp addr           set pointer hint\n| ahr val            set hint for the return value of a function\n| ahs 4              set opcode size=4\n| ahS jz             set asm.syntax=jz for this opcode\n| aht [?] <type>     Mark immediate as a type offset (deprecated, moved to \"aho\")\n| ahv val            change opcode's val field (useful to set jmptbl sizes in jmp rax)\nOne of the most common cases is to set a particular numeric base for immediates:\n[0x00003d54]> ahi?\nUsage: ahi [2|8|10|10u|16|bodhipSs] [@ offset]   Define numeric base\n| ahi <base>  set numeric base (2, 8, 10, 16)\n| ahi 10|d    set base to signed decimal (10), sign bit should depend on receiver size\n| ahi 10u|du  set base to unsigned decimal (11)\n| ahi b       set base to binary (2)\n| ahi o       set base to octal (8)\n| ahi h       set base to hexadecimal (16)\n| ahi i       set base to IP address (32)\n| ahi p       set base to htons(port) (3)\n| ahi S       set base to syscall (80)\n| ahi s       set base to string (1)\n\n[0x00003d54]> pd 2\n0x00003d54      0583000000     add eax, 0x83\n0x00003d59      3d13010000     cmp eax, 0x113\n[0x00003d54]> ahi d\n[0x00003d54]> pd 2\n0x00003d54      0583000000     add eax, 131\n0x00003d59      3d13010000     cmp eax, 0x113\n[0x00003d54]> ahi b\n[0x00003d54]> pd 2\n0x00003d54      0583000000     add eax, 10000011b\n0x00003d59      3d13010000     cmp eax, 0x113\nIt is notable that some analysis stages or commands add the internal analysis hints, which can be checked with ah command:\n[0x00003d54]> ah\n 0x00003d54 - 0x00003d54 => immbase=2\n[0x00003d54]> ah*\n ahi 2 @ 0x3d54\nSometimes we need to override jump or call address, for example in case of tricky relocation, which is unknown for rizin, thus we can change the value manually. The current analysis information about a particular opcode can be checked with ao command. We can use ahc command for performing such a change:\n[0x00003cee]> pd 2\n0x00003cee      e83d080100     call sub.__errno_location_530\n0x00003cf3      85c0           test eax, eax\n[0x00003cee]> ao\naddress: 0x3cee\nopcode: call 0x14530\nmnemonic: call\nprefix: 0\nid: 56\nbytes: e83d080100\nrefptr: 0\nsize: 5\nsign: false\ntype: call\ncycles: 3\nesil: 83248,rip,8,rsp,-=,rsp,=[],rip,=\njump: 0x00014530\ndirection: exec\nfail: 0x00003cf3\nstack: null\nfamily: cpu\nstackop: null\n[0x00003cee]> ahc 0x5382\n[0x00003cee]> pd 2\n0x00003cee      e83d080100     call sub.__errno_location_530\n0x00003cf3      85c0           test eax, eax\n[0x00003cee]> ao\naddress: 0x3cee\nopcode: call 0x14530\nmnemonic: call\nprefix: 0\nid: 56\nbytes: e83d080100\nrefptr: 0\nsize: 5\nsign: false\ntype: call\ncycles: 3\nesil: 83248,rip,8,rsp,-=,rsp,=[],rip,=\njump: 0x00005382\ndirection: exec\nfail: 0x00003cf3\nstack: null\nfamily: cpu\nstackop: null\n[0x00003cee]> ah\n 0x00003cee - 0x00003cee => jump: 0x5382\nAs you can see, despite the unchanged disassembly view the jump address in opcode was changed (jump option).\nIf anything of the previously described didn’t help, you can simply override shown disassembly with anything you like:\n[0x00003d54]> pd 2\n0x00003d54      0583000000     add eax, 10000011b\n0x00003d59      3d13010000     cmp eax, 0x113\n[0x00003d54]> \"ahd myopcode bla, foo\"\n[0x00003d54]> pd 2\n0x00003d54                     myopcode bla, foo\n0x00003d55      830000         add dword [rax], 0"
  },
  {
    "href": "src/analysis/variables.html#type-inference",
    "title": "35  Managing variables",
    "section": "35.1 Type inference",
    "text": "The type inference for local variables and arguments is well integrated with the command afta.\nLet’s see an example of this with a simple hello_world binary\n[0x000007aa]> pdf\n|           ;-- main:\n/ (fcn) sym.main 157\n| sym.main ();\n| ; var int local_20h @ rbp-0x20\n| ; var int local_1ch @ rbp-0x1c\n| ; var int local_18h @ rbp-0x18\n| ; var int local_10h @ rbp-0x10\n| ; var int local_8h @ rbp-0x8\n| ; DATA XREF from entry0 (0x6bd)\n| 0x000007aa  push rbp\n| 0x000007ab  mov rbp, rsp\n| 0x000007ae  sub rsp, 0x20\n| 0x000007b2  lea rax, str.Hello          ; 0x8d4 ; \"Hello\"\n| 0x000007b9  mov qword [local_18h], rax\n| 0x000007bd  lea rax, str.r2_folks       ; 0x8da ; \" r2-folks\"\n| 0x000007c4  mov qword [local_10h], rax\n| 0x000007c8  mov rax, qword [local_18h]\n| 0x000007cc  mov rdi, rax\n| 0x000007cf  call sym.imp.strlen         ; size_t strlen(const char *s)\n\nAfter applying afta\n\n[0x000007aa]> afta\n[0x000007aa]> pdf\n| ;-- main:\n| ;-- rip:\n/ (fcn) sym.main 157\n| sym.main ();\n| ; var size_t local_20h @ rbp-0x20\n| ; var size_t size @ rbp-0x1c\n| ; var char *src @ rbp-0x18\n| ; var char *s2 @ rbp-0x10\n| ; var char *dest @ rbp-0x8\n| ; DATA XREF from entry0 (0x6bd)\n| 0x000007aa  push rbp\n| 0x000007ab  mov rbp, rsp\n| 0x000007ae  sub rsp, 0x20\n| 0x000007b2  lea rax, str.Hello          ; 0x8d4 ; \"Hello\"\n| 0x000007b9  mov qword [src], rax\n| 0x000007bd  lea rax, str.r2_folks       ; 0x8da ; \" r2-folks\"\n| 0x000007c4  mov qword [s2], rax\n| 0x000007c8  mov rax, qword [src]\n| 0x000007cc  mov rdi, rax                ; const char *s\n| 0x000007cf  call sym.imp.strlen         ; size_t strlen(const char *s)\nIt also extracts type information from format strings like printf (\"fmt : %s , %u , %d\", ...), the format specifications are extracted from analysis/d/spec.sdb\nYou could create a new profile for specifying a set of format chars depending on different libraries/operating systems/programming languages like this :\nwin=spec\nspec.win.u32=unsigned int\nThen change your default specification to a newly created one using this config variable e analysis.spec=win\nFor more information about primitive and user-defined types support in rizin refer to types chapter."
  },
  {
    "href": "src/analysis/types.html#internal-representation",
    "title": "36  Types",
    "section": "36.1 Internal representation",
    "text": "To see the internal representation of the types you can use tk command:\n[0x000051c0]> tk~S1\nS1=struct\nstruct.S1=x,y,z\nstruct.S1.x=int32_t,0,3\nstruct.S1.x.meta=4\nstruct.S1.y=int32_t,12,4\nstruct.S1.y.meta=4\nstruct.S1.z=int32_t,28,0\nstruct.S1.z.meta=0\n[0x000051c0]>\nDefining primitive types requires an understanding of basic pf formats, you can find the whole list of format specifier in pf??:\n---------------------------------------------------\n| format | explanation                            |\n| ------ | -------------------------------------- |\n| b      | byte (unsigned)                        |\n| c      | char (signed byte)                     |\n| d      | 0x%%08x hexadecimal value (4 bytes)    |\n| f      | float value (4 bytes)                  |\n| i      | %%i integer value (4 bytes)            |\n| o      | 0x%%08o octal value (4 byte)           |\n| p      | pointer reference (2, 4 or 8 bytes)    |\n| q      | quadword (8 bytes)                     |\n| s      | 32bit pointer to string (4 bytes)      |\n| S      | 64bit pointer to string (8 bytes)      |\n| t      | UNIX timestamp (4 bytes)               |\n| T      | show Ten first bytes of buffer         |\n| u      | uleb128 (variable length)              |\n| w      | word (2 bytes unsigned short in hex)   |\n| x      | 0x%%08x hex value and flag (fd @ addr) |\n| X      | show formatted hexpairs                |\n| z      | \\0 terminated string                   |\n| Z      | \\0 terminated wide string              |\n---------------------------------------------------\n\nthere are basically 3 mandatory keys for defining basic data types: X=type type.X=format_specifier type.X.size=size_in_bits For example, let’s define UNIT, according to Microsoft documentation UINT is just equivalent of standard C unsigned int (or uint32_t in terms of TCC engine). It will be defined as:\nUINT=type\ntype.UINT=d\ntype.UINT.size=32\nNow there is an optional entry:\nX.type.pointto=Y\nThis one may only be used in case of pointer type.X=p, one good example is LPFILETIME definition, it is a pointer to _FILETIME which happens to be a structure. Assuming that we are targeting only 32-bit windows machine, it will be defined as the following:\nLPFILETIME=type\ntype.LPFILETIME=p\ntype.LPFILETIME.size=32\ntype.LPFILETIME.pointto=_FILETIME\nThis last field is not mandatory because sometimes the data structure internals will be proprietary, and we will not have a clean representation for it.\nThere is also one more optional entry:\ntype.UINT.meta=4\nThis entry is for integration with C parser and carries the type class information: integer size, signed/unsigned, etc.\n\n36.1.1 Structures\nThose are the basic keys for structs (with just two elements):\nX=struct\nstruct.X=a,b\nstruct.X.a=a_type,a_offset,a_number_of_elements\nstruct.X.b=b_type,b_offset,b_number_of_elements\nThe first line is used to define a structure called X, the second line defines the elements of X as comma-separated values. After that, we just define each element info.\nFor example. we can have a struct like this one:\nstruct _FILETIME {\n    DWORD dwLowDateTime;\n    DWORD dwHighDateTime;\n}\nassuming we have DWORD defined, the struct will look like this\n _FILETIME=struct\nstruct._FILETIME=dwLowDateTime,dwHighDateTime\nstruct._FILETIME.dwLowDateTime=DWORD,0,0\nstruct._FILETIME.dwHighDateTime=DWORD,4,0\nNote that the number of elements field is used in the case of arrays only to identify how many elements are in arrays, other than that it is zero by default.\n\n\n36.1.2 Unions\nUnions are defined exactly like structs the only difference is that you will replace the word struct with the word union.\n\n\n36.1.3 Function prototypes\nFunction prototype representation is the most detail-oriented and the most important one of them all. This is the one used directly for type matching\nX=func\nfunc.X.args=NumberOfArgs\nfunc.x.arg0=Arg_type,arg_name\n.\n.\n.\nfunc.X.ret=Return_type\nfunc.X.cc=calling_convention\nIt should be self-explanatory. Let’s do strncasecmp as an example for x86 arch for Linux machines. According to man pages, strncasecmp is defined as the following:\nint strcasecmp(const char *s1, const char *s2, size_t n);\nWhen converting it into its sdb representation it will look like the following:\nstrcasecmp=func\nfunc.strcasecmp.args=3\nfunc.strcasecmp.arg0=char *,s1\nfunc.strcasecmp.arg1=char *,s2\nfunc.strcasecmp.arg2=size_t,n\nfunc.strcasecmp.ret=int\nfunc.strcasecmp.cc=cdecl\nNote that the .cc part is optional and if it didn’t exist the default calling-convention for your target architecture will be used instead. There is one extra optional key\nfunc.x.noreturn=true/false\nThis key is used to mark functions that will not return once called, such as exit and _exit."
  },
  {
    "href": "src/analysis/calling_conventions.html",
    "title": "37  Calling Conventions",
    "section": "",
    "text": "Rizin uses calling conventions to help in identifying function formal arguments and return types. It is used also as a guide for basic function prototype and type propagation.\n[0x00000000]> afc?\nUsage: afc[agl?]\n| afc convention  Manually set calling convention for current function\n| afc             Show Calling convention for the Current function\n| afcr[j]         Show register usage for the current function\n| afca            Analyse function for finding the current calling convention\n| afcf[j] [name]  Prints return type function(arg1, arg2...), see afij\n| afck            List SDB details of call loaded calling conventions\n| afcl            List all available calling conventions\n| afco path       Open Calling Convention sdb profile from the given path\n| afcR            Register telescoping using the calling conventions order\n[0x00000000]>\nTo list all available calling conventions for current architecture using afcl command\n[0x00000000]> afcl\nswift\namd64\namd64syscall\nms\nreg\nThe default calling convention for a particular architecture/binary is defined with analysis.cc for user-mode calls and analysis.syscc for syscalls.\nTo display a function prototype of standard library functions you have the afcf command\n[0x00000000]> afcf printf\nint printf(const char *format)\n[0x00000000]> afcf fgets\nchar *fgets(char *s, int size, FILE *stream)\nAll this information is loaded via sdb under /librz/analysis/d/cc-[arch]-[bits].sdb\ndefault.cc=amd64\n\nms=cc\ncc.ms.name=ms\ncc.ms.arg1=rcx\ncc.ms.arg2=rdx\ncc.ms.arg3=r8\ncc.ms.arg3=r9\ncc.ms.argn=stack\ncc.ms.ret=rax\ncc.x.argi=rax is used to set the ith argument of this calling convention to register name rax\ncc.x.argn=stack means that all the arguments (or the rest of them in case there was argi for any i as counting number) will be stored in the stack from left to right\ncc.x.argn=stack_rev same as cc.x.argn=stack except for it means argument are passed right to left\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/analysis/vtables.html",
    "title": "38  Virtual Tables",
    "section": "",
    "text": "There is basic support of virtual tables parsing (RTTI and others). The most important thing before you start to perform such kind of analysis is to check if the analysis.cpp.abi option is set correctly and change it if needed.\nAll commands to work with virtual tables are located in the av namespace. Currently, the support is very basic, allowing you only to inspect parsed tables.\n|Usage: av[?jr*] C++ vtables and RTTI\n| av           search for vtables in data sections and show results\n| avj          like av, but as json\n| av*          like av, but as rizin commands\n| avr[j@addr]  try to parse RTTI at vtable addr (see analysis.cpp.abi)\n| avra[j]      search for vtables and try to parse RTTI at each of them\nThe main commands here are av and avr. av lists all virtual tables found when rizin opened the file. If you are not happy with the result you may want to try to parse a virtual table at a particular address with avr command. avra performs the search and parsing of all virtual tables in the binary, like rizin does during the file opening.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/analysis/syscalls.html",
    "title": "39  Syscalls",
    "section": "",
    "text": "Rizin allows manual search for assembly code looking like a syscall operation. For example on the ARM platform, usually, these are represented by the svc instruction, on the others, these can be different instructions, e.g. syscall on x86 PC.\n[0x0001ece0]> /ad/ svc\n...\n0x000187c2   # 2: svc 0x76\n0x000189ea   # 2: svc 0xa9\n0x00018a0e   # 2: svc 0x82\n...\nSyscalls detection is driven by asm.os, asm.bits, and asm.arch. Be sure to set those configuration options accordingly. You can use asl command to check if syscalls’ support is set up properly and as you expect. The command lists syscalls supported for your platform.\n[0x0001ece0]> asl\n...\nsd_softdevice_enable = 0x80.16\nsd_softdevice_disable = 0x80.17\nsd_softdevice_is_enabled = 0x80.18\n...\nIf you setup ESIL stack with aei or aeim, you can use /as command to search the addresses where particular syscalls were found and list them.\n[0x0001ece0]> aei\n[0x0001ece0]> /as\n0x000187c2 sd_ble_gap_disconnect\n0x000189ea sd_ble_gatts_sys_attr_set\n0x00018a0e sd_ble_gap_sec_info_reply\n...\nTo reduce searching time it is possible to restrict the searching range for only executable segments or sections with /as @e:search.in=io.maps.x\nUsing the ESIL emulation rizin can print syscall arguments in the disassembly output. To enable the linear (but very rough) emulation use asm.emu configuration variable:\n[0x0001ece0]> e asm.emu=true\n[0x0001ece0]> s 0x000187c2\n[0x000187c2]> pdf~svc\n   0x000187c2   svc 0x76  ; 118 = sd_ble_gap_disconnect\n[0x000187c2]>\nIn case of executing aae (or aaaa which calls aae) command rizin will push found syscalls to a special syscall. flagspace, which can be useful for automation purpose:\n[0x000187c2]> fs\n0    0 * imports\n1    0 * symbols\n2 1523 * functions\n3  420 * strings\n4  183 * syscalls\n[0x000187c2]> f~syscall\n...\n0x000187c2 1 syscall.sd_ble_gap_disconnect.0\n0x000189ea 1 syscall.sd_ble_gatts_sys_attr_set\n0x00018a0e 1 syscall.sd_ble_gap_sec_info_reply\n...\nIt also can be interactively navigated through within HUD mode (V_)\n0> syscall.sd_ble_gap_disconnect\n - 0x000187b2  syscall.sd_ble_gap_disconnect\n   0x000187c2  syscall.sd_ble_gap_disconnect.0\n   0x00018a16  syscall.sd_ble_gap_disconnect.1\n   0x00018b32  syscall.sd_ble_gap_disconnect.2\n   0x0002ac36  syscall.sd_ble_gap_disconnect.3\nWhen debugging in rizin, you can use dcs to continue execution until the next syscall. You can also run dcs* to trace all syscalls.\n[0xf7fb9120]> dcs*\nRunning child until syscalls:-1 \nchild stopped with signal 133\n--> SN 0xf7fd3d5b syscall 45 brk (0xffffffda)\nchild stopped with signal 133\n--> SN 0xf7fd28f3 syscall 384 arch_prctl (0xffffffda 0x3001)\nchild stopped with signal 133\n--> SN 0xf7fc81b2 syscall 33 access (0xffffffda 0xf7fd8bf1)\nchild stopped with signal 133\nrizin also has a syscall name to syscall number utility. You can return the syscall name of a given syscall number or vice versa, without leaving the shell.\n[0x08048436]> asl 1\nexit\n[0x08048436]> asl write\n4\n[0x08048436]> ask write\n0x80,4,3,iZi\nSee as? for more information about the utility.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/analysis/emulation.html#emulation-in-analysis-loop",
    "title": "40  Emulation",
    "section": "40.1 Emulation in analysis loop",
    "text": "Apart from the manual emulation mode, it can be used automatically in the analysis loop. For example, the aaaa command performs the ESIL emulation stage along with others. To disable or enable its usage you can use analysis.esil configuration variable. There is one more important option, though setting it might be quite dangerous, especially in the case of malware - emu.write which allows ESIL VM to modify memory. Sometimes it is required though, especially in the process of deobfuscating or unpacking code.\nTo show the process of emulation you can set asm.emu variable, which will show calculated register and memory values in disassembly comments:\n[0x00001660]> e asm.emu=true\n[0x00001660]> pdf\n. (fcn) fcn.00001660 40\n│   fcn.00001660 ();\n│     ; CALL XREF from 0x00001713 (entry2.fini)\n│     0x00001660  lea rdi, obj.__progname ; 0x207220 ; rdi=0x207220 -> 0x464c457f\n│     0x00001667  push rbp                ; rsp=0xfffffffffffffff8\n│     0x00001668  lea rax, obj.__progname ; 0x207220 ; rax=0x207220 -> 0x464c457f\n│     0x0000166f  cmp rax, rdi            ; zf=0x1 -> 0x2464c45 ; cf=0x0 ; pf=0x1 -> 0x2464c45 ; sf=0x0 ; of=0x0\n│     0x00001672  mov rbp, rsp            ; rbp=0xfffffffffffffff8\n│ .─< 0x00001675  je 0x1690               ; rip=0x1690 -> 0x1f0fc35d ; likely\n│ │   0x00001677  mov rax, qword [reloc._ITM_deregisterTMCloneTable] ; [0x206fd8:8]=0 ; rax=0x0\n│ │   0x0000167e  test rax, rax           ; zf=0x1 -> 0x2464c45 ; pf=0x1 -> 0x2464c45 ; sf=0x0 ; cf=0x0 ; of=0x0\n│.──< 0x00001681  je 0x1690               ; rip=0x1690 -> 0x1f0fc35d ; likely\n│││   0x00001683  pop rbp                 ; rbp=0xffffffffffffffff -> 0x4c457fff ; rsp=0x0\n│││   0x00001684  jmp rax                 ; rip=0x0 ..\n│``─> 0x00001690  pop rbp                 ; rbp=0x10102464c457f ; rsp=0x8 -> 0x464c457f\n`     0x00001691  ret                     ; rip=0x0 ; rsp=0x10 -> 0x3e0003\nNote here likely comments, which indicates that ESIL emulation predicted for particular conditional jump to happen.\nApart from the basic ESIL VM setup, you can change the behavior with other options located in emu. and esil. configuration namespaces.\nFor manipulating ESIL working with memory and stack you can use the following options:\n\nesil.stack to enable or disable temporary stack for asm.emu mode\nesil.stack.addr to set stack address in ESIL VM (like aeim command)\nesil.stack.size to set stack size in ESIL VM (like aeim command)\nesil.stack.depth limits the number of PUSH operations into the stack\nesil.romem specifies read-only access to the ESIL memory\nesil.fillstack and esil.stack.pattern allows you to use a various pattern for filling ESIL VM stack upon initialization\nesil.nonull when set stops ESIL execution upon NULL pointer read or write."
  },
  {
    "href": "src/analysis/symbols.html",
    "title": "41  Symbols",
    "section": "",
    "text": "Rizin automatically parses available imports and exports sections in the binary, moreover, it can load additional debugging information if present. Two main formats are supported: DWARF and PDB (for Windows binaries). Note that, unlike many tools rizin doesn’t rely on Windows API to parse PDB files, thus they can be loaded on any other supported platform - e.g. Linux or OS X.\nDWARF debug info loads automatically by default because usually it’s stored right in the executable file. PDB is a bit of a different beast - it is always stored as a separate binary, thus the different logic of handling it.\nAt first, one of the common scenarios is to analyze the file from Windows distribution. In this case, all PDB files are available on the Microsoft server, which is by default is in options. See all pdb options in rizin:\npdb.autoload = 0\npdb.extract = 1\npdb.server = https://msdl.microsoft.com/download/symbols\npdb.useragent = Microsoft-Symbol-Server/6.11.0001.402\nUsing the variable pdb.server you can change the address where rizin will try to download the PDB file by the GUID stored in the executable header. You can make use of multiple symbol servers by separating each URL with a semi-colon:\ne pdb.server=https://msdl.microsoft.com/download/symbols;https://symbols.mozilla.org/\nOn Windows, you can also use local network share paths (UNC paths) as symbol servers.\nUsually, there is no reason to change the default pdb.useragent, but who knows where could it be handy?\nBecause those PDB files are stored as “cab” archives on the server, pdb.extract=1 says to automatically extract them.\nNote that for the automatic downloading to work you need the “cabextract” tool, and wget/curl installed.\nSometimes you don’t need to do that from the rizin itself, thus - two handy rz-bin options:\n -P              show debug/pdb information\n -PP             download pdb file for binary\nwhere -PP automatically downloads the pdb for the selected binary, using those pdb.* config options. -P will dump the contents of the PDB file, which is useful sometimes for a quick understanding of the symbols stored in it.\nApart from the basic scenario of just opening a file, PDB information can be additionally manipulated by the id commands:\n[0x000051c0]> id?\n|Usage: id Debug information\n| Output mode:\n| '*'              Output in rizin commands\n| id               Source lines\n| idp [file.pdb]   Load pdb file information\n| idpi [file.pdb]  Show pdb file information\n| idpd             Download pdb file on remote server\nWhere idpi is basically the same as rz-bin -P. Note that idp can be also used not only in the static analysis mode but also in the debugging mode, even if connected via WinDbg.\nFor simplifying the loading PDBs, especially for the processes with many linked DLLs, rizin can autoload all required PDBs automatically - you need just set the e pdb.autoload=true option. Then if you load some file in debugging mode in Windows, using rizin -d file.exe or rizin -d 2345 (attach to pid 2345), all related PDB files will be loaded automatically.\nDWARF information loading, on the other hand, is completely automated. You don’t need to run any commands/change any options:\nrizin `which rz-bin`\n[0x00002437 8% 300 /usr/local/bin/rz-bin]> pd $r\n0x00002437  jne 0x2468                  ;[1]\n0x00002439  cmp qword reloc.__cxa_finalize_224, 0\n0x00002441  push rbp\n0x00002442  mov rbp, rsp\n0x00002445  je 0x2453                   ;[2]\n0x00002447  lea rdi, obj.__dso_handle   ; 0x207c40 ; \"@| \"\n0x0000244e  call 0x2360                 ;[3]\n0x00002453  call sym.deregister_tm_clones ;[4]\n0x00002458  mov byte [obj.completed.6991], 1 ; obj.__TMC_END__ ; [0x2082f0:1]=0\n0x0000245f  pop rbp\n0x00002460  ret\n0x00002461  nop dword [rax]\n0x00002468  ret\n0x0000246a  nop word [rax + rax]\n;-- entry1.init:\n;-- frame_dummy:\n0x00002470  push rbp\n0x00002471  mov rbp, rsp\n0x00002474  pop rbp\n0x00002475  jmp sym.register_tm_clones  ;[5]\n;-- blob_version:\n0x0000247a  push rbp                    ; ../blob/version.c:18\n0x0000247b  mov rbp, rsp\n0x0000247e  sub rsp, 0x10\n0x00002482  mov qword [rbp - 8], rdi\n0x00002486  mov eax, 0x32               ; ../blob/version.c:24 ; '2'\n0x0000248b  test al, al                 ; ../blob/version.c:19\n0x0000248d  je 0x2498                   ;[6]\n0x0000248f  lea rax, str.2.0.1_182_gf1aa3aa4d ; 0x60b8 ; \"2.0.1-182-gf1aa3aa4d\"\n0x00002496  jmp 0x249f                  ;[7]\n0x00002498  lea rax, 0x000060cd\n0x0000249f  mov rsi, qword [rbp - 8]\n0x000024a3  mov r8, rax\n0x000024a6  mov ecx, 0x40               ; section_end.ehdr\n0x000024ab  mov edx, 0x40c0\n0x000024b0  lea rdi, str._s_2.1.0_git__d___linux_x86__d_git._s_n ; 0x60d0 ; \"%s 2.1.0-git %d @ linux-x86-%d git.%s\\n\"\n0x000024b7  mov eax, 0\n0x000024bc  call 0x2350                 ;[8]\n0x000024c1  mov eax, 0x66               ; ../blob/version.c:25 ; 'f'\n0x000024c6  test al, al\n0x000024c8  je 0x24d6                   ;[9]\n0x000024ca  lea rdi, str.commit:_f1aa3aa4d2599c1ad60e3ecbe5f4d8261b282385_build:_2017_11_06__12:18:39 ; ../blob/version.c:26 ; 0x60f8 ; \"commit: f1aa3aa4d2599c1ad60e3ecbe5f4d8261b282385 build: 2017-11-06__1\n0x000024d1  call sym.imp.puts           ;[?]\n0x000024d6  mov eax, 0                  ; ../blob/version.c:28\n0x000024db  leave                       ; ../blob/version.c:29\n0x000024dc  ret\n;-- rabin_show_help:\n0x000024dd  push rbp                    ; .//rz-bin.c:27\nAs you can see, it loads function names and source line information.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/analysis/graphs.html",
    "title": "42  Graph commands",
    "section": "",
    "text": "When analyzing data it is usually handy to have different ways to represent it in order to get new perspectives to allow the analyst to understand how different parts of the program interact.\nRepresenting basic block edges, function calls, string references as graphs show a very clear view of this information.\nRizin supports various types of graph available through commands starting with ag:\n[0x00005000]> ag?\n|Usage: ag<graphtype><format> [addr]\n| Graph commands:\n| aga[format]             Data references graph\n| agA[format]             Global data references graph\n| agc[format]             Function callgraph\n| agC[format]             Global callgraph\n| agd[format] [fcn addr]  Diff graph\n| agf[format]             Basic blocks function graph\n| agi[format]             Imports graph\n| agr[format]             References graph\n| agR[format]             Global references graph\n| agx[format]             Cross references graph\n| agg[format]             Custom graph\n| ag-                     Clear the custom graph\n| agn[?] title body       Add a node to the custom graph\n| age[?] title1 title2    Add an edge to the custom graph\n\nOutput formats:\n| <blank>                 Ascii art\n| *                       rizin commands\n| d                       Graphviz dot\n| g                       Graph Modelling Language (gml)\n| j                       json ('J' for formatted disassembly)\n| k                       SDB key-value\n| t                       Tiny ascii art\n| v                       Interactive ascii art\n| w [path]                Write to path or display graph image (see graph.gv.format and graph.web)\nThe structure of the commands is as follows: ag <graph type> <output format>.\nFor example, agid displays the imports graph in dot format, while aggj outputs the custom graph in JSON format.\nHere’s a short description for every output format available:\n\n42.0.1 Ascii Art ** (e.g. agf)\nDisplays the graph directly to stdout using ASCII art to represent blocks and edges.\nWarning: displaying large graphs directly to stdout might prove to be computationally expensive and will make rizin not responsive for some time. In case of doubt, prefer using the interactive view (explained below).\n\n\n42.0.2 Interactive Ascii Art (e.g. agfv)\nDisplays the ASCII graph in an interactive view similar to VV which allows to move the screen, zoom in / zoom out, …\n\n\n42.0.3 Tiny Ascii Art (e.g. agft)\nDisplays the ASCII graph directly to stdout in tiny mode (which is the same as reaching the maximum zoom out level in the interactive view).\n\n\n42.0.4 Graphviz dot (e.g. agfd)\nPrints the dot source code representing the graph, which can be interpreted by programs such as graphviz or online viewers like this\n\n\n42.0.5 JSON (e.g. agfj)\nPrints a JSON string representing the graph.\n\nIn the case of the f format (basic blocks of function), it will have detailed information about the function and will also contain the disassembly of the function (use J format for the formatted disassembly.\nIn all other cases, it will only have basic information about the nodes of the graph (id, title, body, and edges).\n\n\n\n42.0.6 Graph Modelling Language (e.g. agfg)\nPrints the GML source code representing the graph, which can be interpreted by programs such as yEd\n\n\n42.0.7 SDB key-value (e.g. agfk)\nPrints key-value strings representing the graph that was stored by sdb (rizin’s string database).\n\n\n42.0.8 R2 custom graph commands (e.g. agf*)\nPrints rizin commands that would recreate the desired graph. The commands to construct the graph are agn [title] [body] to add a node and age [title1] [title2] to add an edge. The [body] field can be expressed in base64 to include special formatting (such as newlines).\nTo easily execute the printed commands, it is possible to prepend a dot to the command (.agf*).\n\n\n42.0.9 Web / image (e.g. agfw)\nRizin will convert the graph to dot format, use the dot program to convert it to a .gif image and then try to find an already installed viewer on your system (xdg-open, open, …) and display the graph there.\nThe extension of the output image can be set with the graph.extension config variable. Available extensions are png, jpg, gif, pdf, ps.\nNote: for particularly large graphs, the most recommended extension is svg as it will produce images of much smaller size\nIf graph.web config variable is enabled, rizin will try to display the graph using the browser (this feature is experimental and unfinished, and disabled by default.)\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/analysis/cpu_platform_profiles.html#the-motivation",
    "title": "43  CPU and platform profiles",
    "section": "43.1 The motivation",
    "text": "The computer ecosystem, especially in embedded systems is vast and growing and is thus diverse and is full of trivial differences. CPUs and development boards differ by minor and sometimes large differences in their design, ports, MMIO registers and other peripherals. Rizin handles these differences by storing the data regarding each CPUs and platforms in SDB files in a standard format, instead of hardcoding them with each of the disassembler plugins. This information will be parsed and added as flags and comments during the analysis loop and will show up in the disassembly and other places, making reverse engineering on those particular chips ets is much easier. This also helps in easy addition of a new port, in maintenance and in user-friendliness."
  },
  {
    "href": "src/analysis/cpu_platform_profiles.html#how-it-works",
    "title": "43  CPU and platform profiles",
    "section": "43.2 How it works",
    "text": "43.2.1 CPU profiles\nAll the specifics pertaining to a CPU is written down in a CPU profile. It is designed in a way that allows you to enter CPU specefic values like: size of the RAM (RAM_SIZE), size of the ROM (ROM_SIZE) and many more. CPU profiles can be selected using the configuration variable asm.cpu. Firstly, Rizin checks whether the a CPU profile exists for the selected CPU and architecture. If it exists, Rizin generates the filepath of the profile and gets to a stage where it’s ready to be loaded up. During analysis (aa), it’s loaded up and the values are parsed and handled. CPU profiles also allow you to add information regarding the IO and extended IO registers of a CPU. The information pertaining to the IO and extended IO registers are added as flags at their corresponding offsets.\nThe CPU profile of AVR’s ATTiny88 CPU looks like this:\nRAM_SIZE=512\nROM_SIZE=8192\nINTERRUPT_VECTOR_SIZE=2\n\nPINB=io\nPINB.address=0x03\nDDRB=io\nDDRB.address=0x04\nPORTB=io\nHere, PINB is the name and io is the type of the port and this will be added as a flag at the offset 0x03. The type can be ext_io if it’s an extended IO register, as well. Both will be added as flags and the only difference between them is that they will be added in different flagspaces.\nCPU profiles also support mapping the ROM. According the ROM_ADDRESS and ROM_SIZE, a section named .rom will be added during analysis.\n\n43.2.1.1 Adding CPU profiles\nCPU profiles are stored in SDB files under the directory lirbz/asm/cpus and that’s where you will have to put your new profile. The files follow a naming convention like arch-cpu. You can see the complete list of things that are parsed at librz/analysis/arch_profile.c and if necessary, a new key can be easily added.\nTo add a new CPU profile, firstly make sure that you have the name of the CPU defined in the list of CPUs defined by the variable cpus in the corresponding architecture’s disassembler plugin (RzAsmPlugin). Then, simply add the SDB file in the directory, add the entry in the meson.build of the same directory and build again. Choose the right CPU and architecture and analyze again (aa) to load up the CPU profile.\nFor reference, you can see the previously added CPU profile of ATmega16 here: librz/asm/cpus/avr-ATmega16.sdb.txt.\n\n\n\n43.2.2 Platform profiles\nPlatform profiles are designed with an idea to support adding information that is pertaining to a specific board or a micro controller. For example, most of the Raspberry Pi-s use a specific Broadcom chip and its peripherals like registers and interrupts will be the same for all Raspberry Pi-s. These profiles can be selected using the configuration variable asm.platforms and is loaded during analysis (aa). If you run e asm.platform=?, you can see the supported platforms by the selected architecture and CPU.\nLet’s have a look at Broadcom 2835’s platform profile:\nAUX_IRQ=name\nAUX_IRQ.address=0x7e215000\nAUX_IRQ.comment=Auxiliary Interrupt status\n\nAUX_MU_IO_REG=name\nAUX_MU_IO_REG.address=0x7e215040\nAUX_MU_IO_REG.comment=Mini UART I/O Data\nJust like in CPU profiles, the name will be added as a flag and the comment as a comment (CCu).\n\n43.2.2.1 Adding platform profiles\nPlatform profiles are stored in librz/asm/platforms/ and that’s where you will have to put your profile. They follow a naming convention like arch-cpu-platform.\nTo add a new platform profile, we will have to define the name of the platform in the variable platforms in the RzAsmPlugin definition corresponding architecture’s disassembler plugin. You will also need to add the CPU is it’s not already added. Then, add the entry in the meson.build of the same directory and build again. Choose the right CPU, architecture and platform and analyze again (aa).\nYou can also check out the platform profiles that were previously added at librz/asm/platforms/arm-arm1176-bcm2835.sdb.txt."
  },
  {
    "href": "src/scripting/intro.html",
    "title": "44  Scripting",
    "section": "",
    "text": "Rizin provides a wide set of a features to automate boring work. It ranges from the simple sequencing of the commands to the calling scripts/another programs via IPC (Inter-Process Communication), called rz-pipe.\nAs mentioned a few times before there is an ability to sequence commands using ; semicolon operator.\n[0x00404800]> pd 1 ; ao 1\n           0x00404800      b827e66100     mov eax, 0x61e627      ; \"tab\"\naddress: 0x404800\nopcode: mov eax, 0x61e627\nprefix: 0\nbytes: b827e66100\nptr: 0x0061e627\nrefptr: 0\nsize: 5\ntype: mov\nesil: 6415911,rax,=\nstack: null\nfamily: cpu\n[0x00404800]>\nIt simply runs the second command after finishing the first one, like in a shell.\nThe second important way to sequence the commands is with a simple pipe |\nao|grep address\nNote, the | pipe only can pipe output of rizin commands to external (shell) commands, like system programs or builtin shell commands. There is a similar way to sequence rizin commands, using the backtick operator `command`. The quoted part will undergo command substitution and the output will be used as an argument of the command line.\nFor example, we want to see a few bytes of the memory at the address referred to by the ‘mov eax, addr’ instruction. We can do that without jumping to it, using a sequence of commands:\n[0x00404800]> pd 1\n              0x00404800      b827e66100     mov eax, 0x61e627      ; \"tab\"\n[0x00404800]> ao\naddress: 0x404800\nopcode: mov eax, 0x61e627\nprefix: 0\nbytes: b827e66100\nptr: 0x0061e627\nrefptr: 0\nsize: 5\ntype: mov\nesil: 6415911,rax,=\nstack: null\nfamily: cpu\n[0x00404800]> ao~ptr[1]\n0x0061e627\n0\n[0x00404800]> px 10 @ `ao~ptr[1]`\n- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF\n0x0061e627  7461 6200 2e69 6e74 6572                 tab..inter\n[0x00404800]>\nAnd of course it’s possible to redirect the output of an rizin command into a file, using the > and >> commands\n[0x00404800]> px 10 @ `ao~ptr[1]` > example.txt\n[0x00404800]> px 10 @ `ao~ptr[1]` >> example.txt\nThe ?$? command describes several helpful variables you can use to do similar actions even more easily, like the $v “immediate value” variable, or the $m opcode memory reference variable.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/scripting/loops.html",
    "title": "45  Loops",
    "section": "",
    "text": "One of the most common task in automation is looping through something, there are multiple ways to do this in rizin. You can find all these loops under @@?.\nWe can loop over flags:\n@@f:flagname-regex\nFor example, we want to see function information with afi command:\n[0x004047d6]> afi\n#\noffset: 0x004047d0\nname: entry0\nsize: 42\nrealsz: 42\nstackframe: 0\ncall-convention: amd64\ncyclomatic-complexity: 1\nbits: 64\ntype: fcn [NEW]\nnum-bbs: 1\nedges: 0\nend-bbs: 1\ncall-refs: 0x00402450 C\ndata-refs: 0x004136c0 0x00413660 0x004027e0\ncode-xrefs:\ndata-xrefs:\nlocals:0\nargs: 0\ndiff: type: new\n[0x004047d6]>\nNow let’s say, for example, that we’d like see a particular field from this output for all functions found by analysis. We can do that with a loop over all function flags (whose names begin with fcn.):\n[0x004047d6]> fs functions\n[0x004047d6]> afi @@f:fcn.* ~name\nThis command will extract the name field from the afi output of every flag with a name matching the regexp fcn.*. There are also other loops, for example one called @@F runs your command on every functions found by rizin:\n[0x004047d6]> afi @@F ~name\nWe can also loop over a list of offsets, using the following syntax:\n@@=1 2 3 ... N\nFor example, say we want to see the opcode information for 2 offsets: the current one, and at current + 2:\n[0x004047d6]> ao @@=$$ $$+2\naddress: 0x4047d6\nopcode: mov rdx, rsp\nprefix: 0\nbytes: 4889e2\nrefptr: 0\nsize: 3\ntype: mov\nesil: rsp,rdx,=\nstack: null\nfamily: cpu\naddress: 0x4047d8\nopcode: loop 0x404822\nprefix: 0\nbytes: e248\nrefptr: 0\nsize: 2\ntype: cjmp\nesil: 1,rcx,-=,rcx,?{,4212770,rip,=,}\njump: 0x00404822\nfail: 0x004047da\nstack: null\ncond: al\nfamily: cpu\n[0x004047d6]>\nNote we’re using the $$ variable which evaluates to the current offset. Also note that $$+2 is evaluated before looping, so we can use the simple arithmetic expressions.\nA third way to loop is by having the offsets be loaded from a file. This file should contain one offset per line.\n[0x004047d0]> ?v $$ > offsets.txt\n[0x004047d0]> ?v $$+2 >> offsets.txt\n[0x004047d0]> !cat offsets.txt\n4047d0\n4047d2\n[0x004047d0]> pi 1 @@.offsets.txt\nxor ebp, ebp\nmov r9, rdx\nIf you want to iterate over all instructions of a basic block, you can do:\n[0x004047d0]> pi 1 @@i\nendbr64\npush rbx\ntest rdi, rdi\nje 0x14635\nIn this example the command pi 1 runs over all the instructions in the current basic block.\nIf you want to iterate over all instructions of all basic blocks of the current function, you can do:\n[0x004047d0]> pi 1 @@i @@b\nendbr64     \npush rbx            \ntest rdi, rdi\nje 0x14635\nmov esi, 0x2f    \nmov rbx, rdi\n[... cut for example ...]\nmov rbx, r8                                                                                    \njmp 0x1461a         \nmov rax, qword [reloc.stderr]\nmov edx, 0x37     \nmov esi, 1            \nlea rdi, str.A_NULL_argv_0__was_passed_through_an_exec_system_call.                            \nmov rcx, qword [rax]\ncall sym.imp.fwrite\ncall sym.imp.abort\nOr if you want to make the split between basic blocks clearer:\n[0x004047d0]> (_;pi 1 @@i; ?e)() @@b\nendbr64     \npush rbx            \ntest rdi, rdi\nje 0x14635\n\nmov esi, 0x2f    \nmov rbx, rdi\n[... cut for example ...]\nmov rbx, r8                                                                                    \njmp 0x1461a         \n\nmov rax, qword [reloc.stderr]\nmov edx, 0x37     \nmov esi, 1            \nlea rdi, str.A_NULL_argv_0__was_passed_through_an_exec_system_call.                            \nmov rcx, qword [rax]\ncall sym.imp.fwrite\ncall sym.imp.abort\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/scripting/macros.html",
    "title": "46  Macros",
    "section": "",
    "text": "Apart from simple sequencing and looping, rizin allows to write simple macros, using this construction:\n[0x00404800]> (qwe; pd 4; ao)\nThis will define a macro called ‘qwe’ which runs sequentially first ‘pd 4’ then ‘ao’. Calling the macro using syntax .(macro) is simple:\n[0x00404800]> (qwe; pd 4; ao)\n[0x00404800]> .(qwe)\n0x00404800  mov eax, 0x61e627      ; \"tab\"\n0x00404805  push rbp\n0x00404806  sub rax, section_end.LOAD1\n0x0040480c  mov rbp, rsp\n\naddress: 0x404800\nopcode: mov eax, 0x61e627\nprefix: 0\nbytes: b827e66100\nptr: 0x0061e627\nrefptr: 0\nsize: 5\ntype: mov\nesil: 6415911,rax,=\nstack: null\nfamily: cpu\n[0x00404800]>\nTo list available macros simply call (*:\n[0x00404800]> (*\n(qwe ; pd 4; ao)\nAnd if want to remove some macro, just add ‘-’ before the name:\n[0x00404800]> (-qwe)\nMacro 'qwe' removed.\n[0x00404800]>\nMoreover, it’s possible to create a macro that takes arguments, which comes in handy in some simple scripting situations. To create a macro that takes arguments you simply add them to macro definition.\n[0x00404800]\n[0x004047d0]> (foo x y; pd $0; sd +$1)\n[0x004047d0]> .(foo 5 6)\n;-- entry0:\n0x004047d0      xor ebp, ebp\n0x004047d2      mov r9, rdx\n0x004047d5      pop rsi\n0x004047d6  mov rdx, rsp\n0x004047d9  and rsp, 0xfffffffffffffff0\n[0x004047d6]>\nAs you can see, the arguments are named by index, starting from 0: $0, $1, …\n\n47 Aliases\nrizin also offers aliases which might help you save time by quickly executing your most used commands. They are under $?\nThe general usage of the feature is: $alias=cmd\n[0x00404800]> $disas=pdf\nThe above command will create an alias disas for pdf. The following command prints the disassembly of the main function.\n[0x00404800]> $disas @ main\nApart from commands, you can also alias a text to be printed, when called.\n[0x00404800]> $my_alias=$test input\n[0x00404800]> $my_alias\ntest input\nTo undefine alias, use $alias=:\n[0x00404800]> $pmore='b 300;px'\n[0x00404800]> $\n$pmore\n[0x00404800]> $pmore=\n[0x00404800]> $\n\nA single $ in the above will list all defined aliases. It’s also possible check the aliased command of an alias:\n[0x00404800]> $pmore?\nb 200; px\nCan we create an alias contains alias ? The answer is yes:\n[0x00404800]> $pStart='s 0x0;$pmore'\n[0x00404800]> $pStart\n- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF\n0x00000000  7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............\n0x00000010  0300 3e00 0100 0000 1014 0000 0000 0000  ..>.............\n0x00000020  4000 0000 0000 0000 5031 0000 0000 0000  @.......P1......\n0x00000030  0000 0000 4000 3800 0d00 4000 1e00 1d00  ....@.8...@.....\n0x00000040  0600 0000 0400 0000 4000 0000 0000 0000  ........@.......\n0x00000050  4000 0000 0000 0000 4000 0000 0000 0000  @.......@.......\n0x00000060  d802 0000 0000 0000 d802 0000 0000 0000  ................\n0x00000070  0800 0000 0000 0000 0300 0000 0400 0000  ................\n0x00000080  1803 0000 0000 0000 1803 0000 0000 0000  ................\n0x00000090  1803 0000 0000 0000 1c00 0000 0000 0000  ................\n0x000000a0  1c00 0000 0000 0000 0100 0000 0000 0000  ................\n0x000000b0  0100 0000 0400 0000 0000 0000 0000 0000  ................\n0x000000c0  0000 0000 0000 0000                      ........\n[0x00000000]> \n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/scripting/rz-pipe.html#python",
    "title": "47  Rz-pipe",
    "section": "48.1 Python",
    "text": "$ pip install rz-pipe\nimport rzpipe\n\nrz = rz-pipe.open(\"/bin/ls\")\nrz.cmd('aa')\nprint(rz.cmd(\"afl\"))\nprint(rz.cmdj(\"aflj\"))  # evaluates JSONs and returns an object"
  },
  {
    "href": "src/scripting/rz-pipe.html#haskell",
    "title": "47  Rz-pipe",
    "section": "48.2 Haskell",
    "text": "import RzPipe\nimport qualified Data.ByteString.Lazy as L\n\nshowMainFunction ctx = do\n  cmd ctx \"s main\"\n  L.putStr =<< cmd ctx \"pD `fl $$`\"\n\nmain = do\n  -- Run rizin locally\n  open \"/bin/ls\" >>= showMainFunction\n  -- Connect to rizin via HTTP (e.g. if \"rizin -qc=h /bin/ls\" is running)\n  open \"http://127.0.0.1:9090\" >>= showMainFunction"
  },
  {
    "href": "src/scripting/rz-pipe.html#ocaml",
    "title": "47  Rz-pipe",
    "section": "48.3 OCaml",
    "text": "let result = Rz.with_command ~cmd:\"/j chown\" \"/bin/ls\"\nPrintf.printf \"Rizin output is: %s\" result"
  },
  {
    "href": "src/scripting/rz-pipe.html#rust",
    "title": "47  Rz-pipe",
    "section": "48.4 Rust",
    "text": "#[macro_use]\n extern crate rzpipe;\n extern crate serde_json;\n use rzpipe::RzPipe;\n fn main() {\n     let path = Some(\"/bin/ls\".to_owned());\n     let mut rzp = open_pipe!(path).unwrap();\n     println!(\"{}\", rzp.cmd(\"?e Hello World\").unwrap());\n     if let Ok(json) = rzp.cmdj(\"ij\") {\n         println!(\"{}\", serde_json::to_string_pretty(&json).unwrap());\n         println!(\"ARCH {}\", json[\"bin\"][\"arch\"]);\n     }\n     rzp.close();\n }"
  },
  {
    "href": "src/scripting/rz-pipe.html#ruby",
    "title": "47  Rz-pipe",
    "section": "48.5 Ruby",
    "text": "require './rzpipe'\n\nbegin\n  rzp = RzPipe.new\nrescue Exception => e\n  rzp = RzPipe.new '/bin/ls'\nend\n  puts rzp.cmd 'a'\n  puts rzp.cmd 'pd 10 main'\n  rzp.quit"
  },
  {
    "href": "src/debugger/intro.html",
    "title": "48  Debugger",
    "section": "",
    "text": "Debuggers are implemented as IO plugins. Therefore, rizin can handle different URI types for spawning, attaching and controlling processes. The complete list of IO plugins can be viewed with rizin -L. Those that have “d” in the first column (“rwd”) support debugging. For example:\nr_d  debug       Debug a program or pid. dbg:///bin/ls, dbg://1388 (LGPL3)\nrwd  gdb         Attach to gdbserver, 'qemu -s', gdb://localhost:1234 (LGPL3)\nThere are different backends for many target architectures and operating systems, e.g., GNU/Linux, Windows, MacOS X, (Net,Free,Open)BSD and Solaris.\nProcess memory is treated as a plain file. All mapped memory pages of a debugged program and its libraries can be read and interpreted as code or data structures.\nCommunication between rizin and the debugger IO layer is wrapped into system() calls, which accept a string as an argument, and executes it as a command. An answer is then buffered in the output console, its contents can be additionally processed by a script. Access to the IO system is achieved with R!. Most IO plugins provide help with R!? or R!help. For example:\n$ rizin -d /bin/ls\n...\n[0x7fc15afa3cc0]> R!help\nUsage: R!cmd args\n R!ptrace   - use ptrace io\n R!mem      - use /proc/pid/mem io if possible\n R!pid      - show targeted pid\n R!pid <#>  - select new pid\nIn general, debugger commands are portable between architectures and operating systems. Still, as rizin tries to support the same functionality for all target architectures and operating systems, certain things have to be handled separately. They include injecting shellcodes and handling exceptions. For example, in MIPS targets there is no hardware-supported single-stepping feature. In this case, rizin provides its own implementation for single-step by using a mix of code analysis and software breakpoints.\nTo get basic help for the debugger, type ‘d?’:\nUsage: d   # Debug commands\n| db[?]                    Breakpoints commands\n| dbt[?]                   Display backtrace based on dbg.btdepth and dbg.btalgo\n| dc[?]                    Continue execution\n| dd[?]                    File descriptors (!fd in r1)\n| de[-sc] [perm] [rm] [e]  Debug with ESIL (see de?)\n| dg <file>                Generate a core-file (WIP)\n| dH [handler]             Transplant process to a new handler\n| di[?]                    Show debugger backend information (See dh)\n| dk[?]                    List, send, get, set, signal handlers of child\n| dL[?]                    List or set debugger handler\n| dm[?]                    Show memory maps\n| do[?]                    Open process (reload, alias for 'oo')\n| doo[args]                Reopen in debug mode with args (alias for 'ood')\n| doof[file]               Reopen in debug mode from file (alias for 'oodf')\n| doc                      Close debug session\n| dp[?]                    List, attach to process or thread id\n| dr[?]                    Cpu registers\n| ds[?]                    Step, over, source line\n| dt[?]                    Display instruction traces\n| dw <pid>                 Block prompt until pid dies\n| dx[?]                    Inject and run code on target process (See gs)\nTo restart your debugging session, you can type oo or oo+, depending on desired behavior.\noo                 reopen current file (kill+fork in debugger)\noo+                reopen current file in read-write\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/getting_started.html#small-session-in-rizin-debugger",
    "title": "49  Getting Started",
    "section": "49.1 Small session in rizin debugger",
    "text": "rizin -d /bin/ls: Opens rizin with file /bin/ls in debugger mode using the rizin native debugger, but does not run the program. You’ll see a prompt (rizin) - all examples are from this prompt.\ndb flag: place a breakpoint at flag, where flag can be either an address or a function name\ndb - flag: remove the breakpoint at flag, where flag can be either an address or a function name\ndb: show list of breakpoint\ndc: run the program\ndr: Show registers state\ndrr: Show registers references (telescoping) (like peda)\nds: Step into instruction\ndso: Step over instruction\ndbt: Display backtrace\ndm: Show memory maps\ndk <signal>: Send KILL signal to child\nood: reopen in debug mode\nood arg1 arg2: reopen in debug mode with arg1 and arg2"
  },
  {
    "href": "src/debugger/registers.html",
    "title": "50  Registers",
    "section": "",
    "text": "The registers are part of a user area stored in the context structure used by the scheduler. This structure can be manipulated to get and set the values of those registers, and, for example, on Intel hosts, it is possible to directly manipulate DR0-DR7 hardware registers to set hardware breakpoints.\nThere are different commands to get values of registers. For the General Purpose ones use:\n[0x4A13B8C0]> dr\nr15 = 0x00000000\nr14 = 0x00000000\nr13 = 0x00000000\nr12 = 0x00000000\nrbp = 0x00000000\nrbx = 0x00000000\nr11 = 0x00000000\nr10 = 0x00000000\nr9 = 0x00000000\nr8 = 0x00000000\nrax = 0x00000000\nrcx = 0x00000000\nrdx = 0x00000000\nrsi = 0x00000000\nrdi = 0x00000000\noeax = 0x0000003b\nrip = 0x7f20bf5df630\nrsp = 0x7fff515923c0\n\n[0x7f0f2dbae630]> dr rip ; get value of 'rip'\n0x7f0f2dbae630\n\n[0x4A13B8C0]> dr rip = esp   ; set 'rip' as esp\nInteraction between a plugin and the core is done by commands returning rizin instructions. This is used, for example, to set flags in the core to set values of registers.\n[0x7f0f2dbae630]> dr*      ; Appending '*' will show rizin commands\nf r15 1 0x0\nf r14 1 0x0\nf r13 1 0x0\nf r12 1 0x0\nf rbp 1 0x0\nf rbx 1 0x0\nf r11 1 0x0\nf r10 1 0x0\nf r9 1 0x0\nf r8 1 0x0\nf rax 1 0x0\nf rcx 1 0x0\nf rdx 1 0x0\nf rsi 1 0x0\nf rdi 1 0x0\nf oeax 1 0x3b\nf rip 1 0x7fff73557940\nf rflags 1 0x200\nf rsp 1 0x7fff73557940\n\n[0x4A13B8C0]> .dr*  ; include common register values in flags\nAn old copy of registers is stored all the time to keep track of the changes done during execution of a program being analyzed. This old copy can be accessed with oregs.\n[0x7f1fab84c630]> dro\nr15 = 0x00000000\nr14 = 0x00000000\nr13 = 0x00000000\nr12 = 0x00000000\nrbp = 0x00000000\nrbx = 0x00000000\nr11 = 0x00000000\nr10 = 0x00000000\nr9 = 0x00000000\nr8 = 0x00000000\nrax = 0x00000000\nrcx = 0x00000000\nrdx = 0x00000000\nrsi = 0x00000000\nrdi = 0x00000000\noeax = 0x0000003b\nrip = 0x7f1fab84c630\nrflags = 0x00000200\nrsp = 0x7fff386b5080\nCurrent state of registers\n[0x7f1fab84c630]> dr\nr15 = 0x00000000\nr14 = 0x00000000\nr13 = 0x00000000\nr12 = 0x00000000\nrbp = 0x00000000\nrbx = 0x00000000\nr11 = 0x00000000\nr10 = 0x00000000\nr9 = 0x00000000\nr8 = 0x00000000\nrax = 0x00000000\nrcx = 0x00000000\nrdx = 0x00000000\nrsi = 0x00000000\nrdi = 0x7fff386b5080\noeax = 0xffffffffffffffff\nrip = 0x7f1fab84c633\nrflags = 0x00000202\nrsp = 0x7fff386b5080\nValues stored in eax, oeax and eip have changed.\nTo store and restore register values you can just dump the output of ’dr*’ command to disk and then re-interpret it again:\n[0x4A13B8C0]> dr* > regs.saved ; save registers\n[0x4A13B8C0]> drp regs.saved ; restore\nEFLAGS can be similarly altered. E.g., setting selected flags:\n[0x4A13B8C0]> dr eflags = pst\n[0x4A13B8C0]> dr eflags = azsti\nYou can get a string which represents latest changes of registers using drd command (diff registers):\n[0x4A13B8C0]> drd\noeax = 0x0000003b was 0x00000000 delta 59\nrip = 0x7f00e71282d0 was 0x00000000 delta -418217264\nrflags = 0x00000200 was 0x00000000 delta 512\nrsp = 0x7fffe85a09c0 was 0x00000000 delta -396752448\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/memory_maps.html",
    "title": "51  Memory Maps",
    "section": "",
    "text": "The ability to understand and manipulate the memory maps of a debugged program is important for many different Reverse Engineering tasks. rizin offers a rich set of commands to handle memory maps in the binary. This includes listing the memory maps of the currently debugged binary, removing memory maps, handling loaded libraries and more.\nFirst, let’s see the help message for dm, the command which is responsible for handling memory maps:\n[0x55f2104cf620]> dm?\nUsage: dm   # Memory maps commands\n| dm                               List memory maps of target process\n| dm address size                  Allocate <size> bytes at <address> (anywhere if address is -1) in child process\n| dm=                              List memory maps of target process (ascii-art bars)\n| dm.                              Show map name of current address\n| dm*                              List memmaps in rizin commands\n| dm- address                      Deallocate memory map of <address>\n| dmd[a] [file]                    Dump current (all) debug map region to a file (from-to.dmp) (see Sd)\n| dmh[?]                           Show map of heap\n| dmi [addr|libname] [symname]     List symbols of target lib\n| dmi* [addr|libname] [symname]    List symbols of target lib in rizin commands\n| dmi.                             List closest symbol to the current address\n| dmiv                             Show address of given symbol for given lib\n| dmj                              List memmaps in JSON format\n| dml <file>                       Load contents of file into the current map region\n| dmm[?][j*]                       List modules (libraries, binaries loaded in memory)\n| dmp[?] <address> <size> <perms>  Change page at <address> with <size>, protection <perms> (perm)\n| dms[?] <id> <mapaddr>            Take memory snapshot\n| dms- <id> <mapaddr>              Restore memory snapshot\n| dmS [addr|libname] [sectname]    List sections of target lib\n| dmS* [addr|libname] [sectname]   List sections of target lib in rizin commands\n| dmL address size                 Allocate <size> bytes at <address> and promote to huge page\nIn this chapter, we’ll go over some of the most useful subcommands of dm using simple examples. For the following examples, we’ll use a simple helloworld program for Linux but it’ll be the same for every binary.\nFirst things first - open a program in debugging mode:\n$ rizin -d helloworld\nProcess with PID 20304 started...\n= attach 20304 20304\nbin.baddr 0x56136b475000\nUsing 0x56136b475000\nasm.bits 64\n[0x7f133f022fb0]>\n\nNote that we passed “helloworld” to rizin without “./”. rizin will try to find this program in the current directory and then in $PATH, even if no “./” is passed. This is contradictory with UNIX systems, but makes the behaviour consistent for windows users\n\nLet’s use dm to print the memory maps of the binary we’ve just opened:\n[0x7f133f022fb0]> dm\n0x0000563a0113a000 - usr   4K s r-x /tmp/helloworld /tmp/helloworld ; map.tmp_helloworld.r_x\n0x0000563a0133a000 - usr   8K s rw- /tmp/helloworld /tmp/helloworld ; map.tmp_helloworld.rw\n0x00007f133f022000 * usr 148K s r-x /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.r_x\n0x00007f133f246000 - usr   8K s rw- /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.rw\n0x00007f133f248000 - usr   4K s rw- unk0 unk0 ; map.unk0.rw\n0x00007fffd25ce000 - usr 132K s rw- [stack] [stack] ; map.stack_.rw\n0x00007fffd25f6000 - usr  12K s r-- [vvar] [vvar] ; map.vvar_.r\n0x00007fffd25f9000 - usr   8K s r-x [vdso] [vdso] ; map.vdso_.r_x\n0xffffffffff600000 - usr   4K s r-x [vsyscall] [vsyscall] ; map.vsyscall_.r_x\nFor those of you who prefer a more visual way, you can use dm= to see the memory maps using an ASCII-art bars. This will be handy when you want to see how these maps are located in the memory.\nIf you want to know the memory-map you are currently in, use dm.:\n[0x7f133f022fb0]> dm.\n0x00007f947eed9000 # 0x00007f947eefe000 * usr   148K s r-x /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.r_x\nUsing dmm we can “List modules (libraries, binaries loaded in memory)”, this is quite a handy command to see which modules were loaded.\n[0x7fa80a19dfb0]> dmm\n0x55ca23a4a000 /tmp/helloworld\n0x7fa80a19d000 /usr/lib/ld-2.27.so\n\nNote that the output of dm subcommands, and dmm specifically, might be different in various systems and different binaries.\n\nWe can see that along with our helloworld binary itself, another library was loaded which is ld-2.27.so. We don’t see libc yet and this is because rizin breaks before libc is loaded to memory. Let’s use dcu (debug continue until) to execute our program until the entry point of the program, which rizin flags as entry0.\n[0x7fa80a19dfb0]> dcu entry0\nContinue until 0x55ca23a4a520 using 1 bpsize\nhit breakpoint at: 55ca23a4a518\n[0x55ca23a4a520]> dmm\n0x55ca23a4a000 /tmp/helloworld\n0x7fa809de1000 /usr/lib/libc-2.27.so\n0x7fa80a19d000 /usr/lib/ld-2.27.so\nNow we can see that libc-2.27.so was loaded as well, great!\nSpeaking of libc, a popular task for binary exploitation is to find the address of a specific symbol in a library. With this information in hand, you can build, for example, an exploit which uses ROP. This can be achieved using the dmi command. So if we want, for example, to find the address of system() in the loaded libc, we can simply execute the following command:\n[0x55ca23a4a520]> dmi libc system\n514 0x00000000 0x7fa809de1000  LOCAL  FILE    0 system.c\n515 0x00043750 0x7fa809e24750  LOCAL  FUNC 1221 do_system\n4468 0x001285a0 0x7fa809f095a0 LOCAL  FUNC  100 svcerr_systemerr\n5841 0x001285a0 0x7fa809f095a0 LOCAL  FUNC  100 svcerr_systemerr\n6427 0x00043d10 0x7fa809e24d10  WEAK  FUNC   45 system\n7094 0x00043d10 0x7fa809e24d10 GLBAL  FUNC   45 system\n7480 0x001285a0 0x7fa809f095a0 GLBAL  FUNC  100 svcerr_systemerr\nSimilar to the dm. command, with dmi. you can see the closest symbol to the current address.\nAnother useful command is to list the sections of a specific library. In the following example we’ll list the sections of ld-2.27.so:\n[0x55a7ebf09520]> dmS ld-2.27\n[Sections]\n00 0x00000000     0 0x00000000     0 ---- ld-2.27.so.\n01 0x000001c8    36 0x4652d1c8    36 -r-- ld-2.27.so..note.gnu.build_id\n02 0x000001f0   352 0x4652d1f0   352 -r-- ld-2.27.so..hash\n03 0x00000350   412 0x4652d350   412 -r-- ld-2.27.so..gnu.hash\n04 0x000004f0   816 0x4652d4f0   816 -r-- ld-2.27.so..dynsym\n05 0x00000820   548 0x4652d820   548 -r-- ld-2.27.so..dynstr\n06 0x00000a44    68 0x4652da44    68 -r-- ld-2.27.so..gnu.version\n07 0x00000a88   164 0x4652da88   164 -r-- ld-2.27.so..gnu.version_d\n08 0x00000b30  1152 0x4652db30  1152 -r-- ld-2.27.so..rela.dyn\n09 0x00000fb0 11497 0x4652dfb0 11497 -r-x ld-2.27.so..text\n10 0x0001d0e0 17760 0x4654a0e0 17760 -r-- ld-2.27.so..rodata\n11 0x00021640  1716 0x4654e640  1716 -r-- ld-2.27.so..eh_frame_hdr\n12 0x00021cf8  9876 0x4654ecf8  9876 -r-- ld-2.27.so..eh_frame\n13 0x00024660  2020 0x46751660  2020 -rw- ld-2.27.so..data.rel.ro\n14 0x00024e48   336 0x46751e48   336 -rw- ld-2.27.so..dynamic\n15 0x00024f98    96 0x46751f98    96 -rw- ld-2.27.so..got\n16 0x00025000  3960 0x46752000  3960 -rw- ld-2.27.so..data\n17 0x00025f78     0 0x46752f80   376 -rw- ld-2.27.so..bss\n18 0x00025f78    17 0x00000000    17 ---- ld-2.27.so..comment\n19 0x00025fa0    63 0x00000000    63 ---- ld-2.27.so..gnu.warning.llseek\n20 0x00025fe0 13272 0x00000000 13272 ---- ld-2.27.so..symtab\n21 0x000293b8  7101 0x00000000  7101 ---- ld-2.27.so..strtab\n22 0x0002af75   215 0x00000000   215 ---- ld-2.27.so..shstrtab\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/heap.html",
    "title": "52  Heap",
    "section": "",
    "text": "rizin’s dm subcommands can also display a map of the heap which is useful for those who are interested in inspecting the heap and its content. Simply execute dmh to show a map of the heap:\n[0x55c392ae1189]> dmh\nArena @ 0x7f10940c1b80\nChunk(status=free,      addr=0x55c3934c9290, size=0x50, flags=PREV_INUSE)\nChunk(status=allocated, addr=0x55c3934c92e0, size=0x90, flags=PREV_INUSE)\nChunk(status=free,      addr=0x55c3934c9370, size=0x20c90, flags=PREV_INUSE)[top][brk_start: 0x55c3934c9000, brk_end: 0x55c3934ea000]]\nYou can also see a graph layout of the heap:\n[0x7fae46236ca6]> dmhg\nArena @ 0x7f10940c1b80\nHeap Layout\n┌────────────────────────────────────┐\n│    Malloc chunk @ 0x55c3934c9290   │\n│ size: 0x50 status: free            │\n└────────────────────────────────────┘\n    v\n    │\n    │\n┌────────────────────────────────────┐\n│    Malloc chunk @ 0x55c3934c92e0   │\n│ size: 0x90 status: allocated       │\n└────────────────────────────────────┘\n    v\n    │\n    └──┐\n       │\n   ┌───────────────────────────────┐\n   │  Top chunk @ 0x55c3934c9370   │\n   └───────────────────────────────┘\nTo get information about bins of the main arena use the dmhd command.\n[0x55c392ae1189]> dmhd\nTcache bins in Main Arena @ 0x7f10940c1b80\nTcache_bin[03] Items: 1\n -> Chunk(addr=0x55c3934c9290, size=0x50, flags=PREV_INUSE)\n\nFast bins in Arena @ 0x7f10940c1b80\nFast_bin[01] [size: 0x20] Empty bin\nFast_bin[02] [size: 0x30] Empty bin\nFast_bin[03] [size: 0x40] Empty bin\nFast_bin[04] [size: 0x50] Empty bin\nFast_bin[05] [size: 0x60] Empty bin\nFast_bin[06] [size: 0x70] Empty bin\nFast_bin[07] [size: 0x80] Empty bin\n\nUnsorted bin in Arena @ 0x7f10940c1b80\nFound 0 chunks in unsorted bin\n\nSmall bins in Arena @ 0x7f10940c1b80\nFound 0 chunks in 0 small bins\n\nLarge bins in Arena @ 0x7f10940c1b80\nFound 0 chunks in 0 large bins\nOther heap commands can be found under dmh, check dmh? for the full list.\n[0x00000000]> dmh?\nUsage:  dmh   # Memory map heap\n| dmh                                          List the chunks inside the heap segment\n| dmh @[malloc_state]                          List heap chunks of a particular arena\n| dmha                                         List all malloc_state instances in application\n| dmhb @[malloc_state]                         Display all parsed Double linked list of main_arena's or a particular arena bins instance\n| dmhb [bin_num|bin_num:malloc_state]          Display parsed double linked list of bins instance from a particular arena\n| dmhbg [bin_num]                              Display double linked list graph of main_arena's bin [Under development]\n| dmhc @[chunk_addr]                           Display malloc_chunk struct for a given malloc chunk\n| dmhd [tcache|unsorted|fast|small|large]      Display description of bins in the main_arena\n| dmhf @[malloc_state]                         Display all parsed fastbins of main_arena's or a particular arena fastbinY instance\n| dmhf [fastbin_num|fastbin_num:malloc_state]  Display parsed single linked list in fastbinY instance from a particular arena\n| dmhg                                         Display heap graph of heap segment\n| dmhg [malloc_state]                          Display heap graph of a particular arena\n| dmhi @[malloc_state]                         Display heap_info structure/structures for a given arena\n| dmhj                                         List the chunks inside the heap segment in JSON format\n| dmhm                                         List all elements of struct malloc_state of main thread (main_arena)\n| dmhm @[malloc_state]                         List all malloc_state instance of a particular arena\n| dmht                                         Display all parsed thread cache bins of all arena's tcache instance\n| dmhv @[malloc_state]                         List heap chunks of a particular arena along with hexdump of first 0x10 bytes\n| dmh?                                         Show map heap help\nRizin supports Glibc, Jemalloc < 5.0 and Windows heap.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/files.html",
    "title": "53  Files",
    "section": "",
    "text": "The rizin debugger allows the user to list and manipulate the file descriptors from the target process.\nThis is a useful feature, which is not found in other debuggers, the functionality is similar to the lsof command line tool, but have extra subcommands to change the seek, close or duplicate them.\nSo, at any time in the debugging session you can replace the stdio file descriptors to use network sockets created by rizin, or replace a network socket connection to hijack it.\nThis functionality is also available in r2frida by using the dd command prefixed with a backslash. In rizin you may want to see the output of dd? for proper details.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/revdebug.html",
    "title": "54  Reverse Debugging",
    "section": "",
    "text": "Rizin has reverse debugger, that can seek the program counter backward. (e.g. reverse-next, reverse-continue in gdb) Firstly you need to save program state at the point that you want to start recording. The syntax for recording is:\n[0x004028a0]> dts+\nYou can use dts commands for recording and managing program states. After recording the states, you can seek pc back and forth to any points after saved address. So after recording, you can try single step back:\n[0x004028a0]> 2dso\n[0x004028a0]> dr rip\n0x004028ae\n[0x004028a0]> dsb\ncontinue until 0x004028a2\nhit breakpoint at: 4028a2\n[0x004028a0]> dr rip\n0x004028a2\nWhen you run dsb, reverse debugger restore previous recorded state and execute program from it until desired point.\nOr you can also try continue back:\n[0x004028a0]> db 0x004028a2\n[0x004028a0]> 10dso\n[0x004028a0]> dr rip\n0x004028b9\n[0x004028a0]> dcb\n[0x004028a0]> dr rip\n0x004028a2\ndcb seeks program counter until hit the latest breakpoint. So once set a breakpoint, you can back to it any time.\nYou can see current recorded program states using dts:\n[0x004028a0]> dts\nsession: 0   at:0x004028a0   \"\"\nsession: 1   at:0x004028c2   \"\"\nNOTE: Program records can be saved at any moments. These are diff style format that save only different memory area from previous. It saves memory space rather than entire dump.\nAnd also can add comment:\n[0x004028c2]> dtsC 0 program start\n[0x004028c2]> dtsC 1 decryption start\n[0x004028c2]> dts\nsession: 0   at:0x004028a0   \"program start\"\nsession: 1   at:0x004028c2   \"decryption start\"\nYou can leave notes for each records to keep in your mind. dsb and dcb commands restore the program state from latest record if there are many records.\nProgram records can exported to file and of course import it. Export/Import records to/from file:\n[0x004028c2]> dtst records_for_test\nSession saved in records_for_test.session and dump in records_for_test.dump\n[0x004028c2]> dtsf records_for_test\nsession: 0, 0x4028a0 diffs: 0\nsession: 1, 0x4028c2 diffs: 0\nMoreover, you can do reverse debugging in ESIL mode. In ESIL mode, program state can be managed by aets commands.\n[0x00404870]> aets+\nAnd step back by aesb:\n[0x00404870]> aer rip\n0x00404870\n[0x00404870]> 5aeso\n[0x00404870]> aer rip\n0x0040487d\n[0x00404870]> aesb\n[0x00404870]> aer rip\n0x00404879\nIn addition to the native reverse debugging capabilities in rizin, it’s also possible to use gdb’s remote protocol to reverse debug a target gdbserver that supports it. R!dsb and R!dcb are available as dsb and dcb replacements for this purpose, see remote gdb’s documentation for more information.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/windows_messages.html",
    "title": "55  Windows Messages",
    "section": "",
    "text": "On Windows, you can use dbW while debugging to set a breakpoint for the message handler of a specific window.\nGet a list of the current process windows with dW :\n[0x7ffe885c1164]> dW\n.----------------------------------------------------.\n| Handle      | PID   | TID    | Class Name          |\n)----------------------------------------------------(\n| 0x0023038e  | 9432  | 22432  | MSCTFIME UI         |\n| 0x0029049e  | 9432  | 22432  | IME                 |\n| 0x002c048a  | 9432  | 22432  | Edit                |\n| 0x000d0474  | 9432  | 22432  | msctls_statusbar32  |\n| 0x00070bd6  | 9432  | 22432  | Notepad             |\n`----------------------------------------------------'\nSet the breakpoint with a message type, together with either the window class name or its handle:\n[0x7ffe885c1164]> dbW WM_KEYDOWN Edit\nBreakpoint set.\nOr\n[0x7ffe885c1164]> dbW WM_KEYDOWN 0x002c048a\nBreakpoint set.\nIf you aren’t sure which window you should put a breakpoint on, use dWi to identify it with your mouse:\n[0x7ffe885c1164]> dWi\nMove cursor to the window to be identified. Ready? y\nTry to get the child? y\n.--------------------------------------------.\n| Handle      | PID   | TID    | Class Name  |\n)--------------------------------------------(\n| 0x002c048a  | 9432  | 22432  | Edit        |\n`--------------------------------------------'\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/apple.html#sign-rizin-binary",
    "title": "56  macOS/iOS",
    "section": "56.1 Sign rizin binary",
    "text": "If you install the Rizin pkg file and try to use it to debug a binary, you will very likely get an error message such as:\nChild killed\nptrace: Cannot attach: Invalid argument\n\nPlease ensure your rizin binary is signed and it has the right entitlements\nto make debugger work. Be aware that binaries signed by Apple cannot be\ndebugged due to the Apple System Integrity Protection (SIP).\n\nFor more info look at: https://book.rizin.re/debugger/apple.html#sign-rizin-binary\nThis is because the Darwin kernel will refuse to allow rizin to debug another process if you don’t have special rights (or if you are not root).\nTo sign the binary and give it the special rights to allow debugging as a regular user, download the Entitlements file here. Then execute the following command:\n$ codesign --entitlements <entitlements-file> --force -s - $(which rizin)\nHowever, be aware that even with a signed rizin binary you cannot debug binaries signed by Apple. To bypass the problem you have a few options: - Remove the certificate of the debuggee, by using codesign --remove-signature <binary> or other alternatives like unsign. WARNING: this cannot be undone, so we suggest to make a copy of the original binary. - Disable SIP with csrutil enable --without debug in Recovery Mode."
  },
  {
    "href": "src/debugger/apple.html#debugging-on-macos-over-ssh",
    "title": "56  macOS/iOS",
    "section": "56.2 Debugging on MacOS over SSH",
    "text": "If you are trying to debug a program over SSH, you may experience failures like rizin getting stuck while opening the file. This is because the OS is waiting for user authentication to allow debugging. However, since you are over SSH, the OS has no way of showing the permission window.\nTo avoid this problem you can either run rizin with sudo or you may instruct taskport to not authenticate the user by executing the following commands. This will disable the debugging authentication prompt even after you reboot.\nsecurity authorizationdb read system.privilege.taskport > taskport.plist\n/usr/libexec/PlistBuddy -c 'Set :authenticate-user false' ./taskport.plist\nsudo security authorizationdb write system.privilege.taskport < taskport.plist"
  },
  {
    "href": "src/debugger/remoting_capabilities.html",
    "title": "57  Remote Access Capabilities",
    "section": "",
    "text": "Rizin can be run locally, or it can be started as a server process which is controlled by a local rizin process. This is possible because everything uses rizin’s IO subsystem which abstracts access to system(), cmd() and all basic IO operations so to work over a network.\nHelp for commands useful for remote access to rizin:\n[0x00000000]> R?\nUsage: R[?]   # Connect with other instances of rizin\n| R [[<fd>] <cmd>]        # List all open connections / Exec <cmd> at remote <fd>\n| R< [<fd> <cmd>]         # Send output of local <cmd> to remote <fd>\n| R![<cmd>]               # Run <cmd> via rz_io_system\n| R+ <[proto://]host:port> # Connect to remote host:port\n| R- [<fd>]               # remove all hosts or host 'fd'\n| R= <fd>                 # Open remote session with host 'fd', 'q' to quit\n| R!= <fd>=0              # Enable remote cmd mode, sending commands to remote <fd> server\n| R=!                     # Disable remote cmd mode\n| Rr <[host:]port> [<cmd>] # Start the rap server (o rap://9999) / Execute <cmd> on rap server\n| Rg[?]                   # Start the gdbserver\n| Rh[?]                   # Start the http webserver\n| RH[?]                   # Start the http webserver (and launch the web browser)\n| Rt <[host:]port> [<cmd>] # Start the tcp server\n| R&r <port>              # Start rap server in background (same as '&_=h')\nYou can learn rizin remote capabilities by displaying the list of supported IO plugins: rizin -L.\nA little example should make this clearer. A typical remote session might look like this:\nAt the remote host1:\n$ rizin rap://:1234\nAt the remote host2:\n$ rizin rap://:1234\nAt localhost:\n$ rizin =\nAdd hosts\n[0x004048c5]> R+ rap://<host1>:1234//bin/ls\nConnected to: <host1> at port 1234\nwaiting... ok\n\n[0x004048c5]> R\n0 - rap://<host1>:1234//bin/ls\nYou can open remote files in debug mode (or using any IO plugin) specifying URI when adding hosts:\n[0x004048c5]> R+ R+ rap://<host2>:1234/dbg:///bin/ls\nConnected to: <host2> at port 1234\nwaiting... ok\n0 - rap://<host1>:1234//bin/ls\n1 - rap://<host2>:1234/dbg:///bin/ls\nTo execute commands on host1:\n[0x004048c5]> R 0 px\n[0x004048c5]> R s 0x666\nTo open a session with host2:\n[0x004048c5]> R= 1\nfd:6> pi 1\n...\nfd:6> q\nTo remove hosts (and close connections):\n[0x004048c5]> R-\nYou can also redirect rizin output to a TCP or UDP server (such as nc -l). First, Add the server with ‘R+ tcp://’ or ‘R+ udp://’, then you can redirect the output of a command to be sent to the server:\n[0x004048c5]> R+ tcp://<host>:<port>/\nConnected to: <host> at port <port>\n5 - tcp://<host>:<port>/\n[0x004048c5]> R<5 cmd...\nThe R< command will send the output from the execution of cmd to the remote connection number N (or the last one used if no id specified).\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/remote_gdb.html",
    "title": "58  Debugging with gdbserver",
    "section": "",
    "text": "rizin allows remote debugging over the gdb remote protocol. So you can run a gdbserver and connect to it with rizin for remote debugging. The syntax for connecting is:\n$ rizin -d gdb://<host>:<port>\nNote that the following command does the same, rizin will use the debug plugin specified by the uri if found.\n$ rizin -D gdb gdb://<host>:<port>\nThe debug plugin can be changed at runtime using the dL or Ld commands.\nOr if the gdbserver is running in extended mode, you can attach to a process on the host with:\n$ rizin -d gdb://<host>:<port>/<pid>\nIt is also possible to start debugging after analyzing a file using the doof command which rebases the current session’s data after opening gdb\n[0x00404870]> doof gdb://<host>:<port>/<pid>\nAfter connecting, you can use the standard rizin debug commands as normal.\nrizin does not yet load symbols from gdbserver, so it needs the binary to be locally present to load symbols from it. In case symbols are not loaded even if the binary is present, you can try specifying the path with e dbg.exe.path:\n$ rizin -e dbg.exe.path=<path> -d gdb://<host>:<port>\nIf symbols are loaded at an incorrect base address, you can try specifying the base address too with e bin.baddr:\n$ rizin -e bin.baddr=<baddr> -e dbg.exe.path=<path> -d gdb://<host>:<port>\nUsually the gdbserver reports the maximum packet size it supports. Otherwise, rizin resorts to sensible defaults. But you can specify the maximum packet size with the environment variable R2_GDB_PKTSZ. You can also check and set the max packet size during a session with the IO system, R!.\n$ export R2_GDB_PKTSZ=512\n$ rizin -d gdb://<host>:<port>\n= attach <pid> <tid>\nAssuming filepath <path/to/exe>\n[0x7ff659d9fcc0]> R!pktsz\npacket size: 512 bytes\n[0x7ff659d9fcc0]> R!pktsz 64\n[0x7ff659d9fcc0]> R!pktsz\npacket size: 64 bytes\nThe gdb IO system provides useful commands which might not fit into any standard rizin commands. You can get a list of these commands with R!?. (Remember, R! accesses the underlying IO plugin’s system()).\n[0x7ff659d9fcc0]> R!?\nUsage: R!cmd args\n R!pid             - show targeted pid\n R!pkt s           - send packet 's'\n R!monitor cmd     - hex-encode monitor command and pass to target interpreter\n R!rd              - show reverse debugging availability\n R!dsb             - step backwards\n R!dcb             - continue backwards\n R!detach [pid]    - detach from remote/detach specific pid\n R!inv.reg         - invalidate reg cache\n R!pktsz           - get max packet size used\n R!pktsz bytes     - set max. packet size as 'bytes' bytes\n R!exec_file [pid] - get file which was executed for current/specified pid\nNote that R!dsb and R!dcb are only available in special gdbserver implementations such as Mozilla’s rr, the default gdbserver doesn’t include remote reverse debugging support. Use R!rd to print the currently available reverse debugging capabilities.\nIf you are interested in debugging rizin’s interaction with gdbserver you can use R!monitor set remote-debug 1 to turn on logging of gdb’s remote protocol packets in gdbserver’s console and R!monitor set debug 1 to show general debug messages from gdbserver in it’s console.\nrizin also provides its own gdbserver implementation:\n$ rizin =\n[0x00000000]> Rg?\n|Usage:  =[g] [...] # gdb server\n| gdbserver:\n| Rg port file [args]   listen on 'port' debugging 'file' using gdbserver\n| Rg! port file [args]  same as above, but debug protocol messages (like gdbserver --remote-debug)\nSo you can start it as:\n$ rizin =\n[0x00000000]> Rg 8000 /bin/rizin -\nAnd then connect to it like you would to any gdbserver. For example, with rizin:\n$ rizin -d gdb://localhost:8000\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/debugger/windbg.html#setting-up-kd-on-windows",
    "title": "59  WinDBG Kernel-mode Debugging (KD)",
    "section": "59.1 Setting Up KD on Windows",
    "text": "For a complete walkthrough, refer to Microsoft’s documentation.\n\n\n59.1.1 Serial Port\nEnable KD over a serial port on Windows Vista and higher like this:\nbcdedit /debug on\nbcdedit /dbgsettings serial debugport:1 baudrate:115200\nOr like this for Windows XP: Open boot.ini and add /debug /debugport=COM1 /baudrate=115200:\n[boot loader]\ntimeout=30\ndefault=multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS\n[operating systems]\nmulti(0)disk(0)rdisk(0)partition(1)\\WINDOWS=\"Debugging with Cable\" /fastdetect /debug /debugport=COM1 /baudrate=57600\nIn case of VMWare\n    Virtual Machine Settings -> Add -> Serial Port\n    Device Status:\n    [v] Connect at power on\n    Connection:\n    [v] Use socket (named pipe)\n    [_/tmp/winkd.pipe________]\n    From: Server To: Virtual Machine\nConfigure the VirtualBox Machine like this:\n    Preferences -> Serial Ports -> Port 1\n\n    [v] Enable Serial Port\n    Port Number: [_COM1_______[v]]\n    Port Mode:   [_Host_Pipe__[v]]\n                 [v] Create Pipe\n    Port/File Path: [_/tmp/winkd.pipe____]\nOr just spawn the VM with qemu like this:\n$ qemu-system-x86_64 -chardev socket,id=serial0,\\\n     path=/tmp/winkd.pipe,nowait,server \\\n     -serial chardev:serial0 -hda Windows7-VM.vdi\n\n\n59.1.2 Network\nEnable KD over network (KDNet) on Windows 7 or later likes this:\nbcdedit /debug on\nbcdedit /dbgsettings net hostip:w.x.y.z port:n\nStarting from Windows 8 there is no way to enforce debugging for every boot, but it is possible to always show the advanced boot options, which allows to enable kernel debugging:\nbcedit /set {globalsettings} advancedoptions true"
  },
  {
    "href": "src/debugger/windbg.html#connecting-to-kd-interface-on-rizin",
    "title": "59  WinDBG Kernel-mode Debugging (KD)",
    "section": "59.2 Connecting to KD interface on rizin",
    "text": "59.2.1 Serial Port\nRizin will use the winkd io plugin to connect to a socket file created by virtualbox or qemu. Also, the winkd debugger plugin and we should specify the x86-32 too. (32 and 64 bit debugging is supported)\n$ rizin -a x86 -b 32 -D winkd winkd:///tmp/winkd.pipe\nOn Windows you should run the following line:\n$ rizin -D winkd winkd://\\\\.\\pipe\\com_1\n\n\n59.2.2 Network\n$ rizin -a x86 -b 32 -d winkd://<hostip>:<port>:w.x.y.z"
  },
  {
    "href": "src/debugger/windbg.html#using-kd",
    "title": "59  WinDBG Kernel-mode Debugging (KD)",
    "section": "59.3 Using KD",
    "text": "When connecting to a KD interface, rizin will send a breakin packet to interrupt the target and we will get stuck here:\n[0x828997b8]> pd 20\n    ;-- eip:\n    0x828997b8    cc           int3\n    0x828997b9    c20400       ret 4\n    0x828997bc    cc           int3\n    0x828997bd    90           nop\n    0x828997be    c3           ret\n    0x828997bf    90           nop\nIn order to skip that trap we will need to change eip and run ‘dc’ twice:\ndr eip=eip+1\ndc\ndr eip=eip+1\ndc\nNow the Windows VM will be interactive again. We will need to kill rizin and attach again to get back to control the kernel.\nIn addition, the dp command can be used to list all processes, and dpa or dp= to attach to the process. This will display the base address of the process in the physical memory layout."
  },
  {
    "href": "src/debugger/windbg.html#using-the-plugin",
    "title": "59  WinDBG Kernel-mode Debugging (KD)",
    "section": "60.1 Using the plugin",
    "text": "To use the windbg plugin, pass the same command-line options as you would for WinDBG or kd (see Microsoft’s documentation), quoting/escaping when necessary:\n> rizin -d \"windbg://-remote tcp:server=Server,port=Socket\"\n> rizin -d \"windbg://MyProgram.exe \\\"my arg\\\"\"\n> rizin -d \"windbg://-k net:port=<n>,key=<MyKey>\"\n> rizin -d \"windbg://-z MyDumpFile.dmp\"\nYou can then debug normally (see d? command) or interact with the backend shell directly with the R! command:\n[0x7ffcac9fcea0]> dcu 0x0007ffc98f42190\nContinue until 0x7ffc98f42190 using 1 bpsize\nModLoad: 00007ffc`ab6b0000 00007ffc`ab6e0000   C:\\WINDOWS\\System32\\IMM32.DLL\nBreakpoint 1 hit\nhit breakpoint at: 0x7ffc98f42190\n\n[0x7fffcf232190]> R!k4\nChild-SP          RetAddr           Call Site\n00000033`73b1f618 00007ff6`c67a861d r_main!r_main_rizin\n00000033`73b1f620 00007ff6`c67d0019 rizin!main+0x8d\n00000033`73b1f720 00007ff6`c67cfebe rizin!invoke_main+0x39\n00000033`73b1f770 00007ff6`c67cfd7e rizin!__scrt_common_main_seh+0x12e"
  },
  {
    "href": "src/tools/intro.html",
    "title": "60  Tools",
    "section": "",
    "text": "Rizin is not just the only tool provided by the rizin project. The rest if chapters in this book are focused on explaining the use of the rizin tool, this chapter will focus on explaining all the other companion tools that are shipped inside the rizin project.\nAll the functionalities provided by the different APIs and plugins have also different tools to allow to use them from the commandline and integrate them with shellscripts easily.\nThanks to the orthogonal design of the framework it is possible to do all the things that rizin is able from different places:\n\nthese companion tools\nnative library apis\nscripting with rz-pipe\nthe rizin shell\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-ax/intro.html",
    "title": "61  Rz-ax",
    "section": "",
    "text": "The rz-ax utility comes with the rizin framework and aims to be a minimalistic expression evaluator for the shell. It is useful for making base conversions between floating point values, hexadecimal representations, hexpair strings to ascii, octal to integer. It supports endianness and can be used as a shell if no arguments are given.\nThis is the help message of rz-ax, this tool can be used in the command-line or interactively (reading the values from stdin), so it can be used as a multi-base calculator.\nInside rizin, the functionality of rz-ax is available under the ? command. For example:\n[0x00000000]> ? 3+4\nAs you can see, the numeric expressions can contain mathematical expressions like addition, subtraction, .. as well as group operations with parenthesis.\nThe syntax in which the numbers are represented define the base, for example:\n\n3 : decimal, base 10\n0xface : hexadecimal, base 16\n0472 : octal, base 8\n2M : units, 2 megabytes\n…\n\nThis is the help message of rz-ax -h, which will show you a bunch more syntaxes\n$ rz-ax -h\nUsage: rz-ax [options] [expr ...]\n  =[base]                      ;  rz-ax =10 0x46 -> output in base 10\n  int     ->  hex              ;  rz-ax 10\n  hex     ->  int              ;  rz-ax 0xa\n  -int    ->  hex              ;  rz-ax -77\n  -hex    ->  int              ;  rz-ax 0xffffffb3\n  int     ->  bin              ;  rz-ax b30\n  int     ->  ternary          ;  rz-ax t42\n  bin     ->  int              ;  rz-ax 1010d\n  ternary ->  int              ;  rz-ax 1010dt\n  float   ->  hex              ;  rz-ax 3.33f\n  hex     ->  float            ;  rz-ax Fx40551ed8\n  oct     ->  hex              ;  rz-ax 35o\n  hex     ->  oct              ;  rz-ax Ox12 (O is a letter)\n  bin     ->  hex              ;  rz-ax 1100011b\n  hex     ->  bin              ;  rz-ax Bx63\n  ternary ->  hex              ;  rz-ax 212t\n  hex     ->  ternary          ;  rz-ax Tx23\n  raw     ->  hex              ;  rz-ax -S < /binfile\n  hex     ->  raw              ;  rz-ax -s 414141\n  -l                           ;  append newline to output (for -E/-D/-r/..\n  -a      show ascii table     ;  rz-ax -a\n  -b      bin -> str           ;  rz-ax -b 01000101 01110110\n  -B      str -> bin           ;  rz-ax -B hello\n  -d      force integer        ;  rz-ax -d 3 -> 3 instead of 0x3\n  -e      swap endianness      ;  rz-ax -e 0x33\n  -D      base64 decode        ;\n  -E      base64 encode        ;\n  -f      floating point       ;  rz-ax -f 6.3+2.1\n  -F      stdin slurp code hex ;  rz-ax -F < shellcode.[c/py/js]\n  -h      help                 ;  rz-ax -h\n  -i      dump as C byte array ;  rz-ax -i < bytes\n  -k      keep base            ;  rz-ax -k 33+3 -> 36\n  -K      randomart            ;  rz-ax -K 0x34 1020304050\n  -L      bin -> hex(bignum)   ;  rz-ax -L 111111111 # 0x1ff\n  -n      binary number        ;  rz-ax -n 0x1234 # 34120000\n  -N      binary number        ;  rz-ax -N 0x1234 # \\x34\\x12\\x00\\x00\n  -r      rizin style output      ;  rz-ax -r 0x1234\n  -s      hexstr -> raw        ;  rz-ax -s 43 4a 50\n  -S      raw -> hexstr        ;  rz-ax -S < /bin/ls > ls.hex\n  -t      tstamp -> str        ;  rz-ax -t 1234567890\n  -x      hash string          ;  rz-ax -x linux osx\n  -u      units                ;  rz-ax -u 389289238 # 317.0M\n  -w      signed word          ;  rz-ax -w 16 0xffff\n  -v      version              ;  rz-ax -v\nSome examples:\n$ rz-ax 3+0x80\n0x83\n$ rz-ax 0x80+3\n131\n$ echo 0x80+3 | rz-ax\n131\n$ rz-ax -s 4142\nAB\n$ rz-ax -S AB\n4142\n$ rz-ax -S < bin.foo\n...\n$ rz-ax -e 33\n0x21000000\n$ rz-ax -e 0x21000000\n33\n$ rz-ax -K 90203010\n+--[0x10302090]---+\n|Eo. .            |\n| . . . .         |\n|      o          |\n|       .         |\n|        S        |\n|                 |\n|                 |\n|                 |\n|                 |\n+-----------------+\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-find/intro.html",
    "title": "62  Rz-find",
    "section": "",
    "text": "rz-find is the command line frontend of the rz_search library. Which allows you to search for strings, sequences of bytes with binary masks, etc\n$ rz-find -h\nUsage: rz-find [-mXnzZhqv] [-a align] [-b sz] [-f/t from/to] [-[e|s|S] str] [-x hex] -|file|dir ..\n -a [align] only accept aligned hits\n -b [size]  set block size\n -e [regex] search for regex matches (can be used multiple times)\n -f [from]  start searching from address 'from'\n -h         show this help\n -i         identify filetype (rizin -nqcpm file)\n -j         output in JSON\n -m         magic search, file-type carver\n -M [str]   set a binary mask to be applied on keywords\n -n         do not stop on read errors\n -r         print using rizin commands\n -s [str]   search for a specific string (can be used multiple times)\n -S [str]   search for a specific wide string (can be used multiple times). Assumes str is UTF-8.\n -t [to]    stop search at address 'to'\n -q         quiet - do not show headings (filenames) above matching contents (default for searching a single file)\n -v         print version and exit\n -x [hex]   search for hexpair string (909090) (can be used multiple times)\n -X         show hexdump of search results\n -z         search for zero-terminated strings\n -Z         show string found on each search hit\nThat’s how to use it, first we’ll search for “lib” inside the /bin/ls binary.\n$ rz-find -s lib /bin/ls\n0x5f9\n0x675\n0x679\n...\n$\nNote that the output is pretty minimal, and shows the offsets where the string lib is found. We can then use this output to feed other tools.\nCounting results:\n$ rz-find -s lib /bin/ls | wc -l\nDisplaying results with context:\n$ export F=/bin/ls\n$ for a in `rz-find -s lib $F` ; do \\\n    rizin -ns $a -qc'x 32' $F ; done\n0x000005f9  6c69 622f 6479 6c64 .. lib/dyld........\n0x00000675  6c69 622f 6c69 6275 .. lib/libutil.dyli\n0x00000679  6c69 6275 7469 6c2e .. libutil.dylib...\n0x00000683  6c69 6200 000c 0000 .. lib......8......\n0x000006a5  6c69 622f 6c69 626e .. lib/libncurses.5\n0x000006a9  6c69 626e 6375 7273 .. libncurses.5.4.d\n0x000006ba  6c69 6200 0000 0c00 .. lib.......8.....\n0x000006dd  6c69 622f 6c69 6253 .. lib/libSystem.B.\n0x000006e1  6c69 6253 7973 7465 .. libSystem.B.dyli\n0x000006ef  6c69 6200 0000 0000 .. lib......&......\nrz-find can also be used as a replacement of file to identify the mimetype of a file using the internal magic database of rizin.\n$ rz-find -i /bin/ls\n0x00000000 1 Mach-O\nAlso works as a strings replacement, similar to what you do with rz-bin -z, but without caring about parsing headers and obeying binary sections.\n$ rz-find -z /bin/ls| grep http\n0x000076e5 %http://www.apple.com/appleca/root.crl0\\r\n0x00007ae6 https://www.apple.com/appleca/0\n0x00007fa9 )http://www.apple.com/certificateauthority0\n0x000080ab $http://crl.apple.com/codesigning.crl0\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-run/intro.html",
    "title": "63  Rz-run",
    "section": "",
    "text": "rz-run is a tool allowing to setup a specified execution environment - redefine stdin/stdout, pipes, change the environment variables and other settings useful to craft the boundary conditions you need to run a binary for debugging.\n$ rz-run -h\nUsage: rz-run -v|-t|script.rrz [directive ..]\nIt takes the text file in key=value format to specify the execution environment. Rz-run can be used as both separate tool or as a part of rizin. To load the rz-run profile in rizin you need to use either -r to load the profile from file or -R to specify the directive from string.\nThe format of the profile is very simple. Note the most important keys - program and arg*\nOne of the most common usage cases - redirect the output of debugged program in rizin. For this you need to use stdio, stdout, stdin, input, and a couple similar keys.\nHere is the basic profile example:\nprogram=/bin/ls\narg1=/bin\n# arg2=hello\n# arg3=\"hello\\nworld\"\n# arg4=:048490184058104849\n# arg5=:!ragg2 -p n50 -d 10:0x8048123\n# arg6=@arg.txt\n# arg7=@300@ABCD # 300 chars filled with ABCD pattern\n# system=rizin =\n# aslr=no\nsetenv=FOO=BAR\n# unsetenv=FOO\n# clearenv=true\n# envfile=environ.txt\ntimeout=3\n# timeoutsig=SIGTERM # or 15\n# connect=localhost:8080\n# listen=8080\n# pty=false\n# fork=true\n# bits=32\n# pid=0\n# pidfile=/tmp/foo.pid\n# #sleep=0\n# #maxfd=0\n# #execve=false\n# #maxproc=0\n# #maxstack=0\n# #core=false\n# #stdio=blah.txt\n# #stderr=foo.txt\n# stdout=foo.txt\n# stdin=input.txt # or !program to redirect input from another program\n# input=input.txt\n# chdir=/\n# chroot=/mnt/chroot\n# libpath=$PWD:/tmp/lib\n# rzpreload=yes\n# preload=/lib/libfoo.so\n# setuid=2000\n# seteuid=2000\n# setgid=2001\n# setegid=2001\n# nice=5\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/intro.html",
    "title": "64  Rz-bin — Show Properties of a Binary",
    "section": "",
    "text": "Rz-bin is a powerful tool to handle binaries, to get information on imports, sections, headers and other data. It can present this information in several formats accepted by other tools, including rizin itself. rz-bin understands many file formats: Java CLASS, ELF, PE, Mach-O or any format supported by plugins, and it is able to obtain symbol import/exports, library dependencies, strings of data sections, xrefs, entrypoint address, sections, architecture type.\n$ rz-bin -h\nUsage: rz-bin [-AcdeEghHiIjlLMqrRsSvVxzZ] [-@ at] [-a arch] [-b bits] [-B addr]\n              [-C F:C:D] [-f str] [-m addr] [-n str] [-N m:M] [-P[-P] pdb]\n              [-o str] [-O str] [-k query] [-D lang symname] | file\n -@ [addr]       show section, symbol or import at addr\n -A              list sub-binaries and their arch-bits pairs\n -a [arch]       set arch (x86, arm, .. or <arch>_<bits>)\n -b [bits]       set bits (32, 64 ...)\n -B [addr]       override base address (pie bins)\n -c              list classes\n -C [fmt:C:D]    create [elf,mach0,pe] with Code and Data hexpairs (see -a)\n -d              show debug/dwarf information\n -D lang name    demangle symbol name (-D all for bin.demangle=true)\n -e              entrypoint\n -E              globally exportable symbols\n -f [str]        select sub-bin named str\n -F [binfmt]     force to use that bin plugin (ignore header check)\n -g              same as -SMZIHVResizcld (show all info)\n -G [addr]       load address . offset to header\n -h              this help message\n -H              header fields\n -i              imports (symbols imported from libraries)\n -I              binary info\n -j              output in json\n -k [sdb-query]  run sdb query. for example: '*'\n -K [algo]       calculate checksums (md5, sha1, ..)\n -l              linked libraries\n -L [plugin]     list supported bin plugins or plugin details\n -m [addr]       show source line at addr\n -M              main (show address of main symbol)\n -n [str]        show section, symbol or import named str\n -N [min:max]    force min:max number of chars per string (see -z and -zz)\n -o [str]        output file/folder for write operations (out by default)\n -O [str]        write/extract operations (-O help)\n -p              show physical addresses\n -P              show debug/pdb information\n -PP             download pdb file for binary\n -q              be quiet, just show fewer data\n -qq             show less info (no offset/size for -z for ex.)\n -Q              show load address used by dlopen (non-aslr libs)\n -r              rizin output\n -R              relocations\n -s              symbols\n -S              sections\n -u              unfiltered (no rename duplicated symbols/sections)\n -v              display version and quit\n -V              Show binary version information\n -x              extract bins contained in file\n -X [fmt] [f] .. package in fat or zip the given files and bins contained in file\n -z              strings (from data section)\n -zz             strings (from raw bins [e bin.rawstr=1])\n -zzz            dump raw strings to stdout (for huge files)\n -Z              guess size of binary program\n......\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/file_identification.html",
    "title": "65  File Properties Identification",
    "section": "",
    "text": "File type identification is done using -I. With this option, rz-bin prints information on a binary type, like its encoding, endianness, class, operating system:\n$ rz-bin -I /bin/ls\narch     x86\nbinsz    128456\nbintype  elf\nbits     64\ncanary   true\nclass    ELF64\ncrypto   false\nendian   little\nhavecode true\nintrp    /lib64/ld-linux-x86-64.so.2\nlang     c\nlinenum  false\nlsyms    false\nmachine  AMD x86-64 architecture\nmaxopsz  16\nminopsz  1\nnx       true\nos       linux\npcalign  0\npic      true\nrelocs   false\nrelro    partial\nrpath    NONE\nstatic   false\nstripped true\nsubsys   linux\nva       true\nTo make rz-bin output information in format that the main program, rizin, can understand, pass -Ir option to it:\n$ rz-bin -Ir /bin/ls\ne cfg.bigendian=false\ne asm.bits=64\ne asm.dwarf=true\ne bin.lang=c\ne file.type=elf\ne asm.os=linux\ne asm.arch=x86\ne asm.pcalign=0\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/entrypoints.html",
    "title": "66  Code Entrypoints",
    "section": "",
    "text": "The -e option passed to rz-bin will show entrypoints for given binary. Two examples:\n$ rz-bin -e /bin/ls\n[Entrypoints]\nvaddr=0x00005310 paddr=0x00005310 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 type=program\n\n1 entrypoints\n\n$ rz-bin -er /bin/ls\nfs symbols\nf entry0 1 @ 0x00005310\nf entry0_haddr 1 @ 0x00000018\ns entry0\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/imports.html",
    "title": "67  Imports",
    "section": "",
    "text": "rz-bin is able to find imported objects by an executable, as well as their offsets in its PLT. This information is useful, for example, to understand what external function is invoked by call instruction. Pass -i flag to rz-bin to get a list of imports. An example:\n$ rz-bin -i /bin/ls\n[Imports]\nnth vaddr      bind   type   lib name\n―――――――――――――――――――――――――――――――――――――\n   1 0x000032e0  GLOBAL    FUNC __ctype_toupper_loc\n   2 0x000032f0  GLOBAL    FUNC getenv\n   3 0x00003300  GLOBAL    FUNC sigprocmask\n   4 0x00003310  GLOBAL    FUNC __snprintf_chk\n   5 0x00003320  GLOBAL    FUNC raise\n   6 0x00000000  GLOBAL    FUNC free\n   7 0x00003330  GLOBAL    FUNC abort\n   8 0x00003340  GLOBAL    FUNC __errno_location\n   9 0x00003350  GLOBAL    FUNC strncmp\n  10 0x00000000    WEAK  NOTYPE _ITM_deregisterTMCloneTable\n  11 0x00003360  GLOBAL    FUNC localtime_r\n  12 0x00003370  GLOBAL    FUNC _exit\n  13 0x00003380  GLOBAL    FUNC strcpy\n  14 0x00003390  GLOBAL    FUNC __fpending\n  15 0x000033a0  GLOBAL    FUNC isatty\n  16 0x000033b0  GLOBAL    FUNC sigaction\n  17 0x000033c0  GLOBAL    FUNC iswcntrl\n  18 0x000033d0  GLOBAL    FUNC wcswidth\n  19 0x000033e0  GLOBAL    FUNC localeconv\n  20 0x000033f0  GLOBAL    FUNC mbstowcs\n  21 0x00003400  GLOBAL    FUNC readlink\n...\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/exports.html",
    "title": "68  Exports",
    "section": "",
    "text": "rz-bin is able to find exports. For example:\n$ rz-bin -E /usr/lib/librz_bin.so | head\n[Exports]\n\nnth  paddr       vaddr      bind   type size lib name\n―――――――――――――――――――――――――――――――――――――――――――――――――――――\n210 0x000ae1f0 0x000ae1f0 GLOBAL   FUNC  200 r_bin_java_print_exceptions_attr_summary\n211 0x000afc90 0x000afc90 GLOBAL   FUNC  135 r_bin_java_get_args\n212 0x000b18e0 0x000b18e0 GLOBAL   FUNC   35 r_bin_java_get_item_desc_from_bin_cp_list\n213 0x00022d90 0x00022d90 GLOBAL   FUNC  204 r_bin_class_add_method\n214 0x000ae600 0x000ae600 GLOBAL   FUNC  175 r_bin_java_print_fieldref_cp_summary\n215 0x000ad880 0x000ad880 GLOBAL   FUNC  144 r_bin_java_print_constant_value_attr_summary\n216 0x000b7330 0x000b7330 GLOBAL   FUNC  679 r_bin_java_print_element_value_summary\n217 0x000af170 0x000af170 GLOBAL   FUNC   65 r_bin_java_create_method_fq_str\n218 0x00079b00 0x00079b00 GLOBAL   FUNC   15 LZ4_createStreamDecode\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/symbols.html",
    "title": "69  Symbols (Exports)",
    "section": "",
    "text": "With rz-bin, the generated symbols list format is similar to the imports list. Use the -s option to get it:\nrz-bin -s /bin/ls | head\n[Symbols]\n\nnth paddr       vaddr      bind   type   size lib name\n――――――――――――――――――――――――――――――――――――――――――――――――――――――\n110 0x000150a0 0x000150a0 GLOBAL FUNC 56 _obstack_allocated_p\n111 0x0001f600 0x0021f600 GLOBAL  OBJ  8 program_name\n112 0x0001f620 0x0021f620 GLOBAL  OBJ  8 stderr\n113 0x00014f90 0x00014f90 GLOBAL FUNC 21 _obstack_begin_1\n114 0x0001f600 0x0021f600   WEAK  OBJ  8 program_invocation_name\n115 0x0001f5c0 0x0021f5c0 GLOBAL  OBJ  8 alloc_failed_handler\n116 0x0001f5f8 0x0021f5f8 GLOBAL  OBJ  8 optarg\n117 0x0001f5e8 0x0021f5e8 GLOBAL  OBJ  8 stdout\n118 0x0001f5e0 0x0021f5e0 GLOBAL  OBJ  8 program_short_name\nWith the -sr option rz-bin produces a rizin script instead. It can later be passed to the core to automatically flag all symbols and to define corresponding byte ranges as functions and data blocks.\n$ rz-bin -sr /bin/ls | head\nfs symbols\nf sym.obstack_allocated_p 56 0x000150a0\nf sym.program_invocation_name 8 0x0021f600\nf sym.stderr 8 0x0021f620\nf sym.obstack_begin_1 21 0x00014f90\nf sym.program_invocation_name 8 0x0021f600\nf sym.obstack_alloc_failed_handler 8 0x0021f5c0\nf sym.optarg 8 0x0021f5f8\nf sym.stdout 8 0x0021f5e8\nf sym.program_invocation_short_name 8 0x0021f5e0\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/libraries.html",
    "title": "70  List Libraries",
    "section": "",
    "text": "rz-bin can list libraries used by a binary with the -l option:\n$ rz-bin -l `which rizin`\n[Linked libraries]\nlibrz_core.so\nlibrz_parse.so\nlibrz_search.so\nlibrz_cons.so\nlibrz_config.so\nlibrz_bin.so\nlibrz_debug.so\nlibrz_analysis.so\nlibrz_reg.so\nlibrz_bp.so\nlibrz_io.so\nlibrz_fs.so\nlibrz_asm.so\nlibrz_syscall.so\nlibrz_hash.so\nlibrz_magic.so\nlibrz_flag.so\nlibrz_egg.so\nlibrz_crypto.so\nlibrz_util.so\nlibpthread.so.0\nlibc.so.6\n\n22 libraries\nLets check the output with ldd command:\n$ ldd `which rizin`\nlinux-vdso.so.1 (0x00007fffba38e000)\nlibrz_core.so => /usr/lib64/librz_core.so (0x00007f94b4678000)\nlibrz_parse.so => /usr/lib64/librz_parse.so (0x00007f94b4425000)\nlibrz_search.so => /usr/lib64/librz_search.so (0x00007f94b421f000)\nlibrz_cons.so => /usr/lib64/librz_cons.so (0x00007f94b4000000)\nlibrz_config.so => /usr/lib64/librz_config.so (0x00007f94b3dfa000)\nlibrz_bin.so => /usr/lib64/librz_bin.so (0x00007f94b3afd000)\nlibrz_debug.so => /usr/lib64/librz_debug.so (0x00007f94b38d2000)\nlibrz_analysis.so => /usr/lib64/librz_analysis.so (0x00007f94b2fbd000)\nlibrz_reg.so => /usr/lib64/librz_reg.so (0x00007f94b2db4000)\nlibrz_bp.so => /usr/lib64/librz_bp.so (0x00007f94b2baf000)\nlibrz_io.so => /usr/lib64/librz_io.so (0x00007f94b2944000)\nlibrz_fs.so => /usr/lib64/librz_fs.so (0x00007f94b270e000)\nlibrz_asm.so => /usr/lib64/librz_asm.so (0x00007f94b1c69000)\nlibrz_syscall.so => /usr/lib64/librz_syscall.so (0x00007f94b1a63000)\nlibrz_hash.so => /usr/lib64/librz_hash.so (0x00007f94b185a000)\nlibrz_magic.so => /usr/lib64/librz_magic.so (0x00007f94b164d000)\nlibrz_flag.so => /usr/lib64/librz_flag.so (0x00007f94b1446000)\nlibrz_egg.so => /usr/lib64/librz_egg.so (0x00007f94b1236000)\nlibrz_crypto.so => /usr/lib64/librz_crypto.so (0x00007f94b1016000)\nlibrz_util.so => /usr/lib64/librz_util.so (0x00007f94b0d35000)\nlibpthread.so.0 => /lib64/libpthread.so.0 (0x00007f94b0b15000)\nlibc.so.6 => /lib64/libc.so.6 (0x00007f94b074d000)\nlibrz_lang.so => /usr/lib64/librz_lang.so (0x00007f94b0546000)\nlibrz_socket.so => /usr/lib64/librz_socket.so (0x00007f94b0339000)\nlibm.so.6 => /lib64/libm.so.6 (0x00007f94affaf000)\nlibdl.so.2 => /lib64/libdl.so.2 (0x00007f94afdab000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f94b4c79000)\nlibssl.so.1.0.0 => /usr/lib64/libssl.so.1.0.0 (0x00007f94afb3c000)\nlibcrypto.so.1.0.0 => /usr/lib64/libcrypto.so.1.0.0 (0x00007f94af702000)\nlibutil.so.1 => /lib64/libutil.so.1 (0x00007f94af4ff000)\nlibz.so.1 => /lib64/libz.so.1 (0x00007f94af2e8000)\nIf you compare the outputs of rz-bin -l and ldd, you will notice that rz-bin lists fewer libraries than ldd. The reason is that rz-bin does not follow and does not show dependencies of libraries. Only direct binary dependencies are shown.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/strings.html",
    "title": "71  Strings",
    "section": "",
    "text": "The -z option is used to list readable strings found in the .rodata section of ELF binaries, or the .text section of PE files. Example:\n$ rz-bin -z /bin/ls | head\n[Strings]\nnth paddr      vaddr      len size section type  string\n―――――――――――――――――――――――――――――――――――――――――――――――――――――――\n000 0x000160f8 0x000160f8  11  12 (.rodata) ascii dev_ino_pop\n001 0x00016188 0x00016188  10  11 (.rodata) ascii sort_files\n002 0x00016193 0x00016193   6   7 (.rodata) ascii posix-\n003 0x0001619a 0x0001619a   4   5 (.rodata) ascii main\n004 0x00016250 0x00016250  10  11 (.rodata) ascii ?pcdb-lswd\n005 0x00016260 0x00016260  65  66 (.rodata) ascii # Configuration file for dircolors, a utility to help you set the\n006 0x000162a2 0x000162a2  72  73 (.rodata) ascii # LS_COLORS environment variable used by GNU ls with the --color option.\n007 0x000162eb 0x000162eb  56  57 (.rodata) ascii # Copyright (C) 1996-2018 Free Software Foundation, Inc.\n008 0x00016324 0x00016324  70  71 (.rodata) ascii # Copying and distribution of this file, with or without modification,\n009 0x0001636b 0x0001636b  76  77 (.rodata) ascii # are permitted provided the copyright notice and this notice are preserved.\nWith the -zr option, this information is represented as a rizin commands list. It can be used in a rizin session to automatically create a flag space called “strings” pre-populated with flags for all strings found by rz-bin. Furthermore, this script will mark corresponding byte ranges as strings instead of code.\n$ rz-bin -zr /bin/ls | head\nfs stringsf str.dev_ino_pop 12 @ 0x000160f8\nCs 12 @ 0x000160f8\nf str.sort_files 11 @ 0x00016188\nCs 11 @ 0x00016188\nf str.posix 7 @ 0x00016193\nCs 7 @ 0x00016193\nf str.main 5 @ 0x0001619a\nCs 5 @ 0x0001619a\nf str.pcdb_lswd 11 @ 0x00016250\nCs 11 @ 0x00016250\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-bin/program_sections.html",
    "title": "72  Program Sections",
    "section": "",
    "text": "rz-bin called with the -S option gives complete information about the sections of an executable. For each section the index, offset, size, alignment, type and permissions, are shown. The next example demonstrates this:\n$ rz-bin -S /bin/ls\n[Sections]\n\nnth paddr          size vaddr         vsize perm name\n―――――――――――――――――――――――――――――――――――――――――――――――――――――\n00 0x00000000     0 0x00000000     0 ----\n01 0x00000238    28 0x00000238    28 -r-- .interp\n02 0x00000254    32 0x00000254    32 -r-- .note.ABI_tag\n03 0x00000278   176 0x00000278   176 -r-- .gnu.hash\n04 0x00000328  3000 0x00000328  3000 -r-- .dynsym\n05 0x00000ee0  1412 0x00000ee0  1412 -r-- .dynstr\n06 0x00001464   250 0x00001464   250 -r-- .gnu.version\n07 0x00001560   112 0x00001560   112 -r-- .gnu.version_r\n08 0x000015d0  4944 0x000015d0  4944 -r-- .rela.dyn\n09 0x00002920  2448 0x00002920  2448 -r-- .rela.plt\n10 0x000032b0    23 0x000032b0    23 -r-x .init\n11 0x000032d0  1648 0x000032d0  1648 -r-x .plt\n12 0x00003940    24 0x00003940    24 -r-x .plt.got\n13 0x00003960 73931 0x00003960 73931 -r-x .text\n14 0x00015a2c     9 0x00015a2c     9 -r-x .fini\n15 0x00015a40 20201 0x00015a40 20201 -r-- .rodata\n16 0x0001a92c  2164 0x0001a92c  2164 -r-- .eh_frame_hdr\n17 0x0001b1a0 11384 0x0001b1a0 11384 -r-- .eh_frame\n18 0x0001e390     8 0x0021e390     8 -rw- .init_array\n19 0x0001e398     8 0x0021e398     8 -rw- .fini_array\n20 0x0001e3a0  2616 0x0021e3a0  2616 -rw- .data.rel.ro\n21 0x0001edd8   480 0x0021edd8   480 -rw- .dynamic\n22 0x0001efb8    56 0x0021efb8    56 -rw- .got\n23 0x0001f000   840 0x0021f000   840 -rw- .got.plt\n24 0x0001f360   616 0x0021f360   616 -rw- .data\n25 0x0001f5c8     0 0x0021f5e0  4824 -rw- .bss\n26 0x0001f5c8   232 0x00000000   232 ---- .shstrtab\nWith the -Sr option, rz-bin will flag the start/end of every section, and will pass the rest of information as a comment.\n$ rz-bin -Sr /bin/ls | head\nfs sections\n\"f section. 1 0x00000000\"\n\"f section..interp 1 0x000002a8\"\n\"f section..note.gnu.build_id 1 0x000002c4\"\n\"f section..note.ABI_tag 1 0x000002e8\"\n\"f section..gnu.hash 1 0x00000308\"\n\"f section..dynsym 1 0x000003b8\"\n\"f section..dynstr 1 0x00000fb8\"\n\"f section..gnu.version 1 0x00001574\"\n\"f section..gnu.version_r 1 0x00001678\"\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-diff/intro.html",
    "title": "73  Rz-diff",
    "section": "",
    "text": "rz-diff is a tool designed to compare binary files, similar to how regular diff compares text files.\n$ rz-diff -h\nUsage: rz-diff [options] <file0> <file1>\n  -a [arch] specify architecture plugin to use (x86, arm, ..)\n  -b [bits] specify register size for arch (16 (thumb), 32, 64, ..)\n  -d [algo] compute edit distance based on the choosen algorithm:\n              myers | Eugene W. Myers' O(ND) algorithm (no substitution)\n              leven | Levenshtein O(N^2) algorithm (with substitution)\n  -H        hexadecimal visual mode\n  -h        this help message\n  -j        json output\n  -q        quite output\n  -v        show version information\n  -A        compare virtual and physical addresses\n  -C        disable colors\n  -T        show timestamp information\n  -S [WxH]  sets the width and height of the terminal for visual mode\n  -0 [cmd]  input for file0 when option -t 'commands' is given.\n            the same value will be set for file1, if -1 is not set.\n  -1 [cmd]  input for file1 when option -t 'commands' is given.\n  -t [type] compute the difference between two files based on its type:\n              bytes      | compares raw bytes in the files (only for small files)\n              lines      | compares text files\n              functions  | compares functions found in the files\n              classes    | compares classes found in the files\n              command    | compares command output returned when executed in both files\n                         | requires -0 <cmd> and -1 <cmd> is optional\n              entries    | compares entries found in the files\n              fields     | compares fields found in the files\n              graphs     | compares 2 functions and outputs in graphviz/dot format\n                         | requires -0 <fcn name|offset> and -1 <fcn name|offset> is optional\n              imports    | compares imports found in the files\n              libraries  | compares libraries found in the files\n              sections   | compares sections found in the files\n              strings    | compares strings found in the files\n              symbols    | compares symbols found in the files\n  palette colors can be changed by adding the following lines\n          inside the $HOME/.rizinrc file\n  ec diff.unknown blue   | offset color\n  ec diff.match   green  | match color\n  ec diff.unmatch red    | mismatch color\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/tools/rz-diff/binary_diffing.html#distance",
    "title": "74  Rz-Diff (binary and text diffing utility)",
    "section": "74.1 Distance",
    "text": "For bulk processing, you may want to have a higher-level overview of differences.\nThe -d option serves to calculate the distance between the two binaries using either myers algorithm or the levenshtein algorithm.\n -d --------> myers (myers algorithm)\n       |----> leven (levenshtein algorithm)\n\n74.1.1 Myers algorithm:\nIn the Myers algorithm for edit distance, the cost of an insertion or deletion is 1 and the cost of a replacement is 2. The theorem leads directly to an O(k) algorithm for incrementally computing a new solution from an old one, as contrasts the O(k2 ) time required to compute a solution from scratch. Thus the algorithm performs well when the two strings are similar.\nrz-diff -d myers /bin/true /bin/false\noutput:\nsimilarity: 0.974\ndistance: 2046\n\n\n74.1.2 Levenshtein distance:\nLevenshtein distance is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other.\nrz-diff -d leven /bin/true /bin/false\noutput:\nsimilarity: 0.974\ndistance: 2046"
  },
  {
    "href": "src/tools/rz-diff/binary_diffing.html#hexadecimal-diffing",
    "title": "74  Rz-Diff (binary and text diffing utility)",
    "section": "74.2 Hexadecimal Diffing:",
    "text": "-H The hexadecimal displays the hexdump of file0 vs file1 in a side-by-side window. Navigational keys allows easily parsing through the hexdump of the files individually.\n\n1 and 2 : to move to the next or previous page.\nZ and A : allows parsing forward and backward through file0, byte by byte.\nC and D : allows parsing forward and backward through file1, byte by byte.\nG and B : seeks the end and beginning of the files.\nN and M : takes you to the Next and the Previous differing byte in the files respectively.\n/\\ and \\/ : parsing both binaries simultaneously, 16 bytes a time.\n< and > : parsing both binaries simultaneously, by 1 byte.\n: <seek address in hex/decimal> : seeks the address provided and bring the window to start dump from the seeked address.\n? : shows the help screen in the visual mode which can be exited with ‘q’/esc keys.\n\nThe bytes that differ are: rz-diff -H /bin/true /bin/false\n.---------- [   0 | 9958]( true )-------------------------------------------------------------------- [   0 | 9958]( false )---------------------------------------------------------.\n|                      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F                                             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F                     |\n|0x0000000000000000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............ | 0x0000000000000000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............ |\n|0x0000000000000010 | 03 00 3e 00 01 00 00 00 10 26 00 00 00 00 00 00  | ..>......&...... | 0x0000000000000010 | 03 00 3e 00 01 00 00 00 20 26 00 00 00 00 00 00  | ..>..... &...... |\n|0x0000000000000020 | 40 00 00 00 00 00 00 00 d8 91 00 00 00 00 00 00  | @............... | 0x0000000000000020 | 40 00 00 00 00 00 00 00 d8 91 00 00 00 00 00 00  | @............... |\n|0x0000000000000030 | 00 00 00 00 40 00 38 00 0d 00 40 00 1e 00 1d 00  | ....@.8...@..... | 0x0000000000000030 | 00 00 00 00 40 00 38 00 0d 00 40 00 1e 00 1d 00  | ....@.8...@..... |\n|0x0000000000000040 | 06 00 00 00 04 00 00 00 40 00 00 00 00 00 00 00  | ........@....... | 0x0000000000000040 | 06 00 00 00 04 00 00 00 40 00 00 00 00 00 00 00  | ........@....... |\n|0x0000000000000050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@....... | 0x0000000000000050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@....... |\n|0x0000000000000060 | d8 02 00 00 00 00 00 00 d8 02 00 00 00 00 00 00  | ................ | 0x0000000000000060 | d8 02 00 00 00 00 00 00 d8 02 00 00 00 00 00 00  | ................ |\n|0x0000000000000070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................ | 0x0000000000000070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................ |\n|0x0000000000000080 | 18 03 00 00 00 00 00 00 18 03 00 00 00 00 00 00  | ................ | 0x0000000000000080 | 18 03 00 00 00 00 00 00 18 03 00 00 00 00 00 00  | ................ |\n|0x0000000000000090 | 18 03 00 00 00 00 00 00 1c 00 00 00 00 00 00 00  | ................ | 0x0000000000000090 | 18 03 00 00 00 00 00 00 1c 00 00 00 00 00 00 00  | ................ |\n\n...\n|0x00000000000002f0 | 30 9c 00 00 00 00 00 00 30 9c 00 00 00 00 00 00  | 0.......0....... | 0x00000000000002f0 | 30 9c 00 00 00 00 00 00 30 9c 00 00 00 00 00 00  | 0.......0....... |\n|0x0000000000000300 | d0 03 00 00 00 00 00 00 d0 03 00 00 00 00 00 00  | ................ | 0x0000000000000300 | d0 03 00 00 00 00 00 00 d0 03 00 00 00 00 00 00  | ................ |\n`------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'\n 1 2 -/+0x320 | Z A file0 +/-1 | C D file1 +/-1 | G B end/begin | N M next/prev | \\//\\ +/-16 | < >  +/-1 | : seek\n\n-S mode allows you to adjust the window size of the hexadecimal view to your preference. Minimmum: W = 120 H = 20\nExample : rz-diff -HS 120x20 /bin/true /bin/false\n\n74.2.1 File Type Based Diffing\nt option computes the difference between two files based on its type.\n -t --------> bytes (raw bytes in the files)\n       |----> lines (compares text files)\n       |----> functions (compares functions found in the files)\n       |----> classes (compares classes found in the files)\n       |----> command (compares command output returned when executed)\n       |----> entries (compares entries found in the files)\n       |----> fields (compares fields found in the files)\n       |----> graphs (compares 2 functions and outputs in graphviz/dot      format)\n       |----> format (compares text files)\n       |----> imports (compares imports found in the files)\n       |----> libraries (compares libraries found in the files)\n       |----> sections (compares sections found in the files)\n       |----> strings (compares sections found in the files)\n       |----> symbols (compares symbols found in the files)\n\n\n\n74.2.2 Diffing ASCII-text files:\n$ rz-diff -t lines genuine cracked\n--- genuine\n+++ cracked\n@@ -1,1 +1,1 @@\n-hello1234567890\n+1234567890hello\n\n\n74.2.3 Diffing functions in binaries:\nIt this mode, it will give you three columns for all functions: “First file offset”, “Percentage of matching” and “Second file offset”.\n$ rz-diff -t functions /bin/true /bin/false\n         sym.imp.__fprintf_chk   11 0x00000000000024e0 | MATCH   (1.000000) | 0x00000000000024e0    11 sym.imp.__fprintf_chk\n               sym.imp.mbsinit   11 0x00000000000024f0 | MATCH   (1.000000) | 0x00000000000024f0    11 sym.imp.mbsinit\n              sym.imp.iswprint   11 0x0000000000002500 | MATCH   (1.000000) | 0x0000000000002500    11 sym.imp.iswprint\n         sym.imp.__ctype_b_loc   11 0x0000000000002510 | MATCH   (1.000000) | 0x0000000000002510    11 sym.imp.__ctype_b_loc\n                  fcn.00002640   34 0x0000000000002640 | UNMATCH (0.058824) | 0x0000000000002650    34 fcn.00002650\n                  fcn.00002700  840 0x0000000000002700 | UNMATCH (0.221163) | 0x0000000000002710   840 fcn.00002710\n                  fcn.00002b30  176 0x0000000000002b30 | UNMATCH (0.173077) | 0x0000000000002b40   176 fcn.00002b40\n                  fcn.00002bf0  208 0x0000000000002bf0 | SIMILAR (0.961538) | 0x0000000000002c00   208 fcn.00002c00\n                  fcn.00002cd0 4627 0x0000000000002cd0 | SIMILAR (0.993949) | 0x0000000000002ce0  4627 fcn.00002ce0\n\n\n74.2.4 Diffing classes in binaries:\nrz-diff -t functions /bin/true /bin/false\n--- /bin/true\n+++ /bin/false\n\n\n74.2.5 Commands\n\n\n74.2.6 Diffing entries in binaries\nrz-diff -t entries /bin/true /bin/false\n--- /bin/true\n+++ /bin/false\n@@ -1,3 +1,3 @@\n-virt: 0x00000000000026f0 phys: 0x00000000000026f0 entry init\n-virt: 0x00000000000026b0 phys: 0x00000000000026b0 entry fini\n-virt: 0x0000000000002610 phys: 0x0000000000002610 entry program\n+virt: 0x0000000000002700 phys: 0x0000000000002700 entry init\n+virt: 0x00000000000026c0 phys: 0x00000000000026c0 entry fini\n+virt: 0x0000000000002620 phys: 0x0000000000002620 entry program\n\n\n\n74.2.7 Diffing fields in binaries:\nrz-diff -t fields /bin/true /bin/false\n--- /bin/true\n+++ /bin/false\n\n\n74.2.8 Diffing sections in binaries:\nrz-diff -t sections /bin/true /bin/false\n\n--- /bin/true\n+++ /bin/false\n\n\n74.2.9 Diffing strings in binaries:\nrz-diff -t strings /bin/true /bin/false\n--- /bin/true\n+++ /bin/false\n@@ -11,7 +11,7 @@\n Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\n Copyright %s %d Free Software Foundation, Inc.\n       --help     display this help and exit\\n\n-Exit with a status code indicating success.\n+Exit with a status code indicating failure.\n Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\n Written by %s, %s, %s,\\n%s, %s, and %s.\\n\n https://www.gnu.org/software/coreutils/\n@@ -51,7 +51,7 @@\n --help\n ASCII\n POSIX\n+false\n shell\n %s\\n\\n\n 8.30\n-true\n\n\n\n74.2.10 Diffing symbols in binaries:\nrz-diff -t symbols /bin/true /bin/false\n--- /bin/true\n+++ /bin/false"
  },
  {
    "href": "src/plugins/intro.html#types-of-plugins",
    "title": "75  Plugins",
    "section": "75.1 Types of plugins",
    "text": "$ ls librz/*/p | grep : | awk -F / '{ print $2 }'\nanalysis  # analysis plugins\nasm       # assembler/disassembler plugins\nbin       # binary format parsing plugins\nbp        # breakpoint plugins\ncore      # core plugins (implement new commands)\ncrypto    # encrypt/decrypt/hash/...\ndebug     # debugger backends\negg       # shellcode encoders, etc\nio        # io plugins\nlang      # embedded scripting languages\nparse     # disassembler parsing plugins\nreg       # arch register logic"
  },
  {
    "href": "src/plugins/intro.html#listing-plugins",
    "title": "75  Plugins",
    "section": "75.2 Listing plugins",
    "text": "Some rizin tools have the -L flag to list all the plugins associated to the functionality.\nrz-asm -L   # list asm plugins\nrizin -L    # list io plugins\nrz-bin -L   # list bin plugins\nrz-hash -L  # list hash/crypto/encoding plugins\nThere are more plugins in rizin ecosystem, we can list them from inside rizin, and this is done by using the L suffix.\nThose are some of the commands:\nL          # list core plugins\niL         # list bin plugins\ndL         # list debug plugins\nph         # print support hash algorithms\nwoD?/woE?  # print support crypto/encoding algorithms\nYou can use the ? as value to get the possible values in the associated eval vars.\ne asm.arch=?   # list assembler/disassembler plugins\ne analysis.arch=?  # list analysis plugins"
  },
  {
    "href": "src/plugins/intro.html#notes",
    "title": "75  Plugins",
    "section": "75.3 Notes",
    "text": "Note there are some inconsistencies that most likely will be fixed in the future rizin versions."
  },
  {
    "href": "src/plugins/ioplugins.html",
    "title": "76  IO plugins",
    "section": "",
    "text": "All access to files, network, debugger and all input/output in general is wrapped by an IO abstraction layer that allows rizin to treat all data as if it were just a file.\nIO plugins are the ones used to wrap the open, read, write and ‘system’ on virtual file systems. You can make rizin understand anything as a plain file. E.g. a socket connection, a remote rizin session, a file, a process, a device, a gdb session.\nSo, when rizin reads a block of bytes, it is the task of an IO plugin to get these bytes from any place and put them into internal buffer. An IO plugin is chosen by a file’s URI to be opened. Some examples:\n\nDebugging URIs\n\n$ rizin dbg:///bin/ls<br />\n$ rizin pid://1927\n\nRemote sessions\n\n$ rizin rap://:1234<br />\n$ rizin rap://<host>:1234//bin/ls\n\nVirtual buffers\n\n$ rizin malloc://512<br />\nshortcut for\n$ rizin =\nYou can get a list of the rizin IO plugins by typing rizin -L:\n$ rizin -L\nrw_  ar       Open ar/lib files [ar|lib]://[file//path] (LGPL3)\nrw_  bfdbg    BrainFuck Debugger (bfdbg://path/to/file) (LGPL3)\nrwd  bochs    Attach to a BOCHS debugger (LGPL3)\nr_d  debug    Native debugger (dbg:///bin/ls dbg://1388 pidof:// waitfor://) (LGPL3) v0.2.0 pancake\nrw_  default  open local files using def_mmap:// (LGPL3)\nrwd  gdb      Attach to gdbserver, 'qemu -s', gdb://localhost:1234 (LGPL3)\nrw_  gprobe   open gprobe connection using gprobe:// (LGPL3)\nrw_  gzip     read/write gzipped files (LGPL3)\nrw_  http     http get (http://rada.re/) (LGPL3)\nrw_  ihex     Intel HEX file (ihex://eeproms.hex) (LGPL)\nr__  mach     mach debug io (unsupported in this platform) (LGPL)\nrw_  malloc   memory allocation (malloc://1024 hex://cd8090) (LGPL3)\nrw_  mmap     open file using mmap:// (LGPL3)\nrw_  null     null-plugin (null://23) (LGPL3)\nrw_  procpid  /proc/pid/mem io (LGPL3)\nrwd  ptrace   ptrace and /proc/pid/mem (if available) io (LGPL3)\nrwd  qnx      Attach to QNX pdebug instance, qnx://host:1234 (LGPL3)\nrw_  rzk      kernel access API io (rzk://) (LGPL3)\nrw_  rz-pipe   rz-pipe io plugin (MIT)\nrw_  rzweb    rzweb io client (rzweb://cloud.rada.re/cmd/) (LGPL3)\nrw_  rap      rizin network protocol (rap://:port rap://host:port/file) (LGPL3)\nrw_  rbuf     RBuffer IO plugin: rbuf:// (LGPL)\nrw_  self     read memory from myself using 'self://' (LGPL3)\nrw_  shm      shared memory resources (shm://key) (LGPL3)\nrw_  sparse   sparse buffer allocation (sparse://1024 sparse://) (LGPL3)\nrw_  tcp      load files via TCP (listen or connect) (LGPL3)\nrwd  windbg   Attach to a KD debugger (windbg://socket) (LGPL3)\nrwd  winedbg  Wine-dbg io and debug.io plugin for rizin (MIT)\nrw_  zip      Open zip files [apk|ipa|zip|zipall]://[file//path] (BSD)\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/plugins/dev-asm.html",
    "title": "77  Implementing a new disassembly plugin",
    "section": "",
    "text": "Rizin has modular architecture, thus adding support for a new architecture is very easy, if you are fluent in C. For various reasons it might be easier to implement it out of the tree. For this we will need to create single C file, called asm_mycpu.c and makefile for it.\nThe key thing of RzAsm plugin is a structure\nRzAsmPlugin rz_asm_plugin_mycpu = {\n    .name = \"mycpu\",\n    .license = \"LGPL3\",\n    .desc = \"MYCPU disassembly plugin\",\n    .arch = \"mycpu\",\n    .bits = 32,\n    .endian = RZ_SYS_ENDIAN_LITTLE,\n    .disassemble = &disassemble\n};\nwhere .disassemble is a pointer to disassembly function, which accepts the bytes buffer and length:\nstatic int disassemble(RzAsm *a, RzAsmOp *op, const ut8 *buf, int len)\nMakefile\nNAME=asm_snes\nRZ_PLUGIN_PATH=$(shell rizin -H RZ_USER_PLUGINS)\nLIBEXT=$(shell rizin -H LIBEXT)\nCFLAGS=-g -fPIC $(shell pkg-config --cflags rz_analyss)\nLDFLAGS=-shared $(shell pkg-config --libs rz_analysis)\nOBJS=$(NAME).o\nLIB=$(NAME).$(LIBEXT)\n\nall: $(LIB)\n\nclean:\n    rm -f $(LIB) $(OBJS)\n\n$(LIB): $(OBJS)\n    $(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(LIB)\n\ninstall:\n    cp -f asm_mycpu.$(SO_EXT) $(RZ_PLUGIN_PATH)\n\nuninstall:\n    rm -f $(RZ_PLUGIN_PATH)/asm_mycpu.$(SO_EXT)\nasm_mycpu.c\n/* rizin - LGPL - Copyright 2018 - user */\n\n#include <stdio.h>\n#include <string.h>\n#include <rz_types.h>\n#include <rz_lib.h>\n#include <rz_asm.h>\n\nstatic int disassemble(RzAsm *a, RzAsmOp *op, const ut8 *buf, int len) {\n    struct op_cmd cmd = {\n        .instr = \"\",\n        .operands = \"\"\n    };\n    if (len < 2) return -1;\n    int ret = decode_opcode (buf, len, &cmd);\n    if (ret > 0) {\n        snprintf (op->buf_asm, rz_asm_BUFSIZE, \"%s %s\",\n              cmd.instr, cmd.operands);\n    }\n    return op->size = ret;\n}\n\nRzAsmPlugin rz_asm_plugin_mycpu = {\n    .name = \"mycpu\",\n    .license = \"LGPL3\",\n    .desc = \"MYCPU disassembly plugin\",\n    .arch = \"mycpu\",\n    .bits = 32,\n    .endian = RZ_SYS_ENDIAN_LITTLE,\n    .disassemble = &disassemble\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n    .type = RZ_LIB_TYPE_ASM,\n    .data = &rz_asm_plugin_mycpu,\n    .version = RZ_VERSION\n};\n#endif\nAfter compiling rizin will list this plugin in the output:\n_d__  _8_32      mycpu        LGPL3   MYCPU\n\n77.0.1 Moving plugin into the tree\nPushing a new architecture into the main branch of rizin requires to modify several files in order to make it fit into the way the rest of plugins are built.\nList of affected files:\n\nplugins.def.cfg : add the asm.mycpu plugin name string in there\nlibrz/asm/p/mycpu.mk : build instructions\nlibrz/asm/p/asm_mycpu.c : implementation\nlibrz/include/rz_asm.h : add the struct definition in there\n\nCheck out how the NIOS II CPU disassembly plugin was implemented by reading those commits:\nImplement RzAsm plugin: https://github.com/rizinorg/rizin/commit/933dc0ef6ddfe44c88bbb261165bf8f8b531476b\nImplement RzAnalysis plugin: https://github.com/rizinorg/rizin/commit/ad430f0d52fbe933e0830c49ee607e9b0e4ac8f2\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/plugins/dev-bin.html#create-a-folder-with-file-format-name-in-librzbinformat",
    "title": "78  Implementing a new format",
    "section": "78.1 Create a folder with file format name in librz/bin/format",
    "text": "Makefile:\nNAME=bin_nes\nRZ_PLUGIN_PATH=$(shell rizin -H RZ_USER_PLUGINS)\nLIBEXT=$(shell rizin -H LIBEXT)\nCFLAGS=-g -fPIC $(shell pkg-config --cflags rz_bin)\nLDFLAGS=-shared $(shell pkg-config --libs rz_bin)\nOBJS=$(NAME).o\nLIB=$(NAME).$(LIBEXT)\n\nall: $(LIB)\n\nclean:\n    rm -f $(LIB) $(OBJS)\n\n$(LIB): $(OBJS)\n    $(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(LIB)\n\ninstall:\n    cp -f $(NAME).$(SO_EXT) $(RZ_PLUGIN_PATH)\n\nuninstall:\n    rm -f $(RZ_PLUGIN_PATH)/$(NAME).$(SO_EXT)\nbin_nes.c:\n#include <rz_util.h>\n#include <rz_bin.h>\n\nstatic bool load_buffer(RzBinFile *bf, void **bin_obj, RzBuffer *b, ut64 loadaddr, Sdb *sdb) {\n    ut64 size;\n    const ut8 *buf = rz_buf_data (b, &size);\n    rz_return_val_if_fail (buf, false);\n    *bin_obj = rz_bin_internal_nes_load (buf, size);\n    return *bin_obj != NULL;\n}\n\nstatic void destroy(RzBinFile *bf) {\n    rz_bin_free_all_nes_obj (bf->o->bin_obj);\n    bf->o->bin_obj = NULL;\n}\n\nstatic bool check_buffer(RzBuffer *b) {\n    if (!buf || length < 4) return false;\n    return (!memcmp (buf, \"\\x4E\\x45\\x53\\x1A\", 4));\n}\n\nstatic RzBinInfo* info(RzBinFile *arch) {\n    RzBinInfo \\*ret = RZ_NEW0 (RzBinInfo);\n    if (!ret) return NULL;\n\n    if (!arch || !arch->buf) {\n        free (ret);\n        return NULL;\n    }\n    ret->file = strdup (arch->file);\n    ret->type = strdup (\"ROM\");\n    ret->machine = strdup (\"Nintendo NES\");\n    ret->os = strdup (\"nes\");\n    ret->arch = strdup (\"6502\");\n    ret->bits = 8;\n\n    return ret;\n}\n\nstruct rz_bin_plugin_t rz_bin_plugin_nes = {\n    .name = \"nes\",\n    .desc = \"NES\",\n    .license = \"BSD\",\n    .get_sdb = NULL,\n    .load_buffer = &load_buffer,\n    .destroy = &destroy,\n    .check_buffer = &check_buffer,\n    .baddr = NULL,\n    .entries = NULL,\n    .sections = NULL,\n    .info = &info,\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n    .type = RZ_LIB_TYPE_BIN,\n    .data = &rz_bin_plugin_nes,\n    .version = RZ_VERSION\n};\n#endif\n\n78.1.1 Some Examples\n\nJava - https://github.com/rizinorg/rizin/commit/7cfddb1da8204587cdc1ba1a26bc07c9fee403dc\nZimgz - https://github.com/rizinorg/rizin/commit/d1351cf836df3e2e63043a6dc728e880316f00eb\nOMF - https://github.com/rizinorg/rizin/commit/44fd8b2555a0446ea759901a94c06f20566bbc40"
  },
  {
    "href": "src/plugins/dev-other.html#more-to-come..",
    "title": "79  Write a debugger plugin",
    "section": "79.1 More to come..",
    "text": "Related article: http://rizin.today/posts/extending-r2-with-new-plugins/\n\nSome commits related to “Implementing a new architecture”\n\nExtensa: https://github.com/rizinorg/rizin/commit/6f1655c49160fe9a287020537afe0fb8049085d7\nMalbolge: https://github.com/rizinorg/rizin/pull/579\n6502: https://github.com/rizinorg/rizin/pull/656\nh8300: https://github.com/rizinorg/rizin/pull/664\nGBA: https://github.com/rizinorg/rizin/pull/702\nCR16: https://github.com/rizinorg/rizin/pull/721/ && 726\nXCore: https://github.com/rizinorg/rizin/commit/bb16d1737ca5a471142f16ccfa7d444d2713a54d\nSharpLH5801: https://github.com/neuschaefer/rizin/commit/f4993cca634161ce6f82a64596fce45fe6b818e7\nMSP430: https://github.com/rizinorg/rizin/pull/1426\nHP-PA-RISC: https://github.com/rizinorg/rizin/commit/f8384feb6ba019b91229adb8fd6e0314b0656f7b\nV810: https://github.com/rizinorg/rizin/pull/2899\nTMS320: https://github.com/rizinorg/rizin/pull/596"
  },
  {
    "href": "src/plugins/dev-other.html#implementing-a-new-pseudo-architecture",
    "title": "79  Write a debugger plugin",
    "section": "79.2 Implementing a new pseudo architecture",
    "text": "This is an simple plugin for z80 that you may use as example:\nhttps://github.com/rizinorg/rizin/commit/8ff6a92f65331cf8ad74cd0f44a60c258b137a06"
  },
  {
    "href": "src/plugins/python.html",
    "title": "80  Python plugins",
    "section": "",
    "text": "At first, to be able to write a plugins in Python for rizin you need to install rz-lang plugin: rz-pm -i lang-python. Note - in the following examples there are missing functions of the actual decoding for the sake of readability!\nFor this you need to do this: 1. import rzlang and from rzlang import RZ (for constants) 2. Make a function with 2 subfunctions - assemble and disassemble and returning plugin structure - for RzAsm plugin\ndef mycpu(a):\n    def assemble(s):\n        return [1, 2, 3, 4]\n\n    def disassemble(memview, addr):\n        try:\n            opcode = get_opcode(memview) # https://docs.python.org/3/library/stdtypes.html#memoryview\n            opstr = optbl[opcode][1]\n            return [4, opstr]\n        except:\n            return [4, \"unknown\"]\n\nThis structure should contain a pointers to these 2 functions - assemble and disassemble\n\n    return {\n            \"name\" : \"mycpu\",\n            \"arch\" : \"mycpu\",\n            \"bits\" : 32,\n            \"endian\" : RZ.RZ_SYS_ENDIAN_LITTLE,\n            \"license\" : \"GPL\",\n            \"desc\" : \"MYCPU disasm\",\n            \"assemble\" : assemble,\n            \"disassemble\" : disassemble,\n    }\n\nMake a function with 2 subfunctions - set_reg_profile and op and returning plugin structure - for RzAnalysis plugin\n\ndef mycpu_analysis(a):\n       def set_reg_profile():\n        profile = \"=PC  pc\\n\" + \\\n        \"=SP    sp\\n\" + \\\n        \"gpr    r0  .32 0   0\\n\" + \\\n        \"gpr    r1  .32 4   0\\n\" + \\\n        \"gpr    r2  .32 8   0\\n\" + \\\n        \"gpr    r3  .32 12  0\\n\" + \\\n        \"gpr    r4  .32 16  0\\n\" + \\\n        \"gpr    r5  .32 20  0\\n\" + \\\n        \"gpr    sp  .32 24  0\\n\" + \\\n        \"gpr    pc  .32 28  0\\n\"\n        return profile\n\n    def op(memview, pc):\n        analysisop = {\n            \"type\" : RZ.RZ_ANALYSIS_OP_TYPE_NULL,\n            \"cycles\" : 0,\n            \"stackop\" : 0,\n            \"stackptr\" : 0,\n            \"ptr\" : -1,\n            \"jump\" : -1,\n            \"addr\" : 0,\n            \"eob\" : False,\n            \"esil\" : \"\",\n        }\n        try:\n            opcode = get_opcode(memview) # https://docs.python.org/3/library/stdtypes.html#memoryview\n            esilstr = optbl[opcode][2]\n            if optbl[opcode][0] == \"J\": # it's jump\n                analysisop[\"type\"] = RZ.RZ_ANALYSIS_OP_TYPE_JMP\n                analysisop[\"jump\"] = decode_jump(opcode, j_mask)\n                esilstr = jump_esil(esilstr, opcode, j_mask)\n\n        except:\n            result = analysisop\n        # Don't forget to return proper instruction size!\n        return [4, result]\n\nThis structure should contain a pointers to these 2 functions - set_reg_profile and op\n\n    return {\n            \"name\" : \"mycpu\",\n            \"arch\" : \"mycpu\",\n            \"bits\" : 32,\n            \"license\" : \"GPL\",\n            \"desc\" : \"MYCPU analysis\",\n            \"esil\" : 1,\n            \"set_reg_profile\" : set_reg_profile,\n            \"op\" : op,\n    }\n\nThen register those using rzlang.plugin(\"asm\") and rzlang.plugin(\"analysis\") respectively\n\nprint(\"Registering MYCPU disasm plugin...\")\nprint(rzlang.plugin(\"asm\", mycpu))\nprint(\"Registering MYCPU analysis plugin...\")\nprint(rzlang.plugin(\"analysis\", mycpu_analysis))\nYou can combine everything in one file and load it using -i option:\nrizin -I mycpu.py some_file.bin\nOr you can load it from the rizin shell: #!python mycpu.py\n\n80.0.1 Implementing new format plugin in Python\nNote - in the following examples there are missing functions of the actual decoding for the sake of readability!\nFor this you need to do this: 1. import rzlang 2. Make a function with subfunctions: - load - load_bytes - destroy - check_bytes - baddr - entries - sections - imports - relocs - binsym - info\nand returning plugin structure - for RzAsm plugin\ndef le_format(a):\n    def load(binf):\n        return [0]\n\n    def check_bytes(buf):\n        try:\n            if buf[0] == 77 and buf[1] == 90:\n                lx_off, = struct.unpack(\"<I\", buf[0x3c:0x40])\n                if buf[lx_off] == 76 and buf[lx_off+1] == 88:\n                    return [1]\n            return [0]\n        except:\n            return [0]\nand so on. Please be sure of the parameters for each function and format of returns. Note, that functions entries, sections, imports, relocs returns a list of special formed dictionaries - each with a different type. Other functions return just a list of numerical values, even if single element one. There is a special function, which returns information about the file - info:\n    def info(binf):\n        return [{\n                \"type\" : \"le\",\n                \"bclass\" : \"le\",\n                \"rclass\" : \"le\",\n                \"os\" : \"OS/2\",\n                \"subsystem\" : \"CLI\",\n                \"machine\" : \"IBM\",\n                \"arch\" : \"x86\",\n                \"has_va\" : 0,\n                \"bits\" : 32,\n                \"big_endian\" : 0,\n                \"dbg_info\" : 0,\n                }]\n\nThis structure should contain a pointers to the most important functions like check_bytes, load and load_bytes, entries, relocs, imports.\n\n    return {\n            \"name\" : \"le\",\n            \"desc\" : \"OS/2 LE/LX format\",\n            \"license\" : \"GPL\",\n            \"load\" : load,\n            \"load_bytes\" : load_bytes,\n            \"destroy\" : destroy,\n            \"check_bytes\" : check_bytes,\n            \"baddr\" : baddr,\n            \"entries\" : entries,\n            \"sections\" : sections,\n            \"imports\" : imports,\n            \"symbols\" : symbols,\n            \"relocs\" : relocs,\n            \"binsym\" : binsym,\n            \"info\" : info,\n    }\n\nThen you need to register it as a file format plugin:\n\nprint(\"Registering OS/2 LE/LX plugin...\")\nprint(rzlang.plugin(\"bin\", le_format))\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/plugins/debug.html",
    "title": "81  Debugging",
    "section": "",
    "text": "It is common to have an issues when you write a plugin, especially if you do this for the first time. This is why debugging them is very important. The first step for debugging is to set an environment variable when running rizin instance:\nR_DEBUG=yes rizin /bin/ls\nLoading /usr/local/lib/rizin/2.2.0-git//bin_xtr_dyldcache.so\nCannot find symbol 'rizin_plugin' in library '/usr/local/lib/rizin/2.2.0-git//bin_xtr_dyldcache.so'\nCannot open /usr/local/lib/rizin/2.2.0-git//2.2.0-git\nLoading /home/user/.config/rizin/plugins/asm_mips_ks.so\nPLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762\nLoading /home/user/.config/rizin/plugins/asm_sparc_ks.so\nPLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762\nCannot open /home/user/.config/rizin/plugins/pimp\nCannot open /home/user/.config/rizin/plugins/yara\nLoading /home/user/.config/rizin/plugins/asm_arm_ks.so\nPLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762\nLoading /home/user/.config/rizin/plugins/core_yara.so\nModule version mismatch /home/user/.config/rizin/plugins/core_yara.so (2.1.0) vs (2.2.0-git)\nLoading /home/user/.config/rizin/plugins/asm_ppc_ks.so\nPLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762\nLoading /home/user/.config/rizin/plugins/lang_python3.so\nPLUGIN OK 0x55b205ea5ed0 fcn 0x7f298de08692\nLoading /usr/local/lib/rizin/2.2.0-git/bin_xtr_dyldcache.so\nCannot find symbol 'rizin_plugin' in library '/usr/local/lib/rizin/2.2.0-git/bin_xtr_dyldcache.so'\nCannot open /usr/local/lib/rizin/2.2.0-git/2.2.0-git\nCannot open directory '/usr/local/lib/rizin-extras/2.2.0-git'\nCannot open directory '/usr/local/lib/rizin-bindings/2.2.0-git'\nUSER CONFIG loaded from /home/user/.config/rizin/rizinrc\n -- In visual mode press 'c' to toggle the cursor mode. Use tab to navigate\n[0x00005520]>\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/plugins/testing.html",
    "title": "82  Testing the plugin",
    "section": "",
    "text": "This plugin is used by rz-asm and rizin. You can verify that the plugin is properly loaded with this command:\n$ rz-asm -L | grep mycpu\n_d  mycpu        My CPU disassembler  (LGPL3)\nLet’s open an empty file using the ‘mycpu’ arch and write some random code there.\n$ rizin =\n -- I endians swap\n[0x00000000]> e asm.arch=mycpu\n[0x00000000]> woR\n[0x00000000]> pd 10\n           0x00000000    888e         mov r8, 14\n           0x00000002    b2a5         ifnot r10, r5\n           0x00000004    3f67         ret\n           0x00000006    7ef6         bl r15, r6\n           0x00000008    2701         xor r0, 1\n           0x0000000a    9826         mov r2, 6\n           0x0000000c    478d         xor r8, 13\n           0x0000000e    6b6b         store r6, 11\n           0x00000010    1382         add r8, r2\n           0x00000012    7f15         ret\nYay! it works.. and the mandatory oneliner too!\nrizin -nqamycpu -cwoR -cpd' 10' =\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/plugins/rz-pm.html",
    "title": "83  Creating an rz-pm package of the plugin",
    "section": "",
    "text": "As you remember rizin has its own packaging manager and we can easily add newly written plugin for everyone to access.\nAll packages are located in rizin-pm repository, and have very simple text format.\nRZPM_BEGIN\n\nRZPM_GIT \"https://github.com/user/mycpu\"\nRZPM_DESC \"[rizin-arch] MYCPU disassembler and analyzer plugins\"\n\nRZPM_INSTALL() {\n    ${MAKE} clean\n    ${MAKE} all || exit 1\n    ${MAKE} install RZPM_PLUGDIR=\"${RZPM_PLUGDIR}\"\n}\n\nRZPM_UNINSTALL() {\n    rm -f \"${RZPM_PLUGDIR}/asm_mycpu.\"*\n    rm -f \"${RZPM_PLUGDIR}/analysis_mycpu.\"*\n}\n\nRZPM_END\nThen add it in the /db directory of rizin-pm repository and send a pull request to the mainline.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/intro.html",
    "title": "84  Crackmes",
    "section": "",
    "text": "Crackmes (from “crack me” challenge) are the training ground for reverse engineering people. This section will go over tutorials on how to defeat various crackmes using rizin.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/intro.html",
    "title": "85  IOLI CrackMes",
    "section": "",
    "text": "The IOLI crackme is a good starting point for learning rizin. This is a set of tutorials based on the tutorial at dustri\nThe IOLI crackmes are available at a locally hosted mirror\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x00.html",
    "title": "86  IOLI 0x00",
    "section": "",
    "text": "This is the first IOLI crackme, and the easiest one.\n$ ./crackme0x00\nIOLI Crackme Level 0x00\nPassword: 1234\nInvalid Password!\nThe first thing to check is if the password is just plaintext inside the file. In this case, we don’t need to do any disassembly, and we can just use rz-bin with the -z flag to search for strings in the binary.\n$ rz-bin -z ./crackme0x00\n[Strings]\nnth paddr      vaddr      len size section type  string\n―――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0   0x00000568 0x08048568 24  25   .rodata ascii IOLI Crackme Level 0x00\\n\n1   0x00000581 0x08048581 10  11   .rodata ascii Password:\n2   0x0000058f 0x0804858f 6   7    .rodata ascii 250382\n3   0x00000596 0x08048596 18  19   .rodata ascii Invalid Password!\\n\n4   0x000005a9 0x080485a9 15  16   .rodata ascii Password OK :)\\n\nSo we know what the following section is, this section is the header shown when the application is run.\nnth paddr      vaddr      len size section type  string\n―――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0   0x00000568 0x08048568 24  25   .rodata ascii IOLI Crackme Level 0x00\\n\nHere we have the prompt for the password.\n1   0x00000581 0x08048581 10  11   .rodata ascii Password:\nThis is the error on entering an invalid password.\n3   0x00000596 0x08048596 18  19   .rodata ascii Invalid Password!\\n\nThis is the message on the password being accepted.\n4   0x000005a9 0x080485a9 15  16   .rodata ascii Password OK :)\\n\nWhat is this? It’s a string, but we haven’t seen it in running the application yet.\n2   0x0000058f 0x0804858f 6   7    .rodata ascii 250382\nLet’s give this a shot.\n$ ./crackme0x00\nIOLI Crackme Level 0x00\nPassword: 250382\nPassword OK :)\nSo we now know that 250382 is the password, and have completed this crackme.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x01.html",
    "title": "87  IOLI 0x01",
    "section": "",
    "text": "This is the second IOLI crackme.\n$ ./crackme0x01\nIOLI Crackme Level 0x01\nPassword: test\nInvalid Password!\nLet’s check for strings with rz-bin.\n$ rz-bin -z ./crackme0x01\n[Strings]\nnth paddr      vaddr      len size section type  string\n―――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0   0x00000528 0x08048528 24  25   .rodata ascii IOLI Crackme Level 0x01\\n\n1   0x00000541 0x08048541 10  11   .rodata ascii Password:\n2   0x0000054f 0x0804854f 18  19   .rodata ascii Invalid Password!\\n\n3   0x00000562 0x08048562 15  16   .rodata ascii Password OK :)\\n\nThis isn’t going to be as easy as 0x00. Let’s try disassembly with rizin.\n$ rizin ./crackme0x01\n-- Use `zoom.byte=printable` in zoom mode ('z' in Visual mode) to find strings\n[0x08048330]> aa\n[0x08048330]> pdf@main\n            ; DATA XREF from entry0 @ 0x8048347\n/ 113: int main (int argc, char **argv, char **envp);\n|           ; var int32_t var_4h @ ebp-0x4\n|           ; var int32_t var_sp_4h @ esp+0x4\n|           0x080483e4      55             push ebp\n|           0x080483e5      89e5           mov ebp, esp\n|           0x080483e7      83ec18         sub esp, 0x18\n|           0x080483ea      83e4f0         and esp, 0xfffffff0\n|           0x080483ed      b800000000     mov eax, 0\n|           0x080483f2      83c00f         add eax, 0xf                ; 15\n|           0x080483f5      83c00f         add eax, 0xf                ; 15\n|           0x080483f8      c1e804         shr eax, 4\n|           0x080483fb      c1e004         shl eax, 4\n|           0x080483fe      29c4           sub esp, eax\n|           0x08048400      c70424288504.  mov dword [esp], str.IOLI_Crackme_Level_0x01 ; [0x8048528:4]=0x494c4f49 ; \"IOLI Crackme Level 0x01\\n\"\n|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)\n|           0x0804840c      c70424418504.  mov dword [esp], str.Password: ; [0x8048541:4]=0x73736150 ; \"Password: \"\n|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)\n|           0x08048418      8d45fc         lea eax, [var_4h]\n|           0x0804841b      89442404       mov dword [var_sp_4h], eax\n|           0x0804841f      c704244c8504.  mov dword [esp], 0x804854c  ; [0x804854c:4]=0x49006425\n|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)\n|           0x0804842b      817dfc9a1400.  cmp dword [var_4h], 0x149a\n|       ,=< 0x08048432      740e           je 0x8048442\n|       |   0x08048434      c704244f8504.  mov dword [esp], str.Invalid_Password ; [0x804854f:4]=0x61766e49 ; \"Invalid Password!\\n\"\n|       |   0x0804843b      e8dcfeffff     call sym.imp.printf         ; int printf(const char *format)\n|      ,==< 0x08048440      eb0c           jmp 0x804844e\n|      |`-> 0x08048442      c70424628504.  mov dword [esp], str.Password_OK_: ; [0x8048562:4]=0x73736150 ; \"Password OK :)\\n\"\n|      |    0x08048449      e8cefeffff     call sym.imp.printf         ; int printf(const char *format)\n|      |    ; CODE XREF from main @ 0x8048440\n|      `--> 0x0804844e      b800000000     mov eax, 0\n|           0x08048453      c9             leave\n\\           0x08048454      c3             ret\n“aa” tells rizin to analyze the whole binary, which gets you symbol names, among things.\n“pdf” stands for\n\nPrint\nDisassemble\nFunction\n\nThis will print the disassembly of the main function, or the main() that everyone knows. You can see several things as well: weird names, arrows, etc.\n\n“imp.” stands for imports. Those are imported symbols, like printf()\n“str.” stands for strings. Those are strings (obviously).\n\nIf you look carefully, you’ll see a cmp instruction, with a constant, 0x149a. cmp is an x86 compare instruction, and the 0x in front of it specifies it is in base 16, or hex (hexadecimal).\n0x0804842b    817dfc9a140. cmp dword [ebp + 0xfffffffc], 0x149a\nYou can use rizin’s ? command to display 0x149a in another numeric base.\n[0x08048330]> ? 0x149a\nint32   5274\nuint32  5274\nhex     0x149a\noctal   012232\nunit    5.2K\nsegment 0000:049a\nstring  \"\\x9a\\x14\"\nfvalue: 5274.0\nfloat:  0.000000f\ndouble: 0.000000\nbinary  0b0001010010011010\ntrits   0t21020100\nSo now we know that 0x149a is 5274 in decimal. Let’s try this as a password.\n$ ./crackme0x01\nIOLI Crackme Level 0x01\nPassword: 5274\nPassword OK :)\nBingo, the password was 5274. In this case, the password function at 0x0804842b was comparing the input against the value, 0x149a in hex. Since user input is usually decimal, it was a safe bet that the input was intended to be in decimal, or 5274. Now, since we’re hackers, and curiosity drives us, let’s see what happens when we input in hex.\n$ ./crackme0x01\nIOLI Crackme Level 0x01\nPassword: 0x149a\nInvalid Password!\nIt was worth a shot, but it doesn’t work. That’s because scanf() will take the 0 in 0x149a to be a zero, rather than accepting the input as actually being the hex value.\nAnd this concludes IOLI 0x01.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x02.html",
    "title": "88  IOLI 0x02",
    "section": "",
    "text": "This is the third one.\n$ ./crackme0x02\nIOLI Crackme Level 0x02\nPassword: hello\nInvalid Password!\nFirstly, let’s check it with rz-bin.\n$ rz-bin -z ./crackme0x02\n[Strings]\nnth paddr      vaddr      len size section type  string\n―――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0   0x00000548 0x08048548 24  25   .rodata ascii IOLI Crackme Level 0x02\\n\n1   0x00000561 0x08048561 10  11   .rodata ascii Password:\n2   0x0000056f 0x0804856f 15  16   .rodata ascii Password OK :)\\n\n3   0x0000057f 0x0804857f 18  19   .rodata ascii Invalid Password!\\n\nSimilar to 0x01, there’s no explicit password string here. So, it’s time to analyze it with Rizin.\n[0x08048330]> aa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[0x08048330]> pdf@main\n            ; DATA XREF from entry0 @ 0x8048347\n/ 144: int main (int argc, char **argv, char **envp);\n|           ; var int32_t var_ch @ ebp-0xc\n|           ; var int32_t var_8h @ ebp-0x8\n|           ; var int32_t var_4h @ ebp-0x4\n|           ; var int32_t var_sp_4h @ esp+0x4\n|           0x080483e4      55             push ebp\n|           0x080483e5      89e5           mov ebp, esp\n|           0x080483e7      83ec18         sub esp, 0x18\n|           0x080483ea      83e4f0         and esp, 0xfffffff0\n|           0x080483ed      b800000000     mov eax, 0\n|           0x080483f2      83c00f         add eax, 0xf                ; 15\n|           0x080483f5      83c00f         add eax, 0xf                ; 15\n|           0x080483f8      c1e804         shr eax, 4\n|           0x080483fb      c1e004         shl eax, 4\n|           0x080483fe      29c4           sub esp, eax\n|           0x08048400      c70424488504.  mov dword [esp], str.IOLI_Crackme_Level_0x02 ; [0x8048548:4]=0x494c4f49 ; \"IOLI Crackme Level 0x02\\n\"\n|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)\n|           0x0804840c      c70424618504.  mov dword [esp], str.Password: ; [0x8048561:4]=0x73736150 ; \"Password: \"\n|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)\n|           0x08048418      8d45fc         lea eax, [var_4h]\n|           0x0804841b      89442404       mov dword [var_sp_4h], eax\n|           0x0804841f      c704246c8504.  mov dword [esp], 0x804856c  ; [0x804856c:4]=0x50006425\n|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)\n|           0x0804842b      c745f85a0000.  mov dword [var_8h], 0x5a    ; 'Z' ; 90\n|           0x08048432      c745f4ec0100.  mov dword [var_ch], 0x1ec   ; 492\n|           0x08048439      8b55f4         mov edx, dword [var_ch]\n|           0x0804843c      8d45f8         lea eax, [var_8h]\n|           0x0804843f      0110           add dword [eax], edx\n|           0x08048441      8b45f8         mov eax, dword [var_8h]\n|           0x08048444      0faf45f8       imul eax, dword [var_8h]\n|           0x08048448      8945f4         mov dword [var_ch], eax\n|           0x0804844b      8b45fc         mov eax, dword [var_4h]\n|           0x0804844e      3b45f4         cmp eax, dword [var_ch]\n|       ,=< 0x08048451      750e           jne 0x8048461\n|       |   0x08048453      c704246f8504.  mov dword [esp], str.Password_OK_: ; [0x804856f:4]=0x73736150 ; \"Password OK :)\\n\"\n|       |   0x0804845a      e8bdfeffff     call sym.imp.printf         ; int printf(const char *format)\n|      ,==< 0x0804845f      eb0c           jmp 0x804846d\n|      |`-> 0x08048461      c704247f8504.  mov dword [esp], str.Invalid_Password ; [0x804857f:4]=0x61766e49 ; \"Invalid Password!\\n\"\n|      |    0x08048468      e8affeffff     call sym.imp.printf         ; int printf(const char *format)\n|      |    ; CODE XREF from main @ 0x804845f\n|      `--> 0x0804846d      b800000000     mov eax, 0\n|           0x08048472      c9             leave\n\\           0x08048473      c3             ret\n\nWith the experience of solving crackme0x01, we can first locate the position of cmp instruction by using this simple oneliner:\n[0x08048330]> pdf@main~cmp\n|           0x0804844e      3b45f4         cmp eax, dword [var_ch]\nUnfortunately, the variable compared to eax is stored in the stack. We can’t check the value of this variable directly. It’s a common case in reverse engineering that we have to derive the value of the variable from the previous sequence. As the amount of code is relatively small, it can be easily done.\nfor example:\n|           0x080483ed      b800000000     mov eax, 0\n|           0x080483f2      83c00f         add eax, 0xf                ; 15\n|           0x080483f5      83c00f         add eax, 0xf                ; 15\n|           0x080483f8      c1e804         shr eax, 4\n|           0x080483fb      c1e004         shl eax, 4\n|           0x080483fe      29c4           sub esp, eax\nWe can easily get the value of eax. It’s 16.\nDirectly looking at the disassembly gets hard when the scale of program grows. Rizin’s flagship decompiler rz-ghidra might be of help, here. You can install it easily:\nrz-pm -i rz-ghidra\nDecompile main() with the following command (like F5 in IDA):\n[0x08048330]> pdg\nundefined4 main(void)\n{\n    uint32_t var_ch;\n    undefined4 var_8h;\n    int32_t var_4h;\n    \n    printf(\"IOLI Crackme Level 0x02\\n\");\n    printf(\"Password: \");\n    scanf(0x804856c, &var_4h);\n    if (var_4h == 0x52b24) {\n        printf(\"Password OK :)\\n\");\n    } else {\n        printf(\"Invalid Password!\\n\");\n    }\n    return 0;\n}\nIt’s more human-readable now. To check the string in 0x804856c, we can: * Seek * Print the string\n[0x08048330]> s 0x804856c\n[0x0804856c]> ps\n%d\nIt’s exactly the format string of scanf(). And rz-ghidra recognizes that the second argument (eax) is a pointer and it points to var_4h. Which means our input will be stored in var_4h.\nWe can easily write out the pseudo code here.\nvar_ch = (var_8h + var_ch)^2;\nif (var_ch == our_input)\n  printf(\"Password OK :)\\n\");\nGiven the initial status that var_8h is 0x5a, var_ch is 0x1ec, we have var_ch = 338724 (0x52b24):\n$ rz-ax '=10' '(0x5a+0x1ec)*(0x5a+0x1ec)'\n338724\n\n$ ./crackme0x02\nIOLI Crackme Level 0x02\nPassword: 338724\nPassword OK :)\nAnd we finish the crackme0x02.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x03.html",
    "title": "89  IOLI 0x03",
    "section": "",
    "text": "crackme 0x03, let’s skip the string check part and analyze it directly.\n[0x08048360]> aaa\n[0x08048360]> pdd@sym.main\n/* jsdec pseudo code output */\n/* ./crackme0x03 @ 0x8048498 */\n#include <stdint.h>\n\nint32_t main (void) {\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    int32_t var_sp_4h;\n    eax = 0;\n    eax += 0xf;\n    eax += 0xf;\n    eax >>= 4;\n    eax <<= 4;\n    printf (\"IOLI Crackme Level 0x03\\n\");\n    printf (\"Password: \");\n    eax = &var_4h;\n    scanf (0x8048634, eax);\n    var_8h = 0x5a;\n    var_ch = 0x1ec;\n    edx = 0x1ec;\n    eax = &var_8h;\n    *(eax) += edx;\n    eax = var_8h;\n    eax *= var_8h;\n    var_ch = eax;\n    eax = var_4h;\n    test (eax, eax);\n    eax = 0;\n    return eax;\n}\nIt looks straightforward except the function test(eax, eax). This is unusual to call a function with same two parameters , so I speculate that the decompiler has gone wrong. we can check it in disassembly.\n[0x08048360]> pdf@sym.main\n...\n           0x080484fc      8945f4         mov dword [var_ch], eax\n           0x080484ff      8b45f4         mov eax, dword [var_ch]\n           0x08048502      89442404       mov dword [var_sp_4h], eax   ; uint32_t arg_ch\n           0x08048506      8b45fc         mov eax, dword [var_4h]\n           0x08048509      890424         mov dword [esp], eax         ; int32_t arg_8h\n           0x0804850c      e85dffffff     call sym.test\n...\nHere comes thesym.test, called with two parameters. One is var_4h (our input from scanf()). The other is var_ch. The value of var_ch (as the parameter of test()) can be calculated like it did in crackme_0x02. It’s 0x52b24. Try it!\n./crackme0x03\nIOLI Crackme Level 0x03\nPassword: 338724\nPassword OK!!! :)\nTake a look at sym.test. It’s a two path conditional jump which compares two parameters and then do shift. We can guess that shift is most likely the decryption part (shift cipher, e.g. Caesar cipher).\n/* jsdec pseudo code output */\n/* ./crackme0x03 @ 0x804846e */\n#include <stdint.h>\n\nint32_t test (int32_t arg_8h, uint32_t arg_ch) {\n    eax = arg_8h;\n    if (eax != arg_ch) {\n        shift (\"Lqydolg#Sdvvzrug$\");\n    } else {\n        shift (\"Sdvvzrug#RN$$$#=,\");\n    }\n    return eax;\n}\ncan also reverse shift() to satisfy curiosity.\n[0x08048360]> pdf@sym.shift\n        ; CODE (CALL) XREF 0x08048491 (sym.test)\n        ; CODE (CALL) XREF 0x08048483 (sym.test)\n/ function: sym.shift (90)\n|       0x08048414  sym.shift:\n|       0x08048414     55               push ebp\n|       0x08048415     89e5             mov ebp, esp\n|       0x08048417     81ec98000000     sub esp, 0x98\n|       0x0804841d     c7458400000000   mov dword [ebp-0x7c], 0x0  ; this seems to be a counter\n|  .    ; CODE (JMP) XREF 0x0804844e (sym.shift)\n/ loc: loc.08048424 (74)\n|  .    0x08048424  loc.08048424:\n|  .--> 0x08048424     8b4508           mov eax, [ebp+0x8] ; ebp+0x8 = strlen(chain)\n|  |    0x08048427     890424           mov [esp], eax\n|  |    0x0804842a     e811ffffff       call dword imp.strlen\n|  |       ; imp.strlen()\n|  |    0x0804842f     394584           cmp [ebp-0x7c], eax\n|  |,=< 0x08048432     731c             jae loc.08048450\n|  ||   0x08048434     8d4588           lea eax, [ebp-0x78]\n|  ||   0x08048437     89c2             mov edx, eax\n|  ||   0x08048439     035584           add edx, [ebp-0x7c]\n|  ||   0x0804843c     8b4584           mov eax, [ebp-0x7c]\n|  ||   0x0804843f     034508           add eax, [ebp+0x8]\n|  ||   0x08048442     0fb600           movzx eax, byte [eax]\n|  ||   0x08048445     2c03             sub al, 0x3\n|  ||   0x08048447     8802             mov [edx], al\n|  ||   0x08048449     8d4584           lea eax, [ebp-0x7c]\n|  ||   0x0804844c     ff00             inc dword [eax]\n|  `==< 0x0804844e     ebd4             jmp loc.08048424\n|   |   ; CODE (JMP) XREF 0x08048432 (sym.shift)\n/ loc: loc.08048450 (30)\n|   |   0x08048450  loc.08048450:\n|   `-> 0x08048450     8d4588           lea eax, [ebp-0x78]\n|       0x08048453     034584           add eax, [ebp-0x7c]\n|       0x08048456     c60000           mov byte [eax], 0x0\n|       0x08048459     8d4588           lea eax, [ebp-0x78]\n|       0x0804845c     89442404         mov [esp+0x4], eax\n|       0x08048460     c70424e8850408   mov dword [esp], 0x80485e8\n|       0x08048467     e8e4feffff       call dword imp.printf\n|          ; imp.printf()\n|       0x0804846c     c9               leave\n\\       0x0804846d     c3               ret\n        ; ------------\nyou can read the assembly code and find the decryption is actually a “sub al, 0x3”. we can write a python script for it:\nprint(''.join([chr(ord(i)-0x3) for i in 'SdvvzrugRN$$$']))\nprint(''.join([chr(ord(i)-0x3) for i in 'LqydolgSdvvzrug$']))\nthe easier way is to run the decryption code, that means debug it or emulate it. I used rizin ESIL emulator but it got stuck when executed call dword imp.strlen. And I can’t find the usage of hooking function / skip instruction in rizin. The following is an example to show u how to emulate ESIL.\n[0x08048414]> s 0x08048445      # the 'sub al, 0x03'\n[0x08048445]> aei               # init VM\n[0x08048445]> aeim              # init memory\n[0x08048445]> aeip              # init ip\n[0x08048445]> aer eax=0x41      # set eax=0x41 -- 'A'\n[0x08048445]> aer               # show current value of regs\noeax = 0x00000000\neax = 0x00000041\nebx = 0x00000000\necx = 0x00000000\nedx = 0x00000000\nesi = 0x00000000\nedi = 0x00000000\nesp = 0x00178000\nebp = 0x00178000\neip = 0x08048445\neflags = 0x00000000\n[0x08048445]> V                 # enter Visual mode\n# 'p' or 'P' to change visual mode\n# I prefer the [xaDvc] mode\n# use 's' to step in and 'S' to step over\n[0x08048442 [xaDvc]0 0% 265 ./crackme0x03]> diq;?0;f t.. @ sym.shift+46 # 0x8048442\ndead at 0x00000000\n- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF\n0x00178000  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x00178010  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x00178020  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x00178030  0000 0000 0000 0000 0000 0000 0000 0000  ................\n   oeax 0x00000000      eax 0x00000041      ebx 0x00000000      ecx 0x00000000\n    edx 0x00000000      esi 0x00000000      edi 0x00000000      esp 0x00178000\n    ebp 0x00178000      eip 0x08048445   eflags 0x00000000\n       :   0x08048442      0fb600         movzx eax, byte [eax]\n       :   ;-- eip:\n       :   0x08048445      2c03           sub al, 3\n       :   0x08048447      8802           mov byte [edx], al\n       :   0x08048449      8d4584         lea eax, [var_7ch]\n       :   0x0804844c      ff00           inc dword [eax]\n       :=< 0x0804844e      ebd4           jmp 0x8048424\n           ; CODE XREF from sym.shift @ 0x8048432\n           0x08048450      8d4588         lea eax, [var_78h]\nBy the way, you can also open the file and use write data command to decrypt data.\nrizin -w ./crackme0x03\n[0x08048360]> aaa\n[0x08048360]> fs strings\n[0x08048360]> f\n0x080485ec 18 str.Lqydolg_Sdvvzrug\n0x080485fe 18 str.Sdvvzrug_RN\n0x08048610 25 str.IOLI_Crackme_Level_0x03\n0x08048629 11 str.Password:\n[0x08048360]> s str.Lqydolg_Sdvvzrug\n[0x080485ec]> wos 0x03 @ str.Lqydolg_Sdvvzrug!0x11\n[0x080485ec]> px\n- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF\n0x080485ec  496e 7661 6c69 6420 5061 7373 776f 7264  Invalid Password\n0x080485fc  2100 5364 7676 7a72 7567 2352 4e24 2424  !.Sdvvzrug#RN$$$\n0x0804860c  233d 2c00 494f 4c49 2043 7261 636b 6d65  #=,.IOLI Crackme\n0x0804861c  204c 6576 656c 2030 7830 330a 0050 6173   Level 0x03..Pas\n0x0804862c  7377 6f72 643a 2000 2564 0000 0000 0000  sword: .%d......\n[0x080485ec]> wos 0x03 @ str.Sdvvzrug_RN!17\n[0x080485ec]> px\n- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF\n0x080485ec  496e 7661 6c69 6420 5061 7373 776f 7264  Invalid Password\n0x080485fc  2100 5061 7373 776f 7264 204f 4b21 2121  !.Password OK!!!\n0x0804860c  203a 2900 494f 4c49 2043 7261 636b 6d65   :).IOLI Crackme\n0x0804861c  204c 6576 656c 2030 7830 330a 0050 6173   Level 0x03..Pas\n0x0804862c  7377 6f72 643a 2000 2564 0000 0000 0000  sword: .%d......\n[0x080485ec]>\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x04.html",
    "title": "90  IOLI 0x04",
    "section": "",
    "text": "91 0x04\n[0x080483d0]> pdd@main\n/* jsdec pseudo code output */\n/* ./crackme0x04 @ 0x8048509 */\n#include <stdint.h>\n\nint32_t main (void) {\n    int32_t var_78h;\n    int32_t var_4h;\n    eax = 0;\n    eax += 0xf;\n    eax += 0xf;\n    eax >>= 4;\n    eax <<= 4;\n    printf (\"IOLI Crackme Level 0x04\\n\");\n    printf (\"Password: \");\n    eax = &var_78h;\n    scanf (0x8048682, eax);\n    eax = &var_78h;\n    check (eax);\n    eax = 0;\n    return eax;\n}\nLet’s enter check.\n#include <stdint.h>\n\nint32_t check (char * s) {\n    char * var_dh;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    char * format;\n    int32_t var_sp_8h;\n    var_8h = 0;\n    var_ch = 0;\n    do {\n        eax = s;\n        eax = strlen (eax);\n        if (var_ch >= eax) {\n            goto label_0;\n        }\n        eax = var_ch;\n        eax += s;\n        eax = *(eax);\n        var_dh = al;\n        eax = &var_4h;\n        eax = &var_dh;\n        sscanf (eax, eax, 0x8048638);\n        edx = var_4h;\n        eax = &var_8h;\n        *(eax) += edx;\n        if (var_8h == 0xf) {\n            printf (\"Password OK!\\n\");\n            exit (0);\n        }\n        eax = &var_ch;\n        *(eax)++;\n    } while (1);\nlabel_0:\n    printf (\"Password Incorrect!\\n\");\n    return eax;\n}\nmanually analyze with both the assembly and pseudo code we can simply write down the C-like code to describe this function:\n#include <stdint.h>\nint32_t check(char *s)\n{\n    var_ch = 0;\n    var_8h = 0;\n    for (var_ch = 0; var_ch < strlen(s); ++var_ch)\n    {\n        var_dh = s[var_ch];\n        sscanf(&var_dh, %d, &var_4h);           // read from string[var_ch], store to var_4h\n        var_8h += var_4h;\n        if(var_8h == 0xf)\n            printf(\"Password OK\\n\");\n    }\n    printf(\"Password Incorrect!\\n\");\n    return 0;\n}\nIn short, it calculates the Digit Sum of a number (add a number digit by digit. for example, 96 => 9 + 6 = 15) :\n./crackme0x04\nIOLI Crackme Level 0x04\nPassword: 12345\nPassword OK!\n\n./crackme0x04\nIOLI Crackme Level 0x04\nPassword: 96\nPassword OK!\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x05.html",
    "title": "91  IOLI 0x05",
    "section": "",
    "text": "check again, it uses scanf() to get our input and pass it to check() as parameter.\n[0x080483d0]> pdd@main\n/* jsdec pseudo code output */\n/* ./crackme0x05 @ 0x8048540 */\n#include <stdint.h>\n\nint32_t main (void) {\n    int32_t var_78h;\n    int32_t var_4h;\n    eax = 0;\n    eax += 0xf;\n    eax += 0xf;\n    eax >>= 4;\n    eax <<= 4;\n    printf (\"IOLI Crackme Level 0x05\\n\");\n    printf (\"Password: \");\n    eax = &var_78h;\n    scanf (0x80486b2, eax);         // 0x80486b2 is %s\n    eax = &var_78h;\n    check (eax);\n    eax = 0;\n    return eax;\n}\nthe check() function:\n/* jsdec pseudo code output */\n/* ./crackme0x05 @ 0x80484c8 */\n#include <stdint.h>\n\nint32_t check (char * s) {\n    char * var_dh;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    char * format;\n    int32_t var_sp_8h;\n    var_8h = 0;\n    var_ch = 0;\n    do {\n        eax = s;\n        eax = strlen (eax);\n        if (var_ch >= eax) {\n            goto label_0;\n        }\n        eax = var_ch;\n        eax += s;\n        eax = *(eax);\n        var_dh = al;\n        eax = &var_4h;\n        eax = &var_dh;\n        sscanf (eax, eax, 0x8048668);           // 0x8048668 is %d\n        edx = var_4h;\n        eax = &var_8h;\n        *(eax) += edx;\n        if (var_8h == 0x10) {\n            eax = s;\n            parell (eax);\n        }\n        eax = &var_ch;\n        *(eax)++;\n    } while (1);\nlabel_0:\n    printf (\"Password Incorrect!\\n\");\n    return eax;\n}\nThe same, we can write our own C-like pseudo code.\n#include <stdint.h>\nint32_t check(char *s)\n{\n    var_ch = 0;\n    var_8h = 0;\n    for (var_ch = 0; var_ch < strlen(s); ++var_ch)\n    {\n        var_dh = s[var_ch];\n        sscanf(&var_dh, %d, &var_4h);           // read from string[var_ch], store to var_4h\n        var_8h += var_4h;\n        if(var_8h == 0x10)\n            parell(s);\n    }\n    printf(\"Password Incorrect!\\n\");\n    return 0;\n}\nThe if condition becomes var_8h == 0x10. In addition, a new function call - parell(s) replace the printf(\"password OK\")now. The next step is to reverse sym.parell.\n[0x08048484]> s sym.parell\n[0x08048484]> pdd@sym.parell\n/* jsdec pseudo code output */\n/* ./crackme0x05 @ 0x8048484 */\n#include <stdint.h>\n\nuint32_t parell (char * s) {\n    int32_t var_4h;\n    char * format;\n    int32_t var_8h;\n    eax = &var_4h;\n    eax = s;\n    sscanf (eax, eax, 0x8048668);\n    eax = var_4h;\n    eax &= 1;\n    if (eax == 0) {\n        printf (\"Password OK!\\n\");\n        exit (0);\n    }\n    return eax;\n}\nthe decompiled code looks well except the sscanf() function. It can be easily corrected by checking the assembly code.\n/ 68: sym.parell (int32_t arg_8h);\n|           ; var int32_t var_4h @ ebp-0x4\n|           ; arg int32_t arg_8h @ ebp+0x8\n|           ; var int32_t var_sp_4h @ esp+0x4\n|           ; var int32_t var_8h @ esp+0x8\n|           0x08048484      55             push ebp\n|           0x08048485      89e5           mov ebp, esp\n|           0x08048487      83ec18         sub esp, 0x18\n|           0x0804848a      8d45fc         lea eax, [var_4h]\n|           0x0804848d      89442408       mov dword [var_8h], eax\n|           0x08048491      c74424046886.  mov dword [var_sp_4h], 0x8048668 ; [0x8048668:4]=0x50006425 %d\n|           0x08048499      8b4508         mov eax, dword [arg_8h]\n|           0x0804849c      890424         mov dword [esp], eax\n|           0x0804849f      e800ffffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)\n....\nThe mov dword [esp], eax is the nearest instruction to sscanf (and it’s equivalent to a push instruction). It stores the string ‘s’ to the stack top (arg1). mov dword [var_sp_4h], 0x8048668 push ‘%d’ as arg2 into stack. var_8h (esp + 0x8) which keeps the address of var_4h is the arg3.\nFinally we have the corrected pseudo code:\nuint32_t parell (char * s) {\n    sscanf (s, %d, &var_4h);\n    if ((var_4h & 1) == 0) {\n        printf (\"Password OK!\\n\");\n        exit(0);\n    }\n    return 0;\n}\nNow there are 2 constraints:\n\nDigit Sum is 16 (0x10)\nMust be an odd number (1 & number == 0)\n\nThe password is at our fingertips now.\n./crackme0x05\nIOLI Crackme Level 0x05\nPassword: 88\nPassword OK!\n\n./crackme0x05\nIOLI Crackme Level 0x05\nPassword: 12346\nPassword OK!\nwe can also use angr to solve it since we have two constraints to the password.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x06.html",
    "title": "92  IOLI 0x06",
    "section": "",
    "text": "nearly a routine to check this binary (not complete output in the following):\nrz-bin -z ./crackme0x06\n[Strings]\nnth paddr      vaddr      len size section type  string\n―――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0   0x00000738 0x08048738 4   5    .rodata ascii LOLO\n1   0x00000740 0x08048740 13  14   .rodata ascii Password OK!\\n\n2   0x0000074e 0x0804874e 20  21   .rodata ascii Password Incorrect!\\n\n3   0x00000763 0x08048763 24  25   .rodata ascii IOLI Crackme Level 0x06\\n\n4   0x0000077c 0x0804877c 10  11   .rodata ascii Password:\n\nrz-bin -I ./crackme0x06\narch     x86\nbaddr    0x8048000\nbintype  elf\nbits     32\ncompiler GCC: (GNU) 3.4.6 (Gentoo 3.4.6-r2, ssp-3.4.6-1.0, pie-8.7.10)\ncrypto   false\nendian   little\nhavecode true\nlang     c\nmachine  Intel 80386\nmaxopsz  16\nminopsz  1\nos       linux\nstatic   false\nva       true\nand analyze it then decompile main\n[0x08048400]> pdd@main\n/* jsdec pseudo code output */\n/* ./crackme0x06 @ 0x8048607 */\n#include <stdint.h>\n\nint32_t main (int32_t arg_10h) {\n    int32_t var_78h;\n    int32_t var_4h;\n    // adjusting stack\n    eax = 0;\n    eax += 0xf;\n    eax += 0xf;\n    eax >>= 4;\n    eax <<= 4;\n\n    // main logic\n    printf (\"IOLI Crackme Level 0x06\\n\");\n    printf (\"Password: \");\n    eax = &var_78h;\n    scanf (0x8048787, eax);\n    eax = arg_10h;\n    eax = &var_78h;\n    check (eax, arg_10h);\n    eax = 0;\n    return eax;\n}\nmain has 3 arguments argc, argv, envp, and this program is compiled with GCC, so the stack should be like this :\n[esp + 0x10] - envp\n[esp + 0x0c] - argv\n[esp + 0x08] - argc\n[esp + 0x04] - return address\nenter the check() and decompile it. this function is different from 0x05 now. but they still have similar code structure.\nint32_t check (char * s, int32_t arg_ch) {\n    char * var_dh;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    char * format;\n    int32_t var_sp_8h;\n    var_8h = 0;\n    var_ch = 0;\n    do {\n        eax = s;\n        eax = strlen (eax);\n        if (var_ch >= eax) {\n            goto label_0;\n        }\n        eax = var_ch;\n        eax += s;\n        eax = *(eax);\n        var_dh = al;\n        eax = &var_4h;\n        eax = &var_dh;\n        sscanf (eax, eax, 0x804873d);\n        edx = var_4h;\n        eax = &var_8h;\n        *(eax) += edx;\n        if (var_8h == 0x10) {\n            eax = arg_ch;\n            eax = s;\n            parell (eax, arg_ch);\n        }\n        eax = &var_ch;\n        *(eax)++;\n    } while (1);\nlabel_0:\n    printf (\"Password Incorrect!\\n\");\n    return eax;\n}\nCorrect the sscanf part and parell part, both of them were generated incorrectly:\nint32_t check (char * s, void* envp)\n{\n    var_ch = 0;\n    var_8h = 0;\n    for (var_ch = 0; var_ch < strlen(s); ++var_ch)\n    {\n        var_dh = s[var_ch];\n        sscanf(&var_dh, %d, &var_4h);           // read from string[var_ch], store to var_4h\n        var_8h += var_4h;\n        if(var_8h == 0x10)\n            parell(s, envp);\n    }\n    printf(\"Password Incorrect!\\n\");\n    return 0;\n}\nno more info, we have to reverse parell() again.\n#include <stdint.h>\n\nuint32_t parell (char * s, char * arg_ch) {\n    sscanf (s, %d, &var_4h);\n\n    if (dummy (var_4h, arg_ch) == 0)\n        return 0;\n\n    for (var_bp_8h = 0; var_bp_8h <= 9; ++var_bp_8h){\n        if (var_4h & 1 == 0){\n            printf(\"Password OK!\\n\");\n            exit(0);\n        }\n    }\n\n    return 0;\n}\nwell, there is a new check condition in parell() – dummy (var_4h, arg_ch) == 0. then reverse dummy!\n[0x080484b4]> pdd@sym.dummy\n/* jsdec pseudo code output */\n/* ./crackme0x06 @ 0x80484b4 */\n#include <stdint.h>\n\nint32_t dummy (char ** s1) {\n    int32_t var_8h;\n    int32_t var_4h;\n    char * s2;\n    size_t * n;\n    var_4h = 0;\n    do {\n        eax = 0;\n        edx = eax*4;\n        eax = s1;\n        if (*((edx + eax)) == 0) {\n            goto label_0;\n        }\n        eax = var_4h;\n        ecx = eax*4;\n        edx = s1;\n        eax = &var_4h;\n        *(eax)++;\n        eax = *((ecx + edx));\n        eax = strncmp (eax, 3, \"LOLO\");\n    } while (eax != 0);\n    var_8h = 1;\n    goto label_1;\nlabel_0:\n    var_8h = 0;\nlabel_1:\n    eax = 0;\n    return eax;\n}\nlooks like a loop to process string. we can beautify it.\n[0x080484b4]> pdd@sym.dummy\n/* jsdec pseudo code output */\n/* ./crackme0x06 @ 0x80484b4 */\n#include <stdint.h>\n\nint32_t dummy (char ** s1) {\n    for (var_4h = 0; strncmp(s1[var_4h], \"LOLO\", 3) != 0; var_4h++){\n        if (s1[i] == NULL)\n            return 0;\n    }\n    return 1;\n}\nThere are 3 constraints to crackme_0x06:\n\nDigit Sum\nOdd Number\nshould have an environment variable whose name started with “LOL”.\n\n$ ./crackme0x06\nIOLI Crackme Level 0x06\nPassword: 12346\nPassword Incorrect!\n$ export LOLAA=help\n$ ./cracke0x06\nIOLI Crackme Level 0x06\nPassword: 12346\nPassword OK!\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x07.html",
    "title": "93  IOLI 0x07",
    "section": "",
    "text": "a weird “wtf?” string.\n$ rz-bin -z ./crackme0x07\n[Strings]\nnth paddr      vaddr      len size section type  string\n―――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0   0x000007a8 0x080487a8 4   5    .rodata ascii LOLO\n1   0x000007ad 0x080487ad 20  21   .rodata ascii Password Incorrect!\\n\n2   0x000007c5 0x080487c5 13  14   .rodata ascii Password OK!\\n\n3   0x000007d3 0x080487d3 5   6    .rodata ascii wtf?\\n\n4   0x000007d9 0x080487d9 24  25   .rodata ascii IOLI Crackme Level 0x07\\n\n5   0x000007f2 0x080487f2 10  11   .rodata ascii Password:\nagain, no password string or compare in main(). I put the simplified pseudo code here. var_78h is likely to a char *pointer (string) .\n#include <stdint.h>\nint32_t main (int32_t arg_10h) {\n    printf (\"IOLI Crackme Level 0x07\\n\");\n    printf (\"Password: \");\n    scanf (%s, &var_78h);\n    return fcn_080485b9 (&var_78h, arg_10h);\n}\ndue to the symbol info lost, neither aa nor aaa show the name of functions. we can double check this in “flagspace”. Rizin use fcn_080485b9 as the function name. It’s a common case in reverse engineering that we don’t have any symbol info of the binary.\n[0x080487fd]> fs symbols\n[0x080487fd]> f\n0x08048400 33 entry0\n0x0804867d 92 main\n0x080487a4 4 obj._IO_stdin_used\ndecompile the fcn_080485b9():\n[0x080485b9]> pdfc\n            ; CALL XREF from main @ 0x80486d4\n/ 118: fcn.080485b9 (char *s, int32_t arg_ch);\n|           ; var char *var_dh @ ebp-0xd\n|           ; var signed int var_ch  { >= 0xffffffffffffffff} @ ebp-0xc\n|           ; var uint32_t var_8h @ ebp-0x8\n|           ; var int32_t var_bp_4h @ ebp-0x4\n|           ; arg char *s @ ebp+0x8\n|           ; arg int32_t arg_ch @ ebp+0xc\n|           ; var char *format @ esp+0x4\n|           ; var int32_t var_sp_8h @ esp+0x8\n|           0x080485b9      55             push ebp\n|           0x080485ba      89e5           mov ebp, esp\n|           0x080485bc      83ec28         sub esp, 0x28\n|           0x080485bf      c745f8000000.  mov dword [var_8h], 0\n|           0x080485c6      c745f4000000.  mov dword [var_ch], 0\n|           ; CODE XREF from fcn.080485b9 @ 0x8048628\n|       .-> 0x080485cd      8b4508         mov eax, dword [s]\n|       :   0x080485d0      890424         mov dword [esp], eax        ; const char *s\n|       :   0x080485d3      e8d0fdffff     call sym.imp.strlen         ; size_t strlen(const char *s)\n|       :   0x080485d8      3945f4         cmp dword [var_ch], eax\n|      ,==< 0x080485db      734d           jae 0x804862a\n|      |:   0x080485dd      8b45f4         mov eax, dword [var_ch]\n|      |:   0x080485e0      034508         add eax, dword [s]\n|      |:   0x080485e3      0fb600         movzx eax, byte [eax]\n|      |:   0x080485e6      8845f3         mov byte [var_dh], al\n|      |:   0x080485e9      8d45fc         lea eax, [var_bp_4h]\n|      |:   0x080485ec      89442408       mov dword [var_sp_8h], eax  ;   ...\n|      |:   0x080485f0      c7442404c287.  mov dword [format], 0x80487c2 ; [0x80487c2:4]=0x50006425 ; const char *format\n|      |:   ;-- eip:\n|      |:   0x080485f8      8d45f3         lea eax, [var_dh]\n|      |:   0x080485fb      890424         mov dword [esp], eax        ; const char *s\n|      |:   0x080485fe      e8c5fdffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)\n|      |:   0x08048603      8b55fc         mov edx, dword [var_bp_4h]\n|      |:   0x08048606      8d45f8         lea eax, [var_8h]\n|      |:   0x08048609      0110           add dword [eax], edx\n|      |:   0x0804860b      837df810       cmp dword [var_8h], 0x10\n|     ,===< 0x0804860f      7512           jne 0x8048623\n|     ||:   0x08048611      8b450c         mov eax, dword [arg_ch]\n|     ||:   0x08048614      89442404       mov dword [format], eax     ; char *arg_ch\n|     ||:   0x08048618      8b4508         mov eax, dword [s]\n|     ||:   0x0804861b      890424         mov dword [esp], eax        ; char *s\n|     ||:   0x0804861e      e81fffffff     call fcn.08048542\n|     ||:   ; CODE XREF from fcn.080485b9 @ 0x804860f\n|     `---> 0x08048623      8d45f4         lea eax, [var_ch]\n|      |:   0x08048626      ff00           inc dword [eax]\n|      |`=< 0x08048628      eba3           jmp 0x80485cd\n|      |    ; CODE XREF from fcn.080485b9 @ 0x80485db\n\\      `--> 0x0804862a      e8f5feffff     call fcn.08048524\nwe got familiar with this code structure in the previous challenges (the check function). It’s not difficult for us even we don’t have the symbol info. you can also use afn command to rename the function name if you like.\nint32_t fcn_080485b9 (char * s, void* envp)\n{\n    var_ch = 0;\n    var_8h = 0;\n    for (var_ch = 0; var_ch < strlen(s); ++var_ch)\n    {\n        var_dh = s[var_ch];\n        sscanf(&var_dh, %d, &var_4h);           // read from string[var_ch], store to var_4h\n        var_8h += var_4h;\n        if(var_8h == 0x10)\n            fcn_08048542(s, envp);\n    }\n    return fcn_08048524();\n}\nmost part of crackme 0x07 is the same with 0x06. and it can be solved by the same password & environment:\n$ export LOLAA=help\n$ ./cracke0x07\nIOLI Crackme Level 0x07\nPassword: 12346\nPassword OK!\nwait … where is the ‘wtf?’. Often, we would like to find the cross reference (xref) to strings (or data, functions, etc.) in reverse engineering. The related commands in Rizin are under “ax” namespace:\n[0x08048400]> f\n0x080487a8 5 str.LOLO\n0x080487ad 21 str.Password_Incorrect\n0x080487c5 14 str.Password_OK\n0x080487d3 6 str.wtf\n0x080487d9 25 str.IOLI_Crackme_Level_0x07\n0x080487f2 11 str.Password:\n[0x08048400]> axt 0x80487d3\n(nofunc) 0x804865c [DATA] mov dword [esp], str.wtf\n[0x08048400]> axF str.wtf\nFinding references of flags matching 'str.wtf'...\n[0x001eff28-0x001f0000] (nofunc) 0x804865c [DATA] mov dword [esp], str.wtf\nMacro 'findstref' removed.\nthe [DATA] mov dword [esp], str.wtf at 0x804865c is an instruction of fcn.080485b9. But the analysis in my PC ignores the remained instructions and only display the incomplete assembly. the range of fcn.080485b9 should be 0x080485b9 ~ 0x0804867c . we can reset block size and print opcodes.\n[0x08040000]> s 0x080485b9\n[0x080485b9]> b 230\n[0x08048400]> pd\n...\n            0x0804862f      8b450c         mov eax, dword [ebp + 0xc]\n            0x08048632      89442404       mov dword [esp + 4], eax\n            0x08048636      8b45fc         mov eax, dword [ebp - 4]\n            0x08048639      890424         mov dword [esp], eax        ; char **s1\n            0x0804863c      e873feffff     call fcn.080484b4\n            0x08048641      85c0           test eax, eax\n        ,=< 0x08048643      7436           je 0x804867b\n        |   0x08048645      c745f4000000.  mov dword [ebp - 0xc], 0\n        |   ; CODE XREF from fcn.080485b9 @ +0xc0\n       .--> 0x0804864c      837df409       cmp dword [ebp - 0xc], 9\n      ,===< 0x08048650      7f29           jg 0x804867b\n      |:|   0x08048652      8b45fc         mov eax, dword [ebp - 4]\n      |:|   0x08048655      83e001         and eax, 1\n      |:|   0x08048658      85c0           test eax, eax\n     ,====< 0x0804865a      7518           jne 0x8048674\n     ||:|   0x0804865c      c70424d38704.  mov dword [esp], str.wtf    ; [0x80487d3:4]=0x3f667477 ; \"wtf?\\n\" ; const char *format\n     ||:|   0x08048663      e850fdffff     call sym.imp.printf         ; int printf(const char *format)\n     ||:|   0x08048668      c70424000000.  mov dword [esp], 0          ; int status\n     ||:|   0x0804866f      e874fdffff     call sym.imp.exit           ; void exit(int status)\n     ||:|   ; CODE XREF from fcn.080485b9 @ +0xa1\n     `----> 0x08048674      8d45f4         lea eax, [ebp - 0xc]\n      |:|   0x08048677      ff00           inc dword [eax]\n      |`==< 0x08048679      ebd1           jmp 0x804864c\n      | |   ; CODE XREFS from fcn.080485b9 @ +0x8a, +0x97\n      `-`-> 0x0804867b      c9             leave\n            0x0804867c      c3             ret\n\ntest eax, ea;je 0x804867b will jump to leave; ret, which forever skips the str.wtf part. only use aa to analyze this binary can display the whole function.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x08.html",
    "title": "94  IOLI 0x08",
    "section": "",
    "text": "we can reverse it and find it’s similar to 0x07, and use the same password to solve it:\n$ export LOLAA=help\n$ ./cracke0x08\nIOLI Crackme Level 0x08\nPassword: 12346\nPassword OK!\ndustri provided a better way to check crackme0x08. 0x07 is the stripped version of 0x08.\n$ rz-diff -A -C ./crackme0x07 ./crackme0x08\n...\n              fcn.08048360  23 0x8048360 |   MATCH  (1.000000) | 0x8048360   23 sym._init\n sym.imp.__libc_start_main   6 0x8048388 |   MATCH  (1.000000) | 0x8048388    6 sym.imp.__libc_start_main\n             sym.imp.scanf   6 0x8048398 |   MATCH  (1.000000) | 0x8048398    6 sym.imp.scanf\n            sym.imp.strlen   6 0x80483a8 |   MATCH  (1.000000) | 0x80483a8    6 sym.imp.strlen\n            sym.imp.printf   6 0x80483b8 |   MATCH  (1.000000) | 0x80483b8    6 sym.imp.printf\n            sym.imp.sscanf   6 0x80483c8 |   MATCH  (1.000000) | 0x80483c8    6 sym.imp.sscanf\n           sym.imp.strncmp   6 0x80483d8 |   MATCH  (1.000000) | 0x80483d8    6 sym.imp.strncmp\n              sym.imp.exit   6 0x80483e8 |   MATCH  (1.000000) | 0x80483e8    6 sym.imp.exit\n                    entry0  33 0x8048400 |   MATCH  (1.000000) | 0x8048400   33 entry0\n              fcn.08048424  33 0x8048424 |   MATCH  (1.000000) | 0x8048424   33 fcn.08048424\n              fcn.08048450  47 0x8048450 |   MATCH  (1.000000) | 0x8048450   47 sym.__do_global_dtors_aux\n              fcn.08048480  50 0x8048480 |   MATCH  (1.000000) | 0x8048480   50 sym.frame_dummy\n              fcn.080484b4 112 0x80484b4 |   MATCH  (1.000000) | 0x80484b4  112 sym.dummy\n              fcn.08048524  30 0x8048524 |   MATCH  (1.000000) | 0x8048524   30 sym.che\n              fcn.08048542 119 0x8048542 |   MATCH  (1.000000) | 0x8048542  119 sym.parell\n              fcn.080485b9 118 0x80485b9 |   MATCH  (1.000000) | 0x80485b9  118 sym.check\n                      main  92 0x804867d |   MATCH  (1.000000) | 0x804867d   92 main\n              fcn.08048755   4 0x8048755 |   MATCH  (1.000000) | 0x8048755    4 sym.__i686.get_pc_thunk.bx\n              fcn.08048760  35 0x8048760 |   MATCH  (1.000000) | 0x8048760   35 sym.__do_global_ctors_aux\n              fcn.0804878d  17 0x804878d |     NEW  (0.000000)\n       sym.__libc_csu_init  99 0x80486e0 |     NEW  (0.000000)\n       sym.__libc_csu_fini   5 0x8048750 |     NEW  (0.000000)\n                 sym._fini  26 0x8048784 |     NEW  (0.000000)\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/ioli/ioli_0x09.html",
    "title": "95  IOLI 0x09",
    "section": "",
    "text": "Hints: crackme0x09 hides the format string (%d and %s), and nothing more than 0x08.\n$ export LOLA=help\n$ ./crackme0x09\nIOLI Crackme Level 0x09\nPassword: 12346\nPassword OK!\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/avatao/01-reverse4/intro.html",
    "title": "96  Avatao R3v3rs3 4",
    "section": "",
    "text": "After a few years of missing out on wargames at Hacktivity, this year I’ve finally found the time to begin, and almost finish (yeah, I’m quite embarrassed about that unfinished webhack :) ) one of them. There were 3 different games at the conf, and I’ve chosen the one that was provided by avatao. It consisted of 8 challenges, most of them being basic web hacking stuff, one sandbox escape, one simple buffer overflow exploitation, and there were two reverse engineering exercises too. You can find these challenges on https://platform.avatao.com.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/avatao/01-reverse4/rizin.html",
    "title": "97  .rizin",
    "section": "",
    "text": "I’ve decided to solve the reversing challenges using rizin, a free and open source reverse engineering framework. I have first learned about rizin back in 2011. during a huge project, where I had to reverse a massive, 11MB statically linked ELF. I simply needed something that I could easily patch Linux ELFs with. Granted, back then I’ve used rizin alongside IDA, and only for smaller tasks, but I loved the whole concept at first sight. Since then, rizin evolved a lot, and I was planning for some time now to solve some crackmes with the framework, and write writeups about them. Well, this CTF gave me the perfect opportunity :)\nBecause this writeup aims to show some of rizin’s features besides how the crackmes can be solved, I will explain every rizin command I use in blockquote paragraphs like this one:\n\nrizin tip: Always use ? or -h to get more information!\n\nIf you know rizin, and just interested in the crackme, feel free to skip those parts! Also keep in mind please, that because of this tutorial style I’m going to do a lot of stuff that you just don’t do during a CTF, because there is no time for proper bookkeeping (e.g. flag every memory area according to its purpose), and with such small executables you can succeed without doing these stuff.\nA few advice if you are interested in learning rizin (and frankly, if you are into RE, you should be interested in learning rizin :) ):\nThe framework has a lot of supplementary executables and a vast amount of functionality - and they are very well documented. I encourage you to read the available docs, and use the built-in help (by appending a ? to any command) extensively! E.g.:\n[0x00000000]> ?\nUsage: [.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ; ...\nAppend '?' to any char command to get detailed help\nPrefix with number to repeat command N times (f.ex: 3x)\n|%var =valueAlias for 'env' command\n| *off[=[0x]value]     Pointer read/write data/values (see ?v, wx, wv)\n| (macro arg0 arg1)    Manage scripting macros\n| .[-|(m)|f|!sh|cmd]   Define macro or load rizin, cparse or rlang file\n| = [cmd]              Run this command via rap://\n| /                    Search for bytes, regexps, patterns, ..\n| ! [cmd]              Run given command as in system(3)\n| # [algo] [len]       Calculate hash checksum of current block\n| #!lang [..]          Hashbang to run an rlang script\n| a                    Perform analysis of code\n| b                    Get or change block size\n\n...\n\n[0x00000000]> a?\n|Usage: a[abdefFghoprxstc] [...]\n| ab [hexpairs]     analyze bytes\n| aa                analyze all (fcns + bbs) (aa0 to avoid sub renaming)\n| ac [cycles]       analyze which op could be executed in [cycles]\n| ad                analyze data trampoline (wip)\n| ad [from] [to]    analyze data pointers to (from-to)\n| ae [expr]         analyze opcode eval expression (see ao)\n| af[rnbcsl?+-*]    analyze Functions\n| aF                same as above, but using analysis.depth=1\n\n...\nAlso, the project is under heavy development, there is no day without commits to the GitHub repo. So, as the readme says, you should always use the git version!\nSome highly recommended reading materials:\n\nRizin Book\nRizin Blog\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/avatao/01-reverse4/first_steps.html",
    "title": "98  .first_steps",
    "section": "",
    "text": "OK, enough of praising rizin, lets start reversing this stuff. First, you have to know your enemy:\n[0x00 avatao]$ rz-bin -I reverse4\npic      false\ncanary   true\nnx       true\ncrypto   false\nva       true\nintrp    /lib64/ld-linux-x86-64.so.2\nbintype  elf\nclass    ELF64\nlang     c\narch     x86\nbits     64\nmachine  AMD x86-64 architecture\nos       linux\nsubsys   linux\nendian   little\nstripped true\nstatic   false\nlinenum  false\nlsyms    false\nrelocs   false\nrpath    NONE\nbinsz    8620\n\nrizin tip: rz-bin is one of the handy tools that comes with rizin. It can be used to extract information (imports, symbols, libraries, etc.) about binary executables. As always, check the help (rz-bin -h)!\n\nSo, its a dynamically linked, stripped, 64bit Linux executable - nothing fancy here. Let’s try to run it:\n[0x00 avatao]$ ./reverse4\n?\nSize of data: 2623\npamparam\nWrong!\n\n[0x00 avatao]$ \"\\x01\\x00\\x00\\x00\" | ./reverse4\nSize of data: 1\nOK, so it reads a number as a size from the standard input first, than reads further, probably “size” bytes/characters, processes this input, and outputs either “Wrong!”, nothing or something else, presumably our flag. But do not waste any more time monkeyfuzzing the executable, let’s fire up rizin, because in asm we trust!\n[0x00 avatao]$ rizin -A reverse4\n -- Heisenbug: A bug that disappears or alters its behavior when one attempts to probe or isolate it.\n[0x00400720]>\n\nrizin tip: The -A switch runs aaa command at start to analyze all referenced code, so we will have functions, strings, XREFS, etc. right at the beginning. As usual, you can get help with ?.\n\nIt is a good practice to create a project, so we can save our progress, and we can come back at a later time:\n[0x00400720]> Ps avatao_reverse4\navatao_reverse4\n[0x00400720]>\n\nrizin tip: You can save a project using Ps [file], and load one using Po [file]. With the -p option, you can load a project when starting rizin.\n\nWe can list all the strings rizin found:\n[0x00400720]> fs strings\n[0x00400720]> f\n0x00400e98 7 str.Wrong_\n0x00400e9f 27 str.We_are_in_the_outer_space_\n0x00400f80 18 str.Size_of_data:__u_n\n0x00400f92 23 str.Such_VM__MuCH_reV3rse_\n0x00400fa9 16 str.Use_everything_\n0x00400fbb 9 str.flag.txt\n0x00400fc7 26 str.You_won__The_flag_is:__s_n\n0x00400fe1 21 str.Your_getting_closer_\n[0x00400720]>\n\nrizin tip: rizin puts so called flags on important/interesting offsets, and organizes these flags into flagspaces (strings, functions, symbols, etc.) You can list all flagspaces using fs, and switch the current one using fs [flagspace] (the default is *, which means all the flagspaces). The command f prints all flags from the currently selected flagspace(s).\n\nOK, the strings looks interesting, especially the one at 0x00400f92. It seems to hint that this crackme is based on a virtual machine. Keep that in mind!\nThese strings could be a good starting point if we were talking about a real-life application with many-many features. But we are talking about a crackme, and they tend to be small and simple, and focused around the problem to be solved. So I usually just take a look at the entry point(s) and see if I can figure out something from there. Nevertheless, I’ll show you how to find where these strings are used:\n[0x00400720]> axt @@=`f~[0]`\nd 0x400cb5 mov edi, str.Size_of_data:__u_n\nd 0x400d1d mov esi, str.Such_VM__MuCH_reV3rse_\nd 0x400d4d mov edi, str.Use_everything_\nd 0x400d85 mov edi, str.flag.txt\nd 0x400db4 mov edi, str.You_won__The_flag_is:__s_n\nd 0x400dd2 mov edi, str.Your_getting_closer_\n\nrizin tip: We can list cross-references to addresses using the axt [addr] command (similarly, we can use axf to list references from the address). The *@@* is an iterator, it just runs the command once for every arguments listed.\nThe argument list in this case comes from the command f[0]. It lists the strings from the executable with f, and uses the internal grep command  to select only the first column ([0]) that contains the strings’ addresses.\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/avatao/01-reverse4/main.html",
    "title": "99  .main",
    "section": "",
    "text": "As I was saying, I usually take a look at the entry point, so let’s just do that:\n[0x00400720]> s main\n[0x00400c63]>\n\nrizin tip: You can go to any offset, flag, expression, etc. in the executable using the s command (seek). You can use references, like $$ (current offset), you can undo (s-) or redo (s+) seeks, search strings (s/ [string]) or hex values (s/x 4142), and a lot of other useful stuff. Make sure to check out s?!\n\nNow that we are at the beginning of the main function, we could use p to show a disassembly (pd, pdf), but rizin can do something much cooler: it has a visual mode, and it can display graphs similar to IDA, but way cooler, since they are ASCII-art graphs :)\n\nrizin tip: The command family p is used to print stuff. For example it can show disassembly (pd), disassembly of the current function (pdf), print strings (ps), hexdump (px), base64 encode/decode data (p6e, p6d), or print raw bytes (pr) so you can for example dump parts of the binary to other files. There are many more functionalities, check ?!\n\nR2 also has a minimap view which is incredibly useful for getting an overall look at a function:\n\n\n\nmain functions’s minimap\n\n\n\nrizin tip: With command V you can enter the so-called visual mode, which has several views. You can switch between them using p and P. The graph view can be displayed by hitting V in visual mode (or using VV at the prompt).\nHitting p in graph view will bring up the minimap. It displays the basic blocks and the connections between them in the current function, and it also shows the disassembly of the currently selected block (marked with @@@@@ on the minimap). You can select the next or the previous block using the *<TAB>* and the *<SHIFT><TAB>* keys respectively. You can also select the true or the false branches using the t and the f keys.\nIt is possible to bring up the prompt in visual mode using the : key, and you can use o to seek.\n\nLets read main node-by-node! The first block looks like this:\n\n\n\nmain bb-0c63\n\n\nWe can see that the program reads a word (2 bytes) into the local variable named local_10_6, and than compares it to 0xbb8. That’s 3000 in decimal:\n[0x00400c63]> ? 0xbb8\n3000 0xbb8 05670 2.9K 0000:0bb8 3000 10111000 3000.0 0.000000f 0.000000\n\nrizin tip: yep, ? will evaluate expressions, and print the result in various formats.\n\nIf the value is greater than 3000, then it will be forced to be 3000:\n\n\n\nmain bb-0ca6\n\n\nThere are a few things happening in the next block:\n\n\n\nmain bb-0cac\n\n\nFirst, the “Size of data:” message we saw when we run the program is printed. So now we know that the local variable local_10_6 is the size of the input data - so lets name it accordingly (remember, you can open the rizin shell from visual mode using the : key!):\n:> afvn local_10_6 input_size\n\nrizin tip: The af command family is used to analyze functions. This includes manipulating arguments and local variables too, which is accessible via the afv commands. You can list function arguments (afa), local variables (afv), or you can even rename them (afan, afvn). Of course there are lots of other features too - as usual: use the “?”, Luke!\n\nAfter this an input_size bytes long memory chunk is allocated, and filled with data from the standard input. The address of this memory chunk is stored in local_10 - time to use afvn again:\n:> afvn local_10 input_data\nWe’ve almost finished with this block, there are only two things remained. First, an 512 (0x200) bytes memory chunk is zeroed out at offset 0x00602120. A quick glance at XREFS to this address reveals that this memory is indeed used somewhere in the application:\n:> axt 0x00602120\nd 0x400cfe mov edi, 0x602120\nd 0x400d22 mov edi, 0x602120\nd 0x400dde mov edi, 0x602120\nd 0x400a51 mov qword [rbp - 8], 0x602120\nSince it probably will be important later on, we should label it:\n:> f sym.memory 0x200 0x602120\n\nrizin tip: Flags can be managed using the f command family. We’ve just added the flag sym.memory to a 0x200 bytes long memory area at 0x602120. It is also possible to remove (f-name), rename (fr [old] [new]), add comment (fC [name] [cmt]) or even color (fc [name] [color]) flags.\n\nWhile we are here, we should also declare that memory chunk as data, so it will show up as a hexdump in disassembly view:\n:> Cd 0x200 @ sym.memory\n\nrizin tip: The command family C is used to manage metadata. You can set (CC) or edit (CC) comments, declare memory areas as data (Cd), strings (Cs), etc. These commands can also be issued via a menu in visual mode invoked by pressing d.\n\nThe only remaining thing in this block is a function call to 0x400a45 with the input data as an argument. The function’s return value is compared to “*“, and a conditional jump is executed depending on the result.\nEarlier I told you that this crackme is probably based on a virtual machine. Well, with that information in mind, one can guess that this function will be the VM’s main loop, and the input data is the instructions the VM will execute. Based on this hunch, I’ve named this function vmloop, and renamed input_data to bytecode and input_size to bytecode_length. This is not really necessary in a small project like this, but it’s a good practice to name stuff according to their purpose (just like when you are writing programs).\n:> af vmloop 0x400a45\n:> afvn input_size bytecode_length\n:> afvn input_data bytecode\n\nrizin tip: The af command is used to analyze a function with a given name at the given address. The other two commands should be familiar from earlier.\n\nAfter renaming local variables, flagging that memory area, and renaming the VM loop function the disassembly looks like this:\n\n\n\nmain bb-0cac_meta\n\n\nSo, back to that conditional jump. If vmloop returns anything else than “*“, the program just exits without giving us our flag. Obviously we don’t want that, so we follow the false branch.\n\n\n\nmain bb-0d1d\n\n\nNow we see that a string in that 512 bytes memory area (sym.memory) gets compared to “Such VM! MuCH reV3rse!”. If they are not equal, the program prints the bytecode, and exits:\n\n\n\nmain bb-0dde\n\n\nOK, so now we know that we have to supply a bytecode that will generate that string when executed. As we can see on the minimap, there are still a few more branches ahead, which probably means more conditions to meet. Lets investigate them before we delve into vmloop!\nIf you take a look at the minimap of the whole function, you can probably recognize that there is some kind of loop starting at block [0d34], and it involves the following nodes:\n\n[0d34]\n[0d65]\n[0d3d]\n[0d61]\n\nHere are the assembly listings for those blocks. The first one puts 0 into local variable local_10_4:\n\n\n\nmain bb-0d34\n\n\nAnd this one compares local_10_4 to 8, and executing a conditional jump based on the result:\n\n\n\nmain bb-0d65\n\n\nIt’s pretty obvious that local_10_4 is the loop counter, so lets name it accordingly:\n:> afvn local_10_4 i\nNext block is the actual loop body:\n\n\n\nmain bb-0d3d\n\n\nThe memory area at 0x6020e0 is treated as an array of dwords (4 byte values), and checked if the ith value of it is zero. If it is not, the loop simply continues:\n\n\n\nmain bb-0d61\n\n\nIf the value is zero, the loop breaks and this block is executed before exiting:\n\n\n\nmain bb-0d4d\n\n\nIt prints the following message: Use everything!” As we’ve established earlier, we are dealing with a virtual machine. In that context, this message probably means that we have to use every available instructions. Whether we executed an instruction or not is stored at 0x6020e0 - so lets flag that memory area:\n:> f sym.instr_dirty 4*9 0x6020e0\nAssuming we don’t break out and the loop completes, we are moving on to some more checks:\n\n\n\nmain bb-0d6b\n\n\nThis piece of code may look a bit strange if you are not familiar with x86_64 specific stuff. In particular, we are talking about RIP-relative addressing, where offsets are described as displacements from the current instruction pointer, which makes implementing PIE easier. Anyways, rizin is nice enough to display the actual address (0x602104). Got the address, flag it!\n:> f sym.good_if_ne_zero 4 0x602104\nKeep in mind though, that if RIP-relative addressing is used, flags won’t appear directly in the disassembly, but rizin displays them as comments:\n\n\n\nmain bb-0d6b_meta\n\n\nIf sym.good_if_ne_zero is zero, we get a message (“Your getting closer!”), and then the program exits. If it is non-zero, we move to the last check:\n\n\n\nmain bb-0d75\n\n\nHere the program compares a dword at 0x6020f0 (again, RIP-relative addressing) to 9. If its greater than 9, we get the same “Your getting closer!” message, but if it’s lesser, or equal to 9, we finally reach our destination, and get the flag:\n\n\n\nmain bb-0d80\n\n\nAs usual, we should flag 0x6020f0:\n:> f sym.good_if_le_9 4 0x6020f0\nWell, it seems that we have fully reversed the main function. To summarize it: the program reads a bytecode from the standard input, and feeds it to a virtual machine. After VM execution, the program’s state have to satisfy these conditions in order to reach the goodboy code:\n\nvmloop’s return value has to be “*”\nsym.memory has to contain the string “Such VM! MuCH reV3rse!”\nall 9 elements of sym.instr_dirty array should not be zero (probably means that all instructions had to be used at least once)\nsym.good_if_ne_zero should not be zero\nsym.good_if_le_9 has to be lesser or equal to 9\n\nThis concludes our analysis of the main function, we can now move on to the VM itself.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/avatao/01-reverse4/vmloop.html",
    "title": "100  .vmloop",
    "section": "",
    "text": "[offset]> fcn.vmloop\n\n\n\nvmloop bb-0a45\n\n\nWell, that seems disappointingly short, but no worries, we have plenty to reverse yet. The thing is that this function uses a jump table at 0x00400a74,\n\n\n\nvmloop bb-0a74\n\n\nand rizin can’t yet recognize jump tables (Issue 3201), so the analysis of this function is a bit incomplete. This means that we can’t really use the graph view now, so either we just use visual mode, or fix those basic blocks. The entire function is just 542 bytes long, so we certainly could reverse it without the aid of the graph mode, but since this writeup aims to include as much rizin wisdom as possible, I’m going to show you how to define basic blocks.\nFirst, lets analyze what we already have! First, rdi is put into local_3. Since the application is a 64bit Linux executable, we know that rdi is the first function argument (as you may have recognized, the automatic analysis of arguments and local variables was not entirely correct), and we also know that vmloop’s first argument is the bytecode. So lets rename local_3:\n:> afvn local_3 bytecode\nNext, sym.memory is put into another local variable at rbp-8 that rizin did not recognize. So let’s define it!\n:> afv 8 memory qword\n\nrizin tip: The afv [idx] [name] [type] command is used to define local variable at [frame pointer - idx] with the name [name] and type [type]. You can also remove local variables using the afv- [idx] command.\n\nIn the next block, the program checks one byte of bytecode, and if it is 0, the function returns with 1.\n\n\n\nvmloop bb-0c4d\n\n\nIf that byte is not zero, the program subtracts 0x41 from it, and compares the result to 0x17. If it is above 0x17, we get the dreaded “Wrong!” message, and the function returns with 0. This basically means that valid bytecodes are ASCII characters in the range of “A” (0x41) through “X” (0x41 + 0x17). If the bytecode is valid, we arrive at the code piece that uses the jump table:\n\n\n\nvmloop bb-0a74\n\n\nThe jump table’s base is at 0x400ec0, so lets define that memory area as a series of qwords:\n[0x00400a74]> s 0x00400ec0\n[0x00400ec0]> Cd 8 @@=`?s $$ $$+8*0x17 8`\n\nrizin tip: Except for the ?s, all parts of this command should be familiar now, but lets recap it! Cd defines a memory area as data, and 8 is the size of that memory area. @@* is an iterator that make the preceding command run for every element that @@* holds. In this example it holds a series generated using the ?s command. ?s simply generates a series from the current seek (\\[*) to current seek + 8*0x17 (*\\]+80x17*) with a step of 8.\n\nThis is how the disassembly looks like after we add this metadata:\n[0x00400ec0]> pd 0x18\n            ; DATA XREF from 0x00400a76 (unk)\n            0x00400ec0 .qword 0x0000000000400a80\n            0x00400ec8 .qword 0x0000000000400c04\n            0x00400ed0 .qword 0x0000000000400b6d\n            0x00400ed8 .qword 0x0000000000400b17\n            0x00400ee0 .qword 0x0000000000400c04\n            0x00400ee8 .qword 0x0000000000400c04\n            0x00400ef0 .qword 0x0000000000400c04\n            0x00400ef8 .qword 0x0000000000400c04\n            0x00400f00 .qword 0x0000000000400aec\n            0x00400f08 .qword 0x0000000000400bc1\n            0x00400f10 .qword 0x0000000000400c04\n            0x00400f18 .qword 0x0000000000400c04\n            0x00400f20 .qword 0x0000000000400c04\n            0x00400f28 .qword 0x0000000000400c04\n            0x00400f30 .qword 0x0000000000400c04\n            0x00400f38 .qword 0x0000000000400b42\n            0x00400f40 .qword 0x0000000000400c04\n            0x00400f48 .qword 0x0000000000400be5\n            0x00400f50 .qword 0x0000000000400ab6\n            0x00400f58 .qword 0x0000000000400c04\n            0x00400f60 .qword 0x0000000000400c04\n            0x00400f68 .qword 0x0000000000400c04\n            0x00400f70 .qword 0x0000000000400c04\n            0x00400f78 .qword 0x0000000000400b99\nAs we can see, the address 0x400c04 is used a lot, and besides that there are 9 different addresses. Lets see that 0x400c04 first!\n\n\n\nvmloop bb-0c04\n\n\nWe get the message “Wrong!”, and the function just returns 0. This means that those are not valid instructions (they are valid bytecode though, they can be e.g. parameters!) We should flag 0x400c04 accordingly:\n[0x00400ec0]> f not_instr @ 0x0000000000400c04\nAs for the other offsets, they all seem to be doing something meaningful, so we can assume they belong to valid instructions. I’m going to flag them using the instructions’ ASCII values:\n[0x00400ec0]> f instr_A @ 0x0000000000400a80\n[0x00400ec0]> f instr_C @ 0x0000000000400b6d\n[0x00400ec0]> f instr_D @ 0x0000000000400b17\n[0x00400ec0]> f instr_I @ 0x0000000000400aec\n[0x00400ec0]> f instr_J @ 0x0000000000400bc1\n[0x00400ec0]> f instr_P @ 0x0000000000400b42\n[0x00400ec0]> f instr_R @ 0x0000000000400be5\n[0x00400ec0]> f instr_S @ 0x0000000000400ab6\n[0x00400ec0]> f instr_X @ 0x0000000000400b99\nOk, so these offsets were not on the graph, so it is time to define basic blocks for them!\n\nrizin tip: You can define basic blocks using the afb+ command. You have to supply what function the block belongs to, where does it start, and what is its size. If the block ends in a jump, you have to specify where does it jump too. If the jump is a conditional jump, the false branch’s destination address should be specified too.\n\nWe can get the start and end addresses of these basic blocks from the full disasm of vmloop.\n\n\n\nvmloop full\n\n\nAs I’ve mentioned previously, the function itself is pretty short, and easy to read, especially with our annotations. But a promise is a promise, so here is how we can create the missing basic blocks for the instructions:\n[0x00400ec0]> afb+ 0x00400a45 0x00400a80 0x00400ab6-0x00400a80 0x400c15\n[0x00400ec0]> afb+ 0x00400a45 0x00400ab6 0x00400aec-0x00400ab6 0x400c15\n[0x00400ec0]> afb+ 0x00400a45 0x00400aec 0x00400b17-0x00400aec 0x400c15\n[0x00400ec0]> afb+ 0x00400a45 0x00400b17 0x00400b42-0x00400b17 0x400c15\n[0x00400ec0]> afb+ 0x00400a45 0x00400b42 0x00400b6d-0x00400b42 0x400c15\n[0x00400ec0]> afb+ 0x00400a45 0x00400b6d 0x00400b99-0x00400b6d 0x400c15\n[0x00400ec0]> afb+ 0x00400a45 0x00400b99 0x00400bc1-0x00400b99 0x400c15\n[0x00400ec0]> afb+ 0x00400a45 0x00400bc1 0x00400be5-0x00400bc1 0x400c15\n[0x00400ec0]> afb+ 0x00400a45 0x00400be5 0x00400c04-0x00400be5 0x400c15\nIt is also apparent from the disassembly that besides the instructions there are three more basic blocks. Lets create them too!\n[0x00400ec0]> afb+ 0x00400a45 0x00400c15 0x00400c2d-0x00400c15 0x400c3c 0x00400c2d\n[0x00400ec0]> afb+ 0x00400a45 0x00400c2d 0x00400c3c-0x00400c2d 0x400c4d 0x00400c3c\n[0x00400ec0]> afb+ 0x00400a45 0x00400c3c 0x00400c4d-0x00400c3c 0x400c61\nNote that the basic blocks starting at 0x00400c15 and 0x00400c2d ending in a conditional jump, so we had to set the false branch’s destination too!\nAnd here is the graph in its full glory after a bit of manual restructuring:\n\n\n\nvmloop graph\n\n\nI think it worth it, don’t you? :) (Well, the restructuring did not really worth it, because it is apparently not stored when you save the project.)\n\nrizin tip: You can move the selected node around in graph view using the HJKL keys.\n\nBy the way, here is how IDA’s graph of this same function looks like for comparison:\n\n\n\nIDA graph\n\n\nAs we browse through the disassembly of the instr_LETTER basic blocks, we should realize a few things. The first: all of the instructions starts with a sequence like these:\n\n\n\nvmloop bb-0a80\n\n\n\n\n\nvmloop bb-0ab6\n\n\nIt became clear now that the 9 dwords at sym.instr_dirty are not simply indicators that an instruction got executed, but they are used to count how many times an instruction got called. Also I should have realized earlier that sym.good_if_le_9 (0x6020f0) is part of this 9 dword array, but yeah, well, I didn’t, I have to live with it… Anyways, what the condition “sym.good_if_le_9 have to be lesser or equal 9” really means is that instr_P can not be executed more than 9 times:\n\n\n\nvmloop bb-0b42\n\n\nAnother similarity of the instructions is that 7 of them calls a function with either one or two parameters, where the parameters are the next, or the next two bytecodes. One parameter example:\n\n\n\nvmloop bb-0aec\n\n\nAnd a two parameters example:\n\n\n\nvmloop bb-0a80_full\n\n\nWe should also realize that these blocks put the number of bytes they eat up of the bytecode (1 byte instruction + 1 or 2 bytes arguments = 2 or 3) into a local variable at 0xc. rizin did not recognize this local var, so lets do it manually!\n:> afv 0xc instr_ptr_step dword\nIf we look at instr_J we can see that this is an exception to the above rule, since it puts the return value of the called function into instr_ptr_step instead of a constant 2 or 3:\n\n\n\nvmloop bb-0bc1\n\n\nAnd speaking of exceptions, here are the two instructions that do not call functions:\n\n\n\nvmloop bb-0be5\n\n\nThis one simply puts the next bytecode (the first the argument) into eax, and jumps to the end of vmloop. So this is the VM’s ret instruction, and we know that vmloop has to return “*”, so “R*” should be the last two bytes of our bytecode.\nThe next one that does not call a function:\n\n\n\nvmloop bb-0b6d\n\n\nThis is a one argument instruction, and it puts its argument to 0x6020c0. Flag that address!\n:> f sym.written_by_instr_C 4 @ 0x6020c0\nOh, and by the way, I do have a hunch that instr_C also had a function call in the original code, but it got inlined by the compiler. Anyways, so far we have these two instructions:\n\ninstr_R(a1): returns with a1\ninstr_C(a1): writes a1 to sym.written_by_instr_C\n\nAnd we also know that these accept one argument,\n\ninstr_I\ninstr_D\ninstr_P\ninstr_X\ninstr_J\n\nand these accept two:\n\ninstr_A\ninstr_S\n\nWhat remains is the reversing of the seven functions that are called by the instructions, and finally the construction of a valid bytecode that gives us the flag.\n###instr_A\nThe function this instruction calls is at offset 0x40080d, so lets seek there!\n[offset]> 0x40080d\n\nrizin tip: In visual mode you can just hit <Enter> when the current line is a jump or a call, and rizin will seek to the destination address.\n\nIf we seek to that address from the graph mode, we are presented with a message that says “Not in a function. Type ‘df’ to define it here. This is because the function is called from a basic block rizin did not recognize, so rizin could not find the function either. Lets obey, and type df! A function is indeed created, but we want some meaningful name for it. So press dr while still in visual mode, and name this function instr_A!\n\n\n\ninstr_A minimap\n\n\n\nrizin tip: You should realize that these commands are all part of the same menu system in visual mode I was talking about when we first used Cd to declare sym.memory as data.\n\nOk, now we have our shiny new fcn.instr_A, lets reverse it! We can see from the shape of the minimap that probably there is some kind cascading if-then-elif, or a switch-case statement involved in this function. This is one of the reasons the minimap is so useful: you can recognize some patterns at a glance, which can help you in your analysis (remember the easily recognizable for loop from a few paragraphs before?) So, the minimap is cool and useful, but I’ve just realized that I did not yet show you the full graph mode, so I’m going to do this using full graph. The first basic blocks:\n\n\n\ninstr_A bb-080d\n\n\nThe two function arguments (rdi and rsi) are stored in local variables, and the first is compared to 0. If it is, the function returns (you can see it on the minimap), otherwise the same check is executed on the second argument. The function returns from here too, if the argument is zero. Although this function is really tiny, I am going to stick with my methodology, and rename the local vars:\n:> afvn local_1 arg1\n:> afvn local_2 arg2\nAnd we have arrived to the predicted switch-case statement, and we can see that arg1’s value is checked against “M”, “P”, and “C”.\n\n\n\ninstr_A switch values\n\n\nThis is the “M” branch:\n\n\n\ninstr_A switch-M\n\n\nIt basically loads an address from offset 0x602088 and adds arg2 to the byte at that address. As rizin kindly shows us in a comment, 0x602088 initially holds the address of sym.memory, the area where we have to construct the “Such VM! MuCH reV3rse!” string. It is safe to assume that somehow we will be able to modify the value stored at 0x602088, so this “M” branch will be able to modify bytes other than the first. Based on this assumption, I’ll flag 0x602088 as sym.current_memory_ptr:\n:> f sym.current_memory_ptr 8 @ 0x602088\nMoving on to the “P” branch:\n\n\n\ninstr_A switch-P\n\n\nYes, this is the piece of code that allows us to modify sym.current_memory_ptr: it adds arg2 to it.\nFinally, the “C” branch:\n\n\n\ninstr_A switch-C\n\n\nWell, it turned out that instr_C is not the only instruction that modifies sym.written_by_instr_C: this piece of code adds arg2 to it.\nAnd that was instr_A, lets summarize it! Depending on the first argument, this instruction does the following:\n\narg1 == “M”: adds arg2 to the byte at sym.current_memory_ptr.\narg1 == “P”: steps sym.current_memory_ptr by arg2 bytes.\narg1 == “C”: adds arg2 to the value at sym.written_by_instr_C.\n\n###instr_S\nThis function is not recognized either, so we have to manually define it like we did with instr_A. After we do, and take a look at the minimap, scroll through the basic blocks, it is pretty obvious that these two functions are very-very similar. We can use rz-diff to see the difference.\n\nrizin tip: rz-diff is used to compare binary files. There’s a few options we can control the type of binary diffing the tool does, and to what kind of output format we want. One of the cool features is that it can generate DarumGrim-style bindiff graphs using the -g option.\n\nSince now we want to diff two functions from the same binary, we specify the offsets with -g, and use reverse4 for both binaries. Also, we create the graphs for comparing instr_A to instr_S and for comparing instr_S to instr_A.\n[0x00 ~]$ rz-diff -g 0x40080d,0x40089f  reverse4 reverse4 | xdot -\n\n\n\ninstr_S graph1\n\n\n[0x00 ~]$ rz-diff -g 0x40089f,0x40080d  reverse4 reverse4 | xdot -\n\n\n\ninstr_S graph2\n\n\nA sad truth reveals itself after a quick glance at these graphs: rz-diff is a liar! In theory, grey boxes should be identical, yellow ones should differ only at some offsets, and red ones should differ seriously. Well this is obviously not the case here - e.g. the larger grey boxes are clearly not identical. This is something I’m definitely going to take a deeper look at after I’ve finished this writeup.\nAnyways, after we get over the shock of being lied to, we can easily recognize that instr_S is basically a reverse-instr_A: where the latter does addition, the former does subtraction. To summarize this:\n\narg1 == “M”: subtracts arg2 from the byte at sym.current_memory_ptr.\narg1 == “P”: steps sym.current_memory_ptr backwards by arg2 bytes.\narg1 == “C”: subtracts arg2 from the value at sym.written_by_instr_C.\n\n###instr_I\n\n\n\ninstr_I\n\n\nThis one is simple, it just calls instr_A(arg1, 1). As you may have noticed the function call looks like call fcn.0040080d instead of call fcn.instr_A. This is because when you save and open a project, function names get lost - another thing to examine and patch in rizin!\n###instr_D\n\n\n\ninstr_D\n\n\nAgain, simple: it calls instr_S(arg1, 1).\n###instr_P\nIt’s local var rename time again!\n:> afvn local_0_1 const_M\n:> afvn local_0_2 const_P\n:> afvn local_3 arg1\n\n\n\ninstr_P\n\n\nThis function is pretty straightforward also, but there is one oddity: const_M is never used. I don’t know why it is there - maybe it is supposed to be some kind of distraction? Anyways, this function simply writes arg1 to sym.current_memory_ptr, and than calls instr_I(“P”). This basically means that instr_P is used to write one byte, and put the pointer to the next byte. So far this would seem the ideal instruction to construct most of the “Such VM! MuCH reV3rse!” string, but remember, this is also the one that can be used only 9 times!\n###instr_X\nAnother simple one, rename local vars anyways!\n:> afvn local_1 arg1\n\n\n\ninstr_X\n\n\nThis function XORs the value at sym.current_memory_ptr with arg1.\n###instr_J\nThis one is not as simple as the previous ones, but it’s not that complicated either. Since I’m obviously obsessed with variable renaming:\n:> afvn local_3 arg1\n:> afvn local_0_4 arg1_and_0x3f\n\n\n\ninstr_J\n\n\nAfter the result of arg1 & 0x3f is put into a local variable, arg1 & 0x40 is checked against 0. If it isn’t zero, arg1_and_0x3f is negated:\n\n\n\ninstr_J bb-09e1\n\n\nThe next branching: if arg1 >= 0, then the function returns arg1_and_0x3f,\n\n\n\ninstr_J bb-09e4\n\n\n\n\n\ninstr_J bb-0a1a\n\n\nelse the function branches again, based on the value of sym.written_by_instr_C:\n\n\n\ninstr_J bb-09ef\n\n\nIf it is zero, the function returns 2,\n\n\n\ninstr_J bb-0a13\n\n\nelse it is checked if arg1_and_0x3f is a negative number,\n\n\n\ninstr_J bb-09f9\n\n\nand if it is, sym.good_if_ne_zero is incremented by 1:\n\n\n\ninstr_J bb-09ff\n\n\nAfter all this, the function returns with arg1_and_0x3f:\n\n\n\ninstr_J bb-0a0e\n\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/avatao/01-reverse4/instructionset.html",
    "title": "101  .instructionset",
    "section": "",
    "text": "We’ve now reversed all the VM instructions, and have a full understanding about how it works. Here is the VM’s instruction set:\n\n\n\n\n\n\n\n\n\nInstruction\n1st arg\n2nd arg\nWhat does it do?\n\n\n\n\n“A”\n“M”\narg2\n*sym.current_memory_ptr += arg2\n\n\n\n“P”\narg2\nsym.current_memory_ptr += arg2\n\n\n\n“C”\narg2\nsym.written_by_instr_C += arg2\n\n\n“S”\n“M”\narg2\n*sym.current_memory_ptr -= arg2\n\n\n\n“P”\narg2\nsym.current_memory_ptr -= arg2\n\n\n\n“C”\narg2\nsym.written_by_instr_C -= arg2\n\n\n“I”\narg1\nn/a\ninstr_A(arg1, 1)\n\n\n“D”\narg1\nn/a\ninstr_S(arg1, 1)\n\n\n“P”\narg1\nn/a\n*sym.current_memory_ptr = arg1; instr_I(“P”)\n\n\n“X”\narg1\nn/a\n*sym.current_memory_ptr ^= arg1\n\n\n“J”\narg1\nn/a\narg1_and_0x3f = arg1 & 0x3f;if (arg1 & 0x40 != 0)  arg1_and_0x3f *= -1if (arg1 >= 0) return arg1_and_0x3f;else if (*sym.written_by_instr_C != 0) {  if (arg1_and_0x3f < 0)    ++*sym.good_if_ne_zero;  return arg1_and_0x3f;} else return 2;\n\n\n“C”\narg1\nn/a\n*sym.written_by_instr_C = arg1\n\n\n“R”\narg1\nn/a\nreturn(arg1)\n\n\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/avatao/01-reverse4/bytecode.html",
    "title": "102  .bytecode",
    "section": "",
    "text": "Well, we did the reverse engineering part, now we have to write a program for the VM with the instruction set described in the previous paragraph. Here is the program’s functional specification:\n\nthe program must return “*”\nsym.memory has to contain the string “Such VM! MuCH reV3rse!” after execution\nall 9 instructions have to be used at least once\nsym.good_if_ne_zero should not be zero\ninstr_P is not allowed to be used more than 9 times\n\nSince this document is about reversing, I’ll leave the programming part to the fellow reader :) But I’m not going to leave you empty-handed, I’ll give you one advice: Except for “J”, all of the instructions are simple, easy to use, and it should not be a problem to construct the “Such VM! MuCH reV3rse!” using them. “J” however is a bit complicated compared to the others. One should realize that its sole purpose is to make sym.good_if_ne_zero bigger than zero, which is a requirement to access the flag. In order to increment sym.good_if_ne_zero, three conditions should be met:\n\narg1 should be a negative number, otherwise we would return early\nsym.written_by_instr_C should not be 0 when “J” is called. This means that “C”, “AC”, or “SC” instructions should be used before calling “J”.\narg1_and_0x3f should be negative when checked. Since 0x3f’s sign bit is zero, no matter what arg1 is, the result of arg1 & 0x3f will always be non-negative. But remember that “J” negates arg1_and_0x3f if arg1 & 0x40 is not zero. This basically means that arg1’s 6th bit should be 1 (0x40 = 01000000b). Also, because arg1_and_0x3f can’t be 0 either, at least one of arg1’s 0th, 1st, 2nd, 3rd, 4th or 5th bits should be 1 (0x3f = 00111111b).\n\nI think this is enough information, you can go now and write that program. Or, you could just reverse engineer the quick’n’dirty one I’ve used during the CTF:\n\\x90\\x00PSAMuAP\\x01AMcAP\\x01AMhAP\\x01AM AP\\x01AMVAP\\x01AMMAP\\x01AM!AP\\x01AM AP\\x01AMMAP\\x01AMuAP\\x01AMCAP\\x01AMHAP\\x01AM AP\\x01AMrAP\\x01AMeAP\\x01AMVAP\\x01AM3AP\\x01AMrAP\\x01AMsAP\\x01AMeIPAM!X\\x00CAJ\\xc1SC\\x00DCR*\nKeep in mind though, that it was written on-the-fly, parallel to the reversing phase - for example there are parts that was written without the knowledge of all possible instructions. This means that the code is ugly and inefficient.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/avatao/01-reverse4/outro.html",
    "title": "103  .outro",
    "section": "",
    "text": "Well, what can I say? Such VM, much reverse! :)\nWhat started out as a simple writeup for a simple crackme, became a rather lengthy writeup/rizin tutorial, so kudos if you’ve read through it. I hope you enjoyed it (I know I did), and maybe even learnt something from it. I’ve surely learnt a lot about rizin during the process, and I’ve even contributed some small patches, and got a few ideas of more possible improvements.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/hackthebox/intro.html",
    "title": "104  hackthebox",
    "section": "",
    "text": "The well-known hack the box hacking training platform offers reversing challenges.\nWe talk about of retired one solved with Rizin.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/hackthebox/find-the-easy-pass/intro.html",
    "title": "105  Find The Easy Pass",
    "section": "",
    "text": "This challenge implies to find the right password to win some points.\nWe present you a methodology to solve it with Rizin in particular by its built-in debugger on the Windows operating system.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/hackthebox/find-the-easy-pass/identification.html",
    "title": "106  identification",
    "section": "",
    "text": "After un-compressing the challenge file Find The Easy Pass.zip, we can find a file named EasyPass.exe inside it.\nWe using rz-bin to identify the executable file.\nC:\\Users\\User\\Desktop\\htb>rz-bin -I EasyPass.exe\narch     x86\nbaddr    0x400000\nbinsz    402432\nbintype  pe\nbits     32\ncanary   false\nretguard false\nclass    PE32\ncmp.csum 0x00063785\ncompiled Fri Jun 19 15:22:17 1992\ncrypto   false\nendian   little\nhavecode true\nhdr.csum 0x00000000\nladdr    0x0\nlang     c\nlinenum  true\nlsyms    true\nmachine  i386\nmaxopsz  16\nminopsz  1\nnx       false\nos       windows\noverlay  false\ncc       cdecl\npcalign  0\npic      false\nrelocs   false\nsigned   false\nsanitiz  false\nstatic   false\nstripped false\nsubsys   Windows GUI\nva       true\nThat’s interesting, EasyPass.exe is an x86 program, it’s a GUI program.\nNow, we will run the program to have some better idea on what it’s doing.\n\n\n\nidentification-run-program\n\n\nWe click on the Check Password\n\n\n\nidentification-error-message-printed\n\n\nInteresting, let’s search for Wrong Password! in the executable.\nC:\\Users\\User\\Desktop\\htb>rz-bin -iz EasyPass.exe | findstr /I Wrong\n\nC:\\Users\\User\\Desktop\\htb>\nWe’re unlucky but don’t panic, we will launch a more thorough research:\nC:\\Users\\User\\Desktop\\htb>rz-bin -izz EasyPass.exe | findstr /I Wrong\n5483 0x00053600 0x00454200 15  16   CODE    ascii   Wrong Password!\nThe “Wrong Password!” string is located at 0x00454200 in the CODE section.\n\nrizin tips: The first search (-iz) works on some flag spaces but not on the whole file, while the second command (-izz) is more exhaustive.\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/hackthebox/find-the-easy-pass/find-the-validation-routine.html",
    "title": "107  Find the validation routine",
    "section": "",
    "text": "The string “Wrong Password!” is located at 0x00454200 in the CODE section.\nIn this step, we wish to find the password, our approach will be to debug the program based on the information already collected.\nSpawned new process with pid 8556, tid = 8576\n= attach 8556 8576\nbin.baddr 0x00400000\nUsing 0x400000\nasm.bits 32\n\n[0x7ffeaa1c2630]> iz~Wrong\n[0x7ffeaa1c2630]> izz~Wrong\n5483 0x00053600 0x00454200 15  16   CODE    ascii   Wrong Password!\nrizin tips: We know where is located the “Wrong Password!” at 0x00454200 in the CODE section. To do the same research, we can use the iz and izz\n\n~ is Rizin’s built-in grep command which you can use to filter the output. Here, we’ve searched for the word “Wrong” in the strings of the data section.\nSeeking to 0x00454200- the location of the string:\n[0x7ffeaa1c2630]> s 0x00454200\n\n[0x00454200]> aaaa\nWe will ask Rizin to analyze the program with aaa.\n[0x00454200]> aaaa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[Warning: Invalid range. Use different search.in=? or analysis.in=dbg.maps.x\nWarning: Invalid range. Use different search.in=? or analysis.in=dbg.maps.x\n[x] Analyze function calls (aac)\n[x] Analyze len bytes of instructions for references (aar)\n[x] Check for classes\n[TOFIX: aaft can't run in debugger mode.ions (aaft)\n[x] Type matching analysis for all functions (aaft)\n[x] Propagate noreturn information\n[x] Use -AA or aaaa to perform additional experimental analysis.\n[Warning: Invalid range. Use different search.in=? or analysis.in=dbg.maps.x\n[x] Finding function preludes\n[x] Enable constraint types analysis for variables\n[0x00454200]> V\n\nrizin tips: The V command triggers the visual mode.\n\n\n\n\nfind-the-validation-routine-wrong-password\n\n\nPress p command to switch on the code view.\n\n\n\nfind-the-validation-routine-wrong-password-code-view\n\n\nPress x to display the cross-references.\n\n\n\nfind-the-validation-routine-wrong-password-xref\n\n\nPress enter or return to jump of this reference.\n\n\n\nfind-the-validation-routine-wrong-password-jump-to-xref\n\n\nRizin allows you to have a graph view by pressing the space bar.\n\n\n\nfind-the-validation-routine-wrong-password-graph-view-not-work\n\n\nFor the graph view to work here, Rizin needs the function to be analyzed. We will help by creating it from the beginning of the function where the string “Wrong Password!” is located.\nScroll up to the address 0x00454078.\n\n\n\nfind-the-validation-routine-wrong-password-prologue-function\n\n\nPress d and f to analyze the function.\n\n\n\nfind-the-validation-routine-wrong-password-analyze-function\n\n\nNow if you press the space bar the graph will be displayed.\n\n\n\nfind-the-validation-routine-wrong-password-graph-view\n\n\n\nrizin tips: to move around of graph, you can use the same keys like Vim: h, j, k, l.\n\n\n\n\nfind-the-validation-routine-wrong-password-interesting-code\n\n\nBy deduction, the address 0x00427a30 is the function which popup the messagebox.\nThe right node, print the “Wrong Password!”, the left one, probably prints the congratulations message.\nAt 0x00404628 is what which looks like a validation function because it is followed by a conditional test that either leads to the “Wrong Password!” message or the congratulation message.\nPress g and enter the address 0x004041dc to check if this one is the congratulation message.\n\n\n\nfind-the-validation-routine-wrong-jump-to-congrats\n\n\nPress n to ignore the create function message and press P.\n\n\n\nfind-the-validation-routine-congrats\n\n\nPress x and p.\n\n\n\nfind-the-validation-routine-congrats-node\n\n\nPress ; to enter a comment:\n\n\n\nfind-the-validation-routine-congrats-node-comment\n\n\n\n\n\nfind-the-validation-routine-congrats-node-comment-1\n\n\n\n\n\nfind-the-validation-routine-breakpoint-to-fish-code\n\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/crackmes/hackthebox/find-the-easy-pass/bonus.html",
    "title": "108  Bonus",
    "section": "",
    "text": "In the previous pages, we found out the the right password. Now, we can figure out whether it is calculated at runtime or hard-coded into the binary.\nTo do this, we will look at what happens from the beginning of the current function from the address 0x00454084.\nAs a first, we’ll go to the address 0x00454084.\n\n\n\nbonus-01\n\n\nTake a break and observe the assembly code. You will see a repeating code sequence :\nmov eax, [ebp - X] ; or X is between 0x8 and 0x24\nmov edx, Y ; or Y is between 0x00454188  and 0x004541d0\nLook the address 0x00454188.\n\n\n\nbonus-02\n\n\n\n\n\nbonus-03\n\n\nPay attention to the previous picture. You can see the password broken down letter by letter.\nWe can see that the routine is concatenating each letter into a string and compares it to a user input.\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  },
  {
    "href": "src/refcard/intro.html#survival-guide",
    "title": "109  Rizin Reference Card",
    "section": "109.1 Survival Guide",
    "text": "Those are the basic commands you will want to know and use for moving around a binary and getting information about it.\n\n\n\nCommand\nDescription\n\n\n\n\ns (tab)\nSeek to a different place\n\n\nx [nbytes]\nHexdump of nbytes, $b by default\n\n\naa\nAuto analyze\n\n\npdf@ funcname\nDisassemble function (main, fcn, etc.)\n\n\nf fcn(Tab)\nList functions\n\n\nf str(Tab)\nList strings\n\n\nfr [flagname] [newname]\nRename flag\n\n\npsz [offset]~grep\nPrint strings and grep for one\n\n\naxF [flag]\nFind cross reference for a flag"
  },
  {
    "href": "src/refcard/intro.html#flags",
    "title": "109  Rizin Reference Card",
    "section": "109.2 Flags",
    "text": "Flags are like bookmarks, but they carry some extra information like size, tags or associated flagspace. Use the f command to list, set, get them.\n\n\n\nCommand\nDescription\n\n\n\n\nf\nList flags\n\n\nfd $$\nDescribe an offset\n\n\nfj\nDisplay flags in JSON\n\n\nfl\nShow flag length\n\n\nfx [flagname]\nShow hexdump of flag\n\n\nfC [name] [comment]\nSet flag comment"
  },
  {
    "href": "src/refcard/intro.html#flagspaces",
    "title": "109  Rizin Reference Card",
    "section": "109.3 Flagspaces",
    "text": "Flags are created into a flagspace, by default none is selected, and listing flags will list them all. To display a subset of flags you can use the fs command to restrict it.\n\n\n\nCommand\nDescription\n\n\n\n\nfs\nDisplay flagspaces\n\n\nfs *\nSelect all flagspaces\n\n\nfs [space]\nSelect one flagspace"
  },
  {
    "href": "src/refcard/intro.html#information",
    "title": "109  Rizin Reference Card",
    "section": "109.4 Information",
    "text": "Binary files have information stored inside the headers. The i command uses the RzBin api and allows us to the same things rz-bin do. Those are the most common ones.\n\n\n\nCommand\nDescription\n\n\n\n\nii\nInformation on imports\n\n\niI\nInfo on binary\n\n\nie\nDisplay entrypoint\n\n\niS\nDisplay sections\n\n\nir\nDisplay relocations\n\n\niz\nList strings (izz, izzz)"
  },
  {
    "href": "src/refcard/intro.html#print-string",
    "title": "109  Rizin Reference Card",
    "section": "109.5 Print string",
    "text": "There are different ways to represent a string in memory. The ps command allows us to print it in utf-16, pascal, zero terminated, .. formats.\n\n\n\nCommand\nDescription\n\n\n\n\npsz [offset]\nPrint zero terminated string\n\n\npsb [offset]\nPrint strings in current block\n\n\npsx [offset]\nShow string with scaped chars\n\n\npsp [offset]\nPrint pascal string\n\n\npsw [offset]\nPrint wide string"
  },
  {
    "href": "src/refcard/intro.html#visual-mode",
    "title": "109  Rizin Reference Card",
    "section": "109.6 Visual mode",
    "text": "The visual mode is the standard interactive interface of rizin.\nTo enter in visual mode use the v or V command, and then you’ll only have to press keys to get the actions happen instead of commands.\n\n\n\nCommand\nDescription\n\n\n\n\nV\nEnter visual mode\n\n\np/P\nRotate modes (hex, disasm, debug, words, buf)\n\n\nc\nToggle (c)ursor\n\n\nq\nBack to rizin shell\n\n\nhjkl\nMove around (or HJKL) (left-down-up-right)\n\n\nEnter\nFollow address of jump/call\n\n\nsS\nStep/step over\n\n\no\nToggle asm.pseudo and asm.esil\n\n\n.\nSeek to program counter\n\n\n/\nIn cursor mode, search in current block\n\n\n:cmd\nRun rizin command\n\n\n;[-]cmt\nAdd/remove comment\n\n\n/*+-[]\nChange block size, [] = resize hex.cols\n\n\n<,>\nSeek aligned to block size\n\n\ni/a/A\n(i)nsert hex, (a)ssemble code, visual (A)ssembler\n\n\nb\nToggle breakpoint\n\n\nB\nBrowse evals, symbols, flags, classes, …\n\n\nd[f?]\nDefine function, data, code, ..\n\n\nD\nEnter visual diff mode (set diff.from/to)\n\n\ne\nEdit eval configuration variables\n\n\nf/F\nSet/unset flag\n\n\ngG\nGo seek to begin and end of file (0-$s)\n\n\nmK/’K\nMark/go to Key (any key)\n\n\nn/N\nSeek next/prev function/flag/hit (scr.nkey)\n\n\nC\nToggle (C)olors\n\n\nR\nRandomize color palette (ecr)\n\n\ntT\nTab related. see also tab\n\n\nv\nVisual code analysis menu\n\n\nV\n(V)iew graph (agv?)\n\n\nwW\nSeek cursor to next/prev word\n\n\nuU\nUndo/redo seek\n\n\nx\nShow xrefs of current func from/to data/code\n\n\nyY\nCopy and paste selection\n\n\nz\nfold/unfold comments in disassembly"
  },
  {
    "href": "src/refcard/intro.html#searching",
    "title": "109  Rizin Reference Card",
    "section": "109.7 Searching",
    "text": "There are many situations where we need to find a value inside a binary or in some specific regions. Use the e search.in=? command to choose where the / command may search for the given value.\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\n/ foo\\00\nSearch for string ’foo\\0’\n\n\n/b\nSearch backwards\n\n\n//\nRepeat last search\n\n\n/w foo\nSearch for wide string ’f\\0o\\0o\\0’\n\n\n/wi foo\nSearch for wide string ignoring case\n\n\n/! ff\nSearch for first occurrence not matching\n\n\n/i foo\nSearch for string ’foo’ ignoring case\n\n\n/e /E.F/i\nMatch regular expression\n\n\n/x a1b2c3\nSearch for bytes; spaces and uppercase nibbles are allowed, same as /x A1 B2 C3\n\n\n/x a1..c3\nSearch for bytes ignoring some nibbles (auto-generates mask, in this example: ff00ff)\n\n\n/x a1b2:fff3\nSearch for bytes with mask (specify individual bits)\n\n\n/d 101112\nSearch for a deltified sequence of bytes\n\n\n/!x 00\nInverse hexa search (find first byte != 0x00)\n\n\n/c jmp [esp]\nSearch for asm code (see search.asmstr)\n\n\n/a jmp eax\nAssemble opcode and search its bytes\n\n\n/A\nSearch for AES expanded keys\n\n\n/r sym.printf\nAnalyze opcode reference an offset\n\n\n/R\nSearch for ROP gadgets\n\n\n/P\nShow offset of previous instruction\n\n\n/m magicfile\nSearch for matching magic file\n\n\n/p patternsize\nSearch for pattern of given size\n\n\n/z min max\nSearch for strings of given size\n\n\n/v[?248] num\nLook for a asm.bigendian 32bit value"
  },
  {
    "href": "src/refcard/intro.html#usable-variables-in-expression",
    "title": "109  Rizin Reference Card",
    "section": "109.8 Usable variables in expression",
    "text": "The ?$? command will display the variables that can be used in any math operation inside the rizin shell. For example, using the ? $$ command to evaluate a number or ?v to just the value in one format.\nAll commands in rizin that accept a number supports the use of those variables.\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\n\\[            | here (current virtual seek)|\n| \\]$\ncurrent non-temporary virtual seek\n\n\n$?\nlast comparison value\n\n\n$alias=value\nalias commands (simple macros)\n\n\n$b\nblock size\n\n\n$B\nbase address (aligned lowest map address)\n\n\n$f\njump fail address (e.g. jz 0x10 => next instruction)\n\n\n$fl\nflag length (size) at current address (fla; pD $l @ entry0)\n\n\n$F\ncurrent function size\n\n\n$FB\nbegin of function\n\n\n$Fb\naddress of the current basic block\n\n\n$Fs\nsize of the current basic block\n\n\n$FE\nend of function\n\n\n$FS\nfunction size\n\n\n$Fj\nfunction jump destination\n\n\n$Ff\nfunction false destination\n\n\n$FI\nfunction instructions\n\n\n\\(c,\\)r\nget width and height of terminal\n\n\n$Cn\nget nth call of function\n\n\n$Dn\nget nth data reference in function\n\n\n$D\ncurrent debug map base address ?v $D @ rsp\n\n\n$DD\ncurrent debug map size\n\n\n$e\n1 if end of block, else 0\n\n\n$j\njump address (e.g. jmp 0x10, jz 0x10 => 0x10)\n\n\n$Ja\nget nth jump of function\n\n\n$Xn\nget nth xref of function\n\n\n$l\nopcode length\n\n\n$m\nopcode memory reference (e.g. mov eax,[0x10] => 0x10)\n\n\n$M\nmap address (lowest map address)\n\n\n$o\nhere (current disk io offset)\n\n\n$p\ngetpid()\n\n\n$P\npid of children (only in debug)\n\n\n$s\nfile size\n\n\n$S\nsection offset\n\n\n$SS\nsection size\n\n\n$v\nopcode immediate value (e.g. lui a0,0x8010 => 0x8010)\n\n\n$w\nget word size, 4 if asm.bits=32, 8 if 64, …\n\n\n${ev}\nget value of eval config variable\n\n\n$r{reg}\nget value of named register\n\n\n$k{kv}\nget value of an sdb query value\n\n\n$s{flag}\nget size of flag\n\n\nRzNum\n$variables usable in math expressions"
  },
  {
    "href": "src/credits/credits.html",
    "title": "110  Authors & Contributors",
    "section": "",
    "text": "This book wouldn’t be possible without the help of a large list of contributors who have been reviewing, writing and reporting bugs and stuff in the rizin project as well as in this book.\n\n110.0.1 The rizin book\nThis book was started by maijin as a new version of the original radare1 book written by pancake. It was updated and reworked significantly for the radare2. With the rizin fork the book has been reworked again.\n\nOld radare2 book https://book.rada.re\n\nMany thanks to everyone who has been involved with the gitbook:\nAdrian Studer, Ahmed Mohamed Abd El-MAwgood, Akshay Krishnan R, Andrew Hoog, Anton Kochkov, Antonio Sánchez, Austin Hartzheim, Aswin C (officialcjunior), Bob131, DZ_ruyk, David Tomaschik, Eric, Fangrui Song, Francesco Tamagni, FreeArtMan, Gerardo García Peña, Giuseppe, Grigory Rechistov, Hui Peng, ITAYC0HEN, Itay Cohen, Jeffrey Crowell, John, Judge Dredd (key 6E23685A), Jupiter, Kevin Grandemange, Kevin Laeufer, Luca Di Bartolomeo, Lukas Dresel, Maijin, Michael Scherer, Mike, Nikita Abdullin, Paul, Paweł Łukasik, Peter C, RandomLive, Ren Kimura, Reto Schneider, SchumBlubBlub, SkUaTeR, Solomon, Srimanta Barua, Sushant Dinesh, TDKPS, Thanat0s, Vanellope, Vex Woo, Vorlent, XYlearn, Yuri Slobodyanyuk, ali, aoighost, condret, hdznrrd, izhuer, jvoisin, kij, madblobfish, muzlightbeer, pancake, polym (Tim), puddl3glum, rizin, sghctoma, shakreiner, sivaramaaa, taiyu, vane11ope, xarkes.\n\n\n\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    target: function(trigger) {\n      return trigger.previousElementSibling;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    setTimeout(function() {\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn) {\n    window.tippy(el, {\n      allowHTML: true,\n      content: contentFn,\n      maxWidth: 500,\n      delay: 100,\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start'\n    }); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i<noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i<bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const cites = ref.parentNode.getAttribute('data-cites').split(' ');\n    tippyHover(ref, function() {\n      var popup = window.document.createElement('div');\n      cites.forEach(function(cite) {\n        var citeDiv = window.document.createElement('div');\n        citeDiv.classList.add('hanging-indent');\n        citeDiv.classList.add('csl-entry');\n        var biblioDiv = window.document.getElementById('ref-' + cite);\n        if (biblioDiv) {\n          citeDiv.innerHTML = biblioDiv.innerHTML;\n        }\n        popup.appendChild(citeDiv);\n      });\n      return popup.innerHTML;\n    });\n  }\n});"
  }
]